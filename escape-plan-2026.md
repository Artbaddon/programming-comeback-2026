# ðŸš€ THE COMPLETE ESCAPE PLAN 2026
**Thursday, January 1, 2026 â†’ Monday, July 14, 2026 | 196 Days to Hireable**

---

## ðŸ“‹ Table of Contents
1. [Your Mission & Commitment](#your-mission--commitment)
2. [Session Structure & Logging](#session-structure--logging)
3. [The 5-Phase Strategy](#the-5-phase-strategy)
4. [Phase 1: Foundations (Jan 1 - Feb 14) - Days 1-45](#phase-1-foundations-jan-1---feb-14)
5. [Phase 2: Backend Mastery (Feb 15 - Mar 28) - Days 46-87](#phase-2-backend-mastery-feb-15---mar-28)
6. [Phase 3: Frontend Mastery (Mar 29 - May 9) - Days 88-128](#phase-3-frontend-mastery-mar-29---may-9)
7. [Phase 4: Full-Stack + Advanced (May 10 - Jun 14) - Days 129-166](#phase-4-full-stack--advanced-may-10---jun-14)
8. [Phase 5: Interview Prep & Job Hunt (Jun 15 - Jul 14) - Days 167-196](#phase-5-interview-prep--job-hunt-jun-15---jul-14)
9. [Complete Resources Arsenal](#complete-resources-arsenal)
10. [Weekly Progress Checkpoints](#weekly-progress-checkpoints)

---

## Your Mission & Commitment

### Current Reality (January 1, 2026)
- **Job:** Intern at HCL Domino/LotusScript shop (legacy hell)
- **Contract End:** July 14, 2026 (uncertainty ahead)
- **Current Skills:** Old tech, bad practices, no modern experience
- **Problem:** Not hireable in modern market

### Time Investment
**Structure:** 50 minutes coding + 10 minutes rest = 1 session

| Day | Sessions | Hours |
|-----|----------|-------|
| Mon-Fri | 2 sessions/day | 2 hours/day |
| Saturday | 4 sessions | 4 hours |
| Sunday | 4 sessions | 4 hours |
| **Weekly** | **18 sessions** | **18 hours** |
| **Total (28 weeks)** | **504 sessions** | **504 hours** |

### The Mission
**Transform from legacy developer to hireable modern full-stack engineer in 6 months.**

### Core Rules
1. **NO AI-generated code.** Type every line yourself. AI is for guidance only (after 15min struggle).
2. **Focus on transferable skills.** Algorithms > frameworks. Problem-solving lasts forever.
3. **Build, don't watch.** Coding > tutorials.
4. **Track everything.** Log sessions, reflect, adjust.
5. **No zero days.** Even 1 session counts.

### Success Criteria (July 14, 2026)
- âœ… JavaScript ES6+ mastery (async, closures, prototypes)
- âœ… TypeScript proficiency
- âœ… React + React Router + state management
- âœ… Node.js + Express + NestJS backend skills
- âœ… PostgreSQL + Prisma ORM
- âœ… Docker & Docker Compose
- âœ… Redis caching basics
- âœ… Git/GitHub advanced workflows
- âœ… 50+ LeetCode problems solved
- âœ… 5+ portfolio projects deployed
- âœ… Pass technical interviews
- âœ… Active job applications or offers

---

## Session Structure & Logging

### Session Template

```markdown
## Session [#]: [Topic]
**Date:** [Day, Month DD, YYYY]
**Start:** [Time] | **End:** [Time]
**Focus:** [Main learning objective]

### Pre-Session Questions (Answer BEFORE coding)
1. [Question 1 about topic]
2. [Question 2 about topic]

**My answers:**
- 
- 

### Resources
- [Resource 1 with link]
- [Resource 2 with link]

### Code & Notes (Write during session)

**What it is:**
[Explain in your own words]

**Why it exists:**
[The problem it solves]

**How it works:**
[Mechanism/process]

**Example:**
```javascript
// Code example with comments explaining each line
```

**When to use:**
[Real-world use cases]

---

### [Main Concept 2]

[Same structure as above]

---

## Aha Moments ðŸ’¡
- [Something that clicked for you]
- [Connection you made between concepts]

---

## Confusion Points â“
- [What's still fuzzy]
- [Questions to research later]

---

## Daily Exercises âœ…

1. [ ] **Exercise 1:** [Description]
2. [ ] **Exercise 2:** [Description]
3. [ ] **Exercise 3:** [Description]

**My Solution Code / Notes:**
```javascript
// Paste your solution code here
```

---

## Code I Wrote (Project/Experiment)

**File(s):** `[filename.js]`

**What I built:**
- [Brief description]

**Key techniques used:**
- 
- 

**Bugs I hit:**
- [Problem you encountered]
- [How you solved it]

---

## Post-Session Recall (CLOSE EVERYTHING FIRST!)

**1. [Recall question 1]**
[Your answer from memory]

**2. [Recall question 2]**
[Your answer from memory]

**3. [Recall question 3]**
[Your answer from memory]

**4. What's one thing I still don't fully understand?**
[Honest answer]

**5. The "ELI5" Summary**
[Explain the main concept in ONE simple sentence]

---

## Next Session Focus
- [What you'll study next]

---

## Reflection

**What went well:**
- 

**What was hard:**
- 

**Time management:**
- Did I stay focused? Yes/No

**Energy level:** X/10
**Confidence on this topic:** X/10

---
```

### Progress Log Template

```markdown
# Progress Log - [Month] 2026

## Week X (Date - Date)

### [Day], [Date] - Day X
**Goal:** [Topic]
**Status:** [x] Completed / [~] Partial / [ ] Skipped
**Sessions:** X/2 (weekday) or X/4 (weekend)
**Time:** X minutes

**Notes:**
- [What you learned]
- [What was challenging]
- [What clicked]

**Commits:**
- [commit message]

---
```

---

## The Strategy Overview

### Phase Breakdown

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  PHASE 1: FOUNDATIONS (Jan 1 - Feb 14) - 6.5 weeks             â”‚
â”‚  JavaScript ES6+ | HTML/CSS | DOM | Git | Node basics          â”‚
â”‚  Sessions: ~117 | Projects: 3                                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  PHASE 2: BACKEND MASTERY (Feb 15 - Mar 28) - 6 weeks          â”‚
â”‚  Express.js | TypeScript | PostgreSQL | Docker | APIs          â”‚
â”‚  Sessions: ~108 | Projects: 2                                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  PHASE 3: FRONTEND MASTERY (Mar 29 - May 9) - 6 weeks          â”‚
â”‚  React | React+TS | State Management | Styling                 â”‚
â”‚  Sessions: ~108 | Projects: 2                                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  PHASE 4: FULL-STACK + ADVANCED (May 10 - Jun 14) - 5 weeks    â”‚
â”‚  NestJS | Redis | Full-stack Projects | CI/CD                  â”‚
â”‚  Sessions: ~90 | Projects: 1 (Capstone)                        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  PHASE 5: INTERVIEW PREP (Jun 15 - Jul 14) - 4.5 weeks         â”‚
â”‚  Algorithms | System Design | Mock Interviews | Applications   â”‚
â”‚  Sessions: ~81 | LeetCode: 50+ problems                        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

# PHASE 1: FOUNDATIONS
## January 1 - February 14 (6.5 weeks)

**Goal:** Build rock-solid JavaScript foundation + basic web dev skills

---

## Week 1 (Jan 1-7): Modern JavaScript Core

### Thursday, Jan 1 - Day 1
**Topic:** Variables & Data Types
**Sessions:** 2 (it's a holiday - treat as special day)

#### Session 1: Variables (50 min)
**Pre-Session Questions:**
1. What's the difference between `let`, `const`, and `var`?
2. What is "hoisting" in JavaScript?

**Core Topics:**
- `let` vs `const` vs `var`
- Block scope vs function scope
- Temporal Dead Zone
- Hoisting behavior

**Resources:**
- [JavaScript.info: Variables](https://javascript.info/variables) (15 min read)
- [JavaScript.info: Variable Scope](https://javascript.info/closure#lexical-environment) (10 min read)

**Exercises:**
1. Declare a variable with `var` inside an `if` block. Can you access it outside? Try the same with `let`.
2. Try to reassign a `const` variable. What happens? Now try to modify a property of a `const` object.
3. Write code that demonstrates hoisting: call a function before its declaration, then try with `var` vs `let`.

**Post-Session Recall:**
1. Explain the difference between `let` and `const` without looking.
2. What is the Temporal Dead Zone?
3. When would you ever use `var`? (Trick question!)

---

#### Session 2: Data Types & Template Literals (50 min)
**Pre-Session Questions:**
1. What are the primitive types in JavaScript?
2. How do you embed expressions inside strings?

**Core Topics:**
- Primitive types: string, number, boolean, null, undefined, symbol, bigint
- Type coercion (`==` vs `===`)
- Template literals (backticks)
- Multi-line strings
- Expression interpolation

**Resources:**
- [JavaScript.info: Data Types](https://javascript.info/types) (15 min)
- [MDN: Template Literals](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals) (10 min)

**Exercises:**
1. Create variables of each primitive type. Use `typeof` to verify.
2. Demonstrate type coercion: What does `"5" + 3` return? What about `"5" - 3`? Why?
3. Create a multi-line template literal that includes a user object's properties: name, age, and a calculated birth year.

**Post-Session Recall:**
1. List all 7 primitive types from memory.
2. Why is `typeof null` equal to "object"? (Historical bug!)
3. Write a template literal example from memory.

**Commit:** `Day 1: Variables, data types, template literals`

---

### Friday, Jan 2 - Day 2
**Topic:** Arrow Functions
**Sessions:** 2

#### Session 1: Arrow Function Syntax (50 min)
**Pre-Session Questions:**
1. What are arrow functions?
2. How do they differ from regular functions?

**Core Topics:**
- Arrow function syntax variations
- Implicit return (single expression)
- Explicit return (with curly braces)
- Returning objects (parentheses trick)
- Parameters: zero, one, multiple

**Resources:**
- [JavaScript.info: Arrow Functions Basics](https://javascript.info/arrow-functions-basics) (15 min)

**Exercises:**
1. Convert these to arrow functions:
```javascript
function add(a, b) { return a + b; }
function square(x) { return x * x; }
function greet() { return "Hello!"; }
```
2. Create an arrow function that returns an object `{ name: "John", age: 25 }` implicitly.
3. Create a one-liner that checks if a number is even.

**Post-Session Recall:**
1. Write the shortest possible arrow function that doubles a number.
2. How do you implicitly return an object from an arrow function?
3. What's the difference between `x => x * 2` and `x => { x * 2 }`?

---

#### Session 2: Arrow Functions & `this` (50 min)
**Pre-Session Questions:**
1. What is `this` in JavaScript?
2. Why do arrow functions handle `this` differently?

**Core Topics:**
- `this` binding in regular functions
- `this` binding in arrow functions (lexical)
- When NOT to use arrow functions
- Object methods and `this`

**Resources:**
- [JavaScript.info: Arrow Functions Revisited](https://javascript.info/arrow-functions) (15 min)

**Exercises:**
1. Create an object with a method using a regular function. Log `this`. What do you see?
2. Change that method to an arrow function. Log `this`. What changed?
3. Create a `setTimeout` inside an object method. Why does `this` break? Fix it with an arrow function.
4. Why can't arrow functions be used as constructors? Try it!

**Post-Session Recall:**
1. Explain lexical `this` in your own words.
2. Give 2 situations where you should NOT use arrow functions.
3. How would you fix a `this` problem in a callback without using arrow functions?

**Commit:** `Day 2: Arrow functions, this binding`

---

### Saturday, Jan 3 - Day 3
**Topic:** Destructuring & Spread/Rest
**Sessions:** 4

#### Session 1: Array Destructuring (50 min)
**Pre-Session Questions:**
1. What is destructuring?
2. Why would you want to "unpack" an array?

**Core Topics:**
- Basic array destructuring
- Skipping elements
- Default values
- Rest pattern with arrays

**Resources:**
- [JavaScript.info: Destructuring - Arrays](https://javascript.info/destructuring-assignment#array-destructuring) (15 min)

**Exercises:**
1. Extract the first two elements from `[1, 2, 3, 4, 5]` into variables.
2. Skip the second element: get first and third from `["a", "b", "c"]`.
3. Use default values: destructure `[1]` but provide default for second element.
4. Use rest to get first element and remaining elements separately.

**Post-Session Recall:**
1. How do you skip elements in array destructuring?
2. What does `const [first, ...rest] = arr` do?
3. Write the swap pattern from memory: swap `a` and `b` using destructuring.

---

#### Session 2: Object Destructuring (50 min)
**Pre-Session Questions:**
1. How is object destructuring different from array destructuring?
2. Can you rename variables during destructuring?

**Core Topics:**
- Basic object destructuring
- Renaming variables (`: newName`)
- Default values
- Nested destructuring
- Rest with objects

**Resources:**
- [JavaScript.info: Destructuring - Objects](https://javascript.info/destructuring-assignment#object-destructuring) (15 min)

**Exercises:**
1. Extract `name` and `age` from `{ name: "John", age: 25, city: "NYC" }`.
2. Extract `name` but rename it to `userName`.
3. Extract `country` with default value "Unknown" from an object that doesn't have it.
4. Destructure a nested object: `{ user: { name: "John", address: { city: "NYC" } } }`.

**Post-Session Recall:**
1. How do you rename a variable during destructuring?
2. Write nested destructuring to get `city` from `{ person: { address: { city: "X" } } }`.
3. What does `const { a, ...rest } = obj` give you?

---

#### Session 3: Spread Operator (50 min)
**Pre-Session Questions:**
1. What does the spread operator (`...`) do?
2. How is spread different from rest?

**Core Topics:**
- Spread in arrays (copying, merging)
- Spread in objects (copying, merging)
- Spread in function calls
- Shallow copy warning

**Resources:**
- [JavaScript.info: Spread Syntax](https://javascript.info/rest-parameters-spread#spread-syntax) (15 min)

**Exercises:**
1. Create a copy of an array using spread.
2. Merge two arrays: `[1, 2]` and `[3, 4]` into `[1, 2, 3, 4]`.
3. Clone an object and override one property.
4. Use spread to pass array elements as function arguments: `Math.max(...numbers)`.
5. Demonstrate shallow copy problem with nested objects.

**Post-Session Recall:**
1. What's the difference between spread and rest?
2. Why is `[...arr]` a shallow copy? What's the danger?
3. How do you merge two objects with spread?

---

#### Session 4: Rest Parameters & Practice (50 min)
**Pre-Session Questions:**
1. What are rest parameters in functions?
2. How do they differ from the `arguments` object?

**Core Topics:**
- Rest parameters in functions
- `arguments` object (old way)
- Combining with regular parameters
- Real-world patterns

**Exercises:**
1. Create a function that takes unlimited numbers and returns their sum.
2. Create a function where first param is required, rest are optional: `greet(greeting, ...names)`.
3. Build a `pick` function: `pick(obj, ...keys)` returns new object with only those keys.
4. Build a `merge` function that merges unlimited objects.

**Post-Session Recall:**
1. Write a sum function with rest parameters from memory.
2. What's the difference between rest parameters and the `arguments` object?
3. Can rest parameters be anywhere in the parameter list?

**Commit:** `Day 3: Destructuring, spread, rest operators`

---

### Sunday, Jan 4 - Day 4
**Topic:** Array Methods
**Sessions:** 4

#### Session 1: map() (50 min)
**Pre-Session Questions:**
1. What does `map()` do?
2. How is it different from a `for` loop?

**Core Topics:**
- `map()` syntax and callback
- Return value creates new array
- Original array unchanged (immutability)
- Callback parameters: element, index, array

**Resources:**
- [JavaScript.info: Array Methods - map](https://javascript.info/array-methods#map) (10 min)
- [MDN: Array.prototype.map()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map) (10 min)

**Exercises:**
```javascript
const numbers = [1, 2, 3, 4, 5];
const users = [
  { name: "Alice", age: 25 },
  { name: "Bob", age: 30 },
  { name: "Charlie", age: 35 }
];

// 1. Double all numbers
// 2. Get array of just names from users
// 3. Create array of strings: "Alice is 25 years old"
// 4. Add index to each: [{ ...user, index: 0 }, ...]
```

**Post-Session Recall:**
1. Does `map()` modify the original array?
2. What are the 3 parameters the callback receives?
3. What happens if you don't return anything in the callback?

---

#### Session 2: filter() (50 min)
**Pre-Session Questions:**
1. What does `filter()` do?
2. What should the callback return?

**Core Topics:**
- `filter()` syntax
- Truthy/falsy return values
- Common filtering patterns
- Chaining with `map()`

**Resources:**
- [JavaScript.info: Array Methods - filter](https://javascript.info/array-methods#filter) (10 min)

**Exercises:**
```javascript
const products = [
  { name: "Laptop", price: 1000, inStock: true },
  { name: "Phone", price: 500, inStock: false },
  { name: "Tablet", price: 300, inStock: true },
  { name: "Watch", price: 200, inStock: true }
];

// 1. Get only products in stock
// 2. Get products under $400
// 3. Get products that are in stock AND under $400
// 4. Remove falsy values from: [0, 1, "", "hello", null, undefined, false, true]
// 5. Chain: Get names of products in stock (filter + map)
```

**Post-Session Recall:**
1. What does the filter callback need to return?
2. How do you chain `filter()` and `map()`?
3. What's a quick way to remove all falsy values from an array?

---

#### Session 3: find() and findIndex() (50 min)
**Pre-Session Questions:**
1. What's the difference between `filter()` and `find()`?
2. When would you use `findIndex()`?

**Core Topics:**
- `find()` returns first match or undefined
- `findIndex()` returns index or -1
- Use cases: lookup by ID, checking existence
- Performance vs `filter()`

**Exercises:**
```javascript
const users = [
  { id: 1, name: "Alice", role: "admin" },
  { id: 2, name: "Bob", role: "user" },
  { id: 3, name: "Charlie", role: "user" },
  { id: 4, name: "Diana", role: "admin" }
];

// 1. Find user with id 3
// 2. Find first admin
// 3. Find index of Bob
// 4. Check if any user named "Eve" exists (what's returned if not found?)
// 5. Build a getUserById function
// 6. Build a removeUserById function using findIndex + splice
```

**Post-Session Recall:**
1. What does `find()` return if nothing matches?
2. What does `findIndex()` return if nothing matches?
3. Why might `find()` be more performant than `filter()` for single item lookup?

---

#### Session 4: reduce() (50 min)
**Pre-Session Questions:**
1. What is `reduce()` used for?
2. What is an "accumulator"?

**Core Topics:**
- `reduce()` syntax: callback(accumulator, currentValue)
- Initial value importance
- Building different output types (number, array, object)
- Common patterns

**Resources:**
- [Fun Fun Function: Reduce](https://www.youtube.com/watch?v=Wl98eZpkp-c) (12 min video - WATCH THIS)
- [MDN: Array.prototype.reduce()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce) (15 min)

**Exercises:**
```javascript
const numbers = [1, 2, 3, 4, 5];
const orders = [
  { product: "Laptop", amount: 1000 },
  { product: "Phone", amount: 500 },
  { product: "Phone", amount: 500 },
  { product: "Tablet", amount: 300 }
];

// 1. Sum all numbers
// 2. Find the maximum number
// 3. Calculate total of all orders
// 4. Count occurrences: { Laptop: 1, Phone: 2, Tablet: 1 }
// 5. Group orders by product: { Laptop: [...], Phone: [...] }
// 6. Flatten [[1,2], [3,4], [5]] into [1,2,3,4,5]
```

**Post-Session Recall:**
1. What are the two required parameters of the reduce callback?
2. What happens if you don't provide an initial value?
3. Explain reduce like you're teaching a 5-year-old (ELI5).

**Commit:** `Day 4: Array methods - map, filter, find, reduce`

---

### Monday, Jan 5 - Day 5
**Topic:** More Array Methods + Practice
**Sessions:** 2

#### Session 1: some(), every(), includes() (50 min)
**Pre-Session Questions:**
1. What does `some()` check for?
2. What does `every()` check for?

**Core Topics:**
- `some()` - at least one matches
- `every()` - all match
- `includes()` - simple value check
- Short-circuit behavior

**Exercises:**
```javascript
const users = [
  { name: "Alice", age: 25, active: true },
  { name: "Bob", age: 17, active: false },
  { name: "Charlie", age: 30, active: true }
];

// 1. Check if ANY user is under 18
// 2. Check if ALL users are active
// 3. Check if ALL users are over 15
// 4. Check if array includes a specific value: [1,2,3].includes(2)
// 5. Build an isValidForm function that checks all fields are filled
```

**Post-Session Recall:**
1. What does `some()` return if the array is empty?
2. What does `every()` return if the array is empty?
3. When would you use `includes()` vs `find()`?

---

#### Session 2: Array Method Challenges (50 min)
**Practice combining everything learned.**

**Exercises:**
```javascript
const data = [
  { id: 1, name: "Alice", department: "Engineering", salary: 80000, active: true },
  { id: 2, name: "Bob", department: "Marketing", salary: 60000, active: true },
  { id: 3, name: "Charlie", department: "Engineering", salary: 90000, active: false },
  { id: 4, name: "Diana", department: "Marketing", salary: 70000, active: true },
  { id: 5, name: "Eve", department: "Engineering", salary: 85000, active: true }
];

// 1. Get names of all active employees (filter + map)
// 2. Calculate total salary of Engineering department (filter + reduce)
// 3. Get average salary of active employees (filter + reduce)
// 4. Group employees by department (reduce to object)
// 5. Find the highest paid active employee (filter + reduce OR sort)
// 6. Check if all Engineering employees earn > 75000 (filter + every)
// 7. Transform to: { Alice: "Engineering", Bob: "Marketing", ... } (reduce)
```

**Commit:** `Day 5: Array methods mastery`

---

### Tuesday, Jan 6 - Day 6
**Topic:** Closures & Scope
**Sessions:** 2

#### Session 1: Lexical Scope & Closures (50 min)
**Pre-Session Questions:**
1. What is "scope" in JavaScript?
2. What is a closure?

**Core Topics:**
- Global scope vs function scope vs block scope
- Lexical scoping (where function is DEFINED, not called)
- What is a closure
- How closures "remember" their environment

**Resources:**
- [JavaScript.info: Closure](https://javascript.info/closure) (20 min - READ CAREFULLY)

**Exercises:**
```javascript
// 1. Predict the output:
function outer() {
  let count = 0;
  return function inner() {
    count++;
    return count;
  };
}
const counter = outer();
console.log(counter()); // ?
console.log(counter()); // ?
console.log(counter()); // ?

// 2. Create a function that generates greeting functions:
// const greetJohn = createGreeter("John");
// greetJohn("Hello"); // "Hello, John!"

// 3. Explain why this logs 3, 3, 3:
for (var i = 0; i < 3; i++) {
  setTimeout(() => console.log(i), 100);
}
// Fix it to log 0, 1, 2
```

**Post-Session Recall:**
1. Define "closure" in one sentence.
2. Why do closures exist? What problem do they solve?
3. What does "lexical scope" mean?

---

#### Session 2: Practical Closure Patterns (50 min)
**Pre-Session Questions:**
1. How can closures create "private" variables?
2. What is a factory function?

**Core Topics:**
- Private variables pattern
- Factory functions
- Module pattern
- Memoization with closures

**Exercises:**
```javascript
// 1. Create a counter factory with private state:
function createCounter() {
  // Return object with: increment(), decrement(), getValue()
  // The count should NOT be accessible directly
}

// 2. Create a createIdGenerator that returns unique IDs:
// const userIdGen = createIdGenerator("user");
// userIdGen(); // "user_1"
// userIdGen(); // "user_2"

// 3. Create a simple memoize function:
function memoize(fn) {
  // Returns a function that caches results
}
const expensiveSquare = memoize((n) => {
  console.log("Computing...");
  return n * n;
});
expensiveSquare(5); // "Computing..." then 25
expensiveSquare(5); // Just 25 (cached!)

// 4. Create a once() function that only allows fn to run once:
const initialize = once(() => console.log("Initialized!"));
initialize(); // "Initialized!"
initialize(); // Nothing happens
```

**Post-Session Recall:**
1. How do closures enable private variables?
2. Write a simple counter factory from memory.
3. What's the memoization pattern? Why is it useful?

**Commit:** `Day 6: Closures and lexical scope`

---

### Wednesday, Jan 7 - Day 7
**Topic:** Promises
**Sessions:** 2

#### Session 1: Promise Fundamentals (50 min)
**Pre-Session Questions:**
1. What problem do Promises solve?
2. What are the three states of a Promise?

**Core Topics:**
- Why Promises exist (callback hell)
- Promise states: pending, fulfilled, rejected
- Creating Promises with `new Promise()`
- `resolve` and `reject`

**Resources:**
- [JavaScript.info: Promise Basics](https://javascript.info/promise-basics) (20 min)

**Exercises:**
```javascript
// 1. Create a Promise that resolves after 2 seconds with "Done!"
const delayed = new Promise((resolve, reject) => {
  // Your code
});

// 2. Create a Promise that randomly resolves or rejects (50/50)
const coinFlip = new Promise((resolve, reject) => {
  // Your code
});

// 3. Wrap setTimeout in a Promise:
function delay(ms) {
  // Return a Promise that resolves after ms milliseconds
}

// 4. Create a Promise that rejects if a number is negative:
function validatePositive(num) {
  return new Promise((resolve, reject) => {
    // Your code
  });
}
```

**Post-Session Recall:**
1. What are the three Promise states?
2. What do `resolve` and `reject` do?
3. Does a Promise execute immediately or lazily?

---

#### Session 2: .then(), .catch(), .finally() (50 min)
**Pre-Session Questions:**
1. What does `.then()` return?
2. Where do errors go in a Promise chain?

**Core Topics:**
- `.then()` for success handling
- `.catch()` for error handling
- `.finally()` for cleanup
- Promise chaining
- Return values in chains

**Resources:**
- [JavaScript.info: Promise Chaining](https://javascript.info/promise-chaining) (15 min)

**Exercises:**
```javascript
// 1. Handle the delayed promise:
delayed.then(result => console.log(result));

// 2. Handle both success and error:
coinFlip
  .then(result => console.log("Won:", result))
  .catch(error => console.log("Lost:", error));

// 3. Chain promises:
function getUser(id) {
  return new Promise(resolve => {
    setTimeout(() => resolve({ id, name: "John" }), 500);
  });
}
function getPosts(userId) {
  return new Promise(resolve => {
    setTimeout(() => resolve(["Post 1", "Post 2"]), 500);
  });
}
// Chain: getUser â†’ getPosts â†’ log posts

// 4. Use .finally() to always log "Complete" regardless of success/failure

// 5. What happens if you return a value in .then()? Try it!
```

**Post-Session Recall:**
1. What does `.then()` return?
2. Where should `.catch()` go in a chain?
3. When does `.finally()` run?

**Commit:** `Day 7: Promises fundamentals`

---

### Thursday, Jan 8 - Day 8
**Topic:** Async/Await
**Sessions:** 2

#### Session 1: Async/Await Basics (50 min)
**Pre-Session Questions:**
1. What does `async` do to a function?
2. What does `await` do?

**Core Topics:**
- `async` functions always return Promises
- `await` pauses until Promise resolves
- `await` can only be used inside `async` functions
- Converting Promise chains to async/await

**Resources:**
- [JavaScript.info: Async/Await](https://javascript.info/async-await) (20 min)

**Exercises:**
```javascript
// 1. Convert this to async/await:
getUser(1)
  .then(user => getPosts(user.id))
  .then(posts => console.log(posts));

// 2. Create an async function that waits 1 second then returns "Hello"

// 3. What does this return?
async function test() {
  return 42;
}
console.log(test()); // What type is this?

// 4. Use await with the delay function from yesterday
```

**Post-Session Recall:**
1. What does an `async` function always return?
2. Can you use `await` outside an async function?
3. Rewrite Promise.then().then() as async/await from memory.

---

#### Session 2: Error Handling & Parallel Execution (50 min)
**Pre-Session Questions:**
1. How do you handle errors with async/await?
2. How do you run multiple Promises in parallel?

**Core Topics:**
- `try/catch` for error handling
- `Promise.all()` for parallel execution
- `Promise.allSettled()` for all results
- `Promise.race()` for first result
- Common async patterns

**Exercises:**
```javascript
// 1. Add error handling:
async function fetchUser(id) {
  // Wrap in try/catch, return null if error
}

// 2. Fetch 3 users in PARALLEL (not sequential):
async function fetchMultipleUsers(ids) {
  // Use Promise.all
}

// 3. What's the difference in execution time?
// Sequential:
async function sequential() {
  const a = await delay(1000);
  const b = await delay(1000);
  const c = await delay(1000);
  // Total time: ?
}
// Parallel:
async function parallel() {
  const [a, b, c] = await Promise.all([
    delay(1000),
    delay(1000),
    delay(1000)
  ]);
  // Total time: ?
}

// 4. Create a "timeout" wrapper:
async function fetchWithTimeout(promise, ms) {
  // Reject if promise takes longer than ms
  // Hint: use Promise.race
}
```

**Post-Session Recall:**
1. How do you catch errors with async/await?
2. What does `Promise.all()` do if one Promise rejects?
3. What's `Promise.allSettled()` and when would you use it?

**Commit:** `Day 8: Async/await mastery`

---

### Friday, Jan 9 - Day 9
**Topic:** Fetch API
**Sessions:** 2

#### Session 1: GET Requests (50 min)
**Pre-Session Questions:**
1. What is the Fetch API?
2. What does `fetch()` return?

**Core Topics:**
- Basic `fetch()` syntax
- Response object
- `.json()` method
- Checking `response.ok`
- Status codes

**Resources:**
- [JavaScript.info: Fetch](https://javascript.info/fetch) (15 min)
- [MDN: Using Fetch](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch) (15 min)

**Exercises:**
```javascript
const BASE_URL = "https://jsonplaceholder.typicode.com";

// 1. Fetch all posts and log them
async function getAllPosts() {
  // Your code
}

// 2. Fetch a single post by ID
async function getPost(id) {
  // Your code
}

// 3. Handle 404 - what happens when you fetch /posts/9999?
async function getPostSafe(id) {
  // Check response.ok, return null if not found
}

// 4. Fetch user and then their posts (sequential)
async function getUserWithPosts(userId) {
  // Your code
}
```

**Post-Session Recall:**
1. What does `fetch()` return?
2. Why do we need to call `.json()` on the response?
3. Is a 404 response a rejected Promise?

---

#### Session 2: POST, Headers, Error Handling (50 min)
**Pre-Session Questions:**
1. How do you send data with fetch?
2. How do you set headers?

**Core Topics:**
- POST requests
- Request options (method, headers, body)
- `JSON.stringify()` for body
- Content-Type header
- Error handling patterns

**Exercises:**
```javascript
// 1. POST a new post
async function createPost(title, body, userId) {
  const response = await fetch(`${BASE_URL}/posts`, {
    method: "POST",
    headers: {
      "Content-Type": "application/json"
    },
    body: JSON.stringify({ title, body, userId })
  });
  return response.json();
}

// 2. Create a reusable API client:
const api = {
  async get(endpoint) { /* ... */ },
  async post(endpoint, data) { /* ... */ },
  async put(endpoint, data) { /* ... */ },
  async delete(endpoint) { /* ... */ }
};

// 3. Add authorization header:
async function fetchWithAuth(url, token) {
  // Add "Authorization": "Bearer {token}" header
}

// 4. Create a robust fetch wrapper with:
// - Timeout
// - Retry on failure
// - Error handling
```

**Post-Session Recall:**
1. What headers do you need for JSON POST requests?
2. What's the second argument to `fetch()`?
3. How do you add authorization headers?

**Commit:** `Day 9: Fetch API - HTTP requests`

---

### Saturday, Jan 10 - Day 10
**Topic:** DOM Manipulation
**Sessions:** 4

#### Session 1: Selecting Elements (50 min)
**Pre-Session Questions:**
1. What is the DOM?
2. What's the difference between `querySelector` and `getElementById`?

**Core Topics:**
- `document.querySelector()` - CSS selector, first match
- `document.querySelectorAll()` - CSS selector, all matches
- `document.getElementById()` - by ID
- `document.getElementsByClassName()` - by class
- NodeList vs HTMLCollection

**Resources:**
- [JavaScript.info: Searching Elements](https://javascript.info/searching-elements-dom) (15 min)

**Create an HTML file to practice:**
```html
<!DOCTYPE html>
<html>
<head><title>DOM Practice</title></head>
<body>
  <header id="main-header">
    <h1 class="title">My Website</h1>
    <nav>
      <a href="#" class="nav-link">Home</a>
      <a href="#" class="nav-link">About</a>
      <a href="#" class="nav-link">Contact</a>
    </nav>
  </header>
  <main>
    <article class="post">
      <h2>First Post</h2>
      <p>Content here...</p>
    </article>
    <article class="post">
      <h2>Second Post</h2>
      <p>More content...</p>
    </article>
  </main>
  <script src="script.js"></script>
</body>
</html>
```

**Exercises:**
```javascript
// 1. Select the header by ID
// 2. Select the first nav link
// 3. Select ALL nav links
// 4. Select all articles with class "post"
// 5. Select the h1 inside the header
// 6. Log the text of each nav link
```

**Post-Session Recall:**
1. What's the difference between `querySelector` and `querySelectorAll`?
2. What does `querySelectorAll` return?
3. Can you use CSS selectors like `.class > element`?

---

#### Session 2: Modifying Elements (50 min)
**Pre-Session Questions:**
1. How do you change an element's text?
2. How do you change an element's attributes?

**Core Topics:**
- `textContent` vs `innerHTML`
- `getAttribute()`, `setAttribute()`
- `classList.add()`, `remove()`, `toggle()`, `contains()`
- `style` property

**Resources:**
- [JavaScript.info: Modifying Document](https://javascript.info/modifying-document) (15 min)

**Exercises:**
```javascript
// 1. Change the h1 text to "Welcome!"
// 2. Change the h1 color to blue using style
// 3. Add a class "active" to the first nav link
// 4. Toggle a class "dark" on the body
// 5. Change the href of all nav links to "#section1", "#section2", etc.
// 6. Add a data-* attribute to each article
```

**Post-Session Recall:**
1. What's the difference between `textContent` and `innerHTML`?
2. How do you toggle a class?
3. How do you change multiple styles at once?

---

#### Session 3: Creating & Removing Elements (50 min)
**Pre-Session Questions:**
1. How do you create a new element?
2. How do you add it to the page?

**Core Topics:**
- `document.createElement()`
- `element.appendChild()`
- `element.append()`, `prepend()`, `before()`, `after()`
- `element.remove()`
- `element.replaceWith()`
- `innerHTML` for bulk creation (and security concerns)

**Exercises:**
```javascript
// 1. Create a new article element
const article = document.createElement("article");
// Add h2 and p inside it
// Append to main

// 2. Create a list from an array:
const items = ["Apple", "Banana", "Orange"];
// Create a <ul> with <li> for each item

// 3. Add a "Delete" button to each existing article
// When clicked, remove that article

// 4. Create a function that builds a card:
function createCard(title, content, imageUrl) {
  // Returns a complete card element
}
```

**Post-Session Recall:**
1. What's the difference between `append()` and `appendChild()`?
2. Why is using `innerHTML` potentially dangerous?
3. How do you remove an element from the DOM?

---

#### Session 4: Events (50 min)
**Pre-Session Questions:**
1. What is an event listener?
2. What is the event object?

**Core Topics:**
- `addEventListener()`
- Event types (click, input, submit, keydown, etc.)
- Event object and properties
- `preventDefault()`
- `removeEventListener()`

**Resources:**
- [JavaScript.info: Browser Events](https://javascript.info/introduction-browser-events) (15 min)

**Exercises:**
```javascript
// 1. Add click listener to a button that alerts "Clicked!"
// 2. Log mouse coordinates on mousemove
// 3. Log key pressed on keydown
// 4. Prevent form submission and log form data instead
// 5. Create a button that can only be clicked once
// 6. Change background color when hovering over an element
```

**Post-Session Recall:**
1. What's the first argument to `addEventListener`?
2. What does `e.preventDefault()` do?
3. How do you remove an event listener?

**Commit:** `Day 10: DOM manipulation mastery`

---

### Sunday, Jan 11 - Day 11
**Topic:** Event Delegation & Forms
**Sessions:** 4

#### Session 1: Event Delegation (50 min)
**Pre-Session Questions:**
1. What is event bubbling?
2. Why use event delegation?

**Core Topics:**
- Event bubbling vs capturing
- Event delegation pattern
- `e.target` vs `e.currentTarget`
- Matching targets with `matches()` or `closest()`

**Resources:**
- [JavaScript.info: Event Delegation](https://javascript.info/event-delegation) (15 min)

**Exercises:**
```javascript
// 1. Instead of adding listener to each button, use delegation:
// <ul id="list">
//   <li>Item 1 <button>Delete</button></li>
//   <li>Item 2 <button>Delete</button></li>
// </ul>

document.getElementById("list").addEventListener("click", (e) => {
  // Check if click was on a button
  // If so, remove the parent <li>
});

// 2. Create a tab system using delegation:
// <div class="tabs">
//   <button data-tab="1">Tab 1</button>
//   <button data-tab="2">Tab 2</button>
// </div>
// <div class="content" data-content="1">Content 1</div>
// <div class="content" data-content="2">Content 2</div>

// 3. Build a todo list where items can be added dynamically
// and deletion works via delegation
```

**Post-Session Recall:**
1. What's the difference between `e.target` and `e.currentTarget`?
2. Why is event delegation more efficient?
3. How do you check if the clicked element matches a selector?

---

#### Session 2: Forms & Inputs (50 min)
**Pre-Session Questions:**
1. How do you get the value of an input?
2. What events do forms fire?

**Core Topics:**
- Input values (`input.value`)
- Form events: submit, input, change, focus, blur
- Form validation
- FormData API

**Exercises:**
```javascript
// Create this form:
// <form id="signup">
//   <input name="username" type="text">
//   <input name="email" type="email">
//   <input name="password" type="password">
//   <button type="submit">Sign Up</button>
// </form>

// 1. Log input value on every keystroke (input event)
// 2. Validate on submit: all fields required, password min 8 chars
// 3. Show error messages next to invalid fields
// 4. Use FormData to get all form values at once
// 5. Clear form after successful submission
```

**Post-Session Recall:**
1. What's the difference between `input` and `change` events?
2. How do you prevent form submission?
3. How do you get all form data at once?

---

#### Session 3: Mini Project - Todo List (50 min)
**Build the HTML/CSS structure and basic add functionality**

```html
<!DOCTYPE html>
<html>
<head>
  <title>Todo List</title>
  <style>
    /* Basic styling */
    .completed { text-decoration: line-through; opacity: 0.6; }
    .todo-item { display: flex; gap: 10px; padding: 10px; border-bottom: 1px solid #eee; }
  </style>
</head>
<body>
  <div id="app">
    <h1>Todo List</h1>
    <form id="todo-form">
      <input type="text" id="todo-input" placeholder="Add a task...">
      <button type="submit">Add</button>
    </form>
    <ul id="todo-list"></ul>
    <div id="stats"></div>
  </div>
  <script src="app.js"></script>
</body>
</html>
```

**Tasks:**
1. Add task on form submit
2. Display tasks in the list
3. Each task has: text, complete checkbox, delete button

---

#### Session 4: Mini Project - Todo List Features (50 min)
**Add remaining features**

**Tasks:**
1. Toggle complete (checkbox or click)
2. Delete task (event delegation!)
3. Show stats: "X items left"
4. Enter key submits form
5. Don't allow empty tasks

**Commit:** `Day 11: Event delegation, forms, todo list`

---

### Monday, Jan 12 - Day 12
**Topic:** LocalStorage
**Sessions:** 2

#### Session 1: LocalStorage Basics (50 min)
**Pre-Session Questions:**
1. What is localStorage?
2. What types of data can you store?

**Core Topics:**
- `localStorage.setItem(key, value)`
- `localStorage.getItem(key)`
- `localStorage.removeItem(key)`
- `localStorage.clear()`
- `JSON.stringify()` and `JSON.parse()`

**Resources:**
- [JavaScript.info: LocalStorage](https://javascript.info/localstorage) (15 min)

**Exercises:**
```javascript
// 1. Save a string to localStorage and retrieve it
// 2. Save an object (requires JSON.stringify)
// 3. Retrieve and parse the object (requires JSON.parse)
// 4. Save an array of todos
// 5. What happens if you getItem a key that doesn't exist?
// 6. Create helper functions:
function saveToStorage(key, data) { /* ... */ }
function loadFromStorage(key) { /* ... */ }
```

**Post-Session Recall:**
1. Can you store objects directly in localStorage?
2. What does `getItem()` return for non-existent keys?
3. What's the storage limit for localStorage?

---

#### Session 2: Persist Todo List (50 min)
**Add localStorage to your todo list**

**Tasks:**
1. Save todos to localStorage on every change
2. Load todos from localStorage on page load
3. Handle the case where there's no saved data
4. Test: refresh the page, todos should persist!

**Bonus:**
- Save user preferences (dark mode toggle)
- Clear all completed todos button

**Commit:** `Day 12: LocalStorage, persistent todo list`

---

### Tuesday, Jan 13 - Day 13
**Topic:** ES6 Modules
**Sessions:** 2

#### Session 1: Export & Import (50 min)
**Pre-Session Questions:**
1. What are ES6 modules?
2. What's the difference between named and default exports?

**Core Topics:**
- `export` (named exports)
- `export default` (one per file)
- `import { name }` (named imports)
- `import name` (default imports)
- `import * as name` (namespace import)

**Resources:**
- [JavaScript.info: Modules](https://javascript.info/modules-intro) (15 min)

**Setup:**
```html
<!-- index.html -->
<script type="module" src="main.js"></script>
```

**Exercises:**
```javascript
// utils.js
export const add = (a, b) => a + b;
export const subtract = (a, b) => a - b;
export default function multiply(a, b) { return a * b; }

// main.js
// 1. Import add and subtract
// 2. Import the default export
// 3. Import everything as Utils
// 4. Re-export from another file

// 5. Create:
// - storage.js (localStorage helpers)
// - dom.js (DOM helpers)
// - main.js (uses both)
```

**Post-Session Recall:**
1. How many default exports can a file have?
2. What's the syntax for importing a default export?
3. What does `import * as X` do?

---

#### Session 2: Refactor Todo to Modules (50 min)
**Restructure your todo list into modules**

**File Structure:**
```
/todo-app
  index.html
  js/
    app.js (main entry point)
    storage.js (localStorage functions)
    ui.js (DOM manipulation)
    todo.js (todo logic/data)
```

**Tasks:**
1. Move localStorage code to `storage.js`
2. Move DOM code to `ui.js`
3. Move todo data operations to `todo.js`
4. Import and wire everything in `app.js`

**Commit:** `Day 13: ES6 modules, refactored todo`

---

### Wednesday, Jan 14 - Day 14
**Topic:** Review & Git
**Sessions:** 2

#### Session 1: Git Fundamentals (50 min)
**Pre-Session Questions:**
1. What is version control?
2. What's the difference between git and GitHub?

**Core Topics:**
- `git init`
- `git add` (staging)
- `git commit`
- `git status`, `git log`
- `.gitignore`
- Good commit messages

**Resources:**
- [Git Handbook](https://guides.github.com/introduction/git-handbook/) (15 min)

**Exercises:**
```bash
# 1. Initialize a new repo
git init

# 2. Check status
git status

# 3. Stage all files
git add .

# 4. Commit with message
git commit -m "Initial commit: todo app structure"

# 5. View history
git log --oneline

# 6. Create .gitignore for node_modules, .DS_Store, etc.
```

**Post-Session Recall:**
1. What does `git add` do?
2. What's the difference between working directory, staging area, and repository?
3. What should always be in `.gitignore`?

---

#### Session 2: GitHub & Branches (50 min)
**Pre-Session Questions:**
1. How do you push code to GitHub?
2. What are branches used for?

**Core Topics:**
- Creating GitHub repository
- `git remote add origin`
- `git push`
- Branches: `git branch`, `git checkout`
- Merging

**Exercises:**
```bash
# 1. Create repo on GitHub
# 2. Connect local repo
git remote add origin https://github.com/username/repo.git
git branch -M main
git push -u origin main

# 3. Create a feature branch
git checkout -b feature/dark-mode

# 4. Make changes, commit
# 5. Merge back to main
git checkout main
git merge feature/dark-mode
```

**Commit:** Push todo app to GitHub!

---

### Thursday, Jan 15 - Day 15
**Topic:** Week 2 Review + HTML/CSS Start
**Sessions:** 2

#### Session 1: Week 1-2 Review (50 min)
**Active recall session - answer without looking!**

1. What are the 7 primitive types in JavaScript?
2. Write an arrow function that returns an object.
3. Destructure nested object: `{ user: { address: { city } } }`.
4. What does `reduce` do? Write a sum function.
5. Explain closures in one sentence.
6. Convert a Promise chain to async/await.
7. What's event delegation? Why use it?
8. How do you persist data in the browser?

**Review any weak areas.**

---

#### Session 2: HTML Semantic Elements (50 min)
**Pre-Session Questions:**
1. What is semantic HTML?
2. Why does it matter?

**Core Topics:**
- `header`, `nav`, `main`, `section`, `article`, `aside`, `footer`
- `figure`, `figcaption`
- Accessibility benefits
- SEO benefits

**Resources:**
- [MDN: Semantic HTML](https://developer.mozilla.org/en-US/docs/Glossary/Semantics#semantics_in_html) (10 min)

**Exercise:**
Build the HTML structure (no CSS) for a portfolio site:
- Header with name and nav
- Hero section
- About section
- Projects section (3 project cards)
- Contact section
- Footer

**Commit:** `Day 15: Semantic HTML`

---

### Friday, Jan 16 - Day 16
**Topic:** CSS Fundamentals
**Sessions:** 2

#### Session 1: Box Model & Selectors (50 min)
**Pre-Session Questions:**
1. What is the CSS box model?
2. What's the difference between margin and padding?

**Core Topics:**
- Box model: content, padding, border, margin
- `box-sizing: border-box`
- Selectors: element, class, ID, attribute
- Combinators: descendant, child, sibling

**Resources:**
- [CSS-Tricks: Box Model](https://css-tricks.com/the-css-box-model/) (10 min)

**Exercises:**
```css
/* 1. Set border-box on everything */
*, *::before, *::after {
  box-sizing: border-box;
}

/* 2. Practice selectors: */
/* Select all paragraphs */
/* Select element with class "card" */
/* Select direct children of nav */
/* Select p that immediately follows h2 */

/* 3. Create a card with padding, border, and margin */
```

**Post-Session Recall:**
1. What does `box-sizing: border-box` do?
2. What's the default box-sizing?
3. What's the difference between `>` and ` ` (space) in selectors?

---

#### Session 2: Typography & Colors (50 min)
**Core Topics:**
- `font-family`, `font-size`, `font-weight`
- `line-height`, `letter-spacing`
- Color formats: hex, rgb, hsl
- CSS custom properties (variables)

**Exercises:**
```css
/* 1. Set up CSS variables */
:root {
  --color-primary: #3498db;
  --color-secondary: #2ecc71;
  --font-main: 'Segoe UI', sans-serif;
}

/* 2. Create a typography scale */
h1 { font-size: 2.5rem; }
h2 { font-size: 2rem; }
/* etc... */

/* 3. Style your portfolio HTML */
```

**Commit:** `Day 16: CSS fundamentals`

---

### Saturday, Jan 17 - Day 17
**Topic:** Flexbox
**Sessions:** 4

#### Session 1: Flexbox Basics (50 min)
**Play [Flexbox Froggy](https://flexboxfroggy.com/) first! (20 min)**

**Core Topics:**
- `display: flex`
- Main axis vs cross axis
- `justify-content`
- `align-items`

**Resources:**
- [CSS-Tricks: Flexbox Guide](https://css-tricks.com/snippets/css/a-guide-to-flexbox/) - BOOKMARK THIS

---

#### Session 2: Flex Properties (50 min)
**Core Topics:**
- `flex-direction`
- `flex-wrap`
- `gap`
- `align-self`

**Exercises:**
```css
/* 1. Center a div horizontally and vertically */
/* 2. Create a horizontal nav bar */
/* 3. Create a row that wraps on small screens */
/* 4. Space items evenly with gap */
```

---

#### Session 3: Flex Item Properties (50 min)
**Core Topics:**
- `flex-grow`
- `flex-shrink`
- `flex-basis`
- `flex` shorthand

**Exercises:**
```css
/* 1. Make sidebar fixed 250px, main content flexible */
/* 2. Equal width columns */
/* 3. One item grows to fill remaining space */
```

---

#### Session 4: Flexbox Practice (50 min)
**Build common layouts:**
1. Navigation bar (logo left, links right)
2. Card with image, content, and footer
3. Holy grail layout (header, sidebar, main, sidebar, footer)

**Commit:** `Day 17: Flexbox mastery`

---

### Sunday, Jan 18 - Day 18
**Topic:** CSS Grid & Responsive
**Sessions:** 4

#### Session 1: Grid Basics (50 min)
**Play [Grid Garden](https://cssgridgarden.com/) first! (20 min)**

**Core Topics:**
- `display: grid`
- `grid-template-columns`
- `grid-template-rows`
- `fr` unit
- `gap`

---

#### Session 2: Grid Placement (50 min)
**Core Topics:**
- `grid-column`, `grid-row`
- `grid-area`
- `grid-template-areas`
- Named grid lines

**Exercises:**
```css
/* 1. 3-column layout */
.grid {
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  gap: 20px;
}

/* 2. Header spans all columns */
/* 3. Sidebar spans multiple rows */
```

---

#### Session 3: Responsive Design (50 min)
**Core Topics:**
- Media queries
- Mobile-first approach
- Breakpoints
- Responsive units (%, vw, vh, rem)

**Resources:**
- [MDN: Media Queries](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_media_queries/Using_media_queries) (15 min)

**Exercises:**
```css
/* Mobile first */
.cards {
  display: grid;
  grid-template-columns: 1fr;
  gap: 1rem;
}

/* Tablet */
@media (min-width: 768px) {
  .cards {
    grid-template-columns: repeat(2, 1fr);
  }
}

/* Desktop */
@media (min-width: 1024px) {
  .cards {
    grid-template-columns: repeat(3, 1fr);
  }
}
```

---

#### Session 4: Responsive Portfolio (50 min)
**Make your portfolio fully responsive:**
- Mobile: single column
- Tablet: 2 columns for cards
- Desktop: full layout with sidebar

**Commit:** `Day 18: CSS Grid, responsive design`

---

### Monday, Jan 19 - Day 19
**Topic:** Project - Weather App Setup
**Sessions:** 2

#### Session 1: Project Setup (50 min)
**Weather App - Your second portfolio piece**

**Setup:**
```
/weather-app
  index.html
  css/
    style.css
  js/
    app.js
    api.js
    ui.js
  README.md
```

**Tasks:**
1. Sign up for [OpenWeatherMap](https://openweathermap.org/api) (free tier)
2. Get your API key
3. Create HTML structure:
   - Search input and button
   - Current weather display
   - 5-day forecast section
4. Basic CSS styling

---

#### Session 2: API Integration (50 min)
**Tasks:**
1. Create `api.js` with fetch functions
2. Test API calls in console
3. Understand the response structure

```javascript
// api.js
const API_KEY = 'your_key';
const BASE_URL = 'https://api.openweathermap.org/data/2.5';

export async function getCurrentWeather(city) {
  const response = await fetch(
    `${BASE_URL}/weather?q=${city}&appid=${API_KEY}&units=metric`
  );
  if (!response.ok) throw new Error('City not found');
  return response.json();
}

export async function getForecast(city) {
  // Similar for 5-day forecast
}
```

**Commit:** `Day 19: Weather app setup`

---

### Tuesday, Jan 20 - Day 20
**Topic:** Weather App - Features
**Sessions:** 2

#### Session 1: Display Weather (50 min)
**Tasks:**
1. Display current weather on search
2. Show: city name, temperature, description, icon
3. Handle loading state

---

#### Session 2: Forecast & Error Handling (50 min)
**Tasks:**
1. Display 5-day forecast
2. Handle "city not found" error gracefully
3. Show user-friendly error messages
4. Add loading spinner

**Commit:** `Day 20: Weather app features`

---

### Wednesday, Jan 21 - Day 21
**Topic:** Weather App - Polish
**Sessions:** 2

#### Session 1: UI/UX Improvements (50 min)
- Responsive design
- Better styling
- Weather icons
- Background changes based on weather

---

#### Session 2: Final Touches (50 min)
- LocalStorage for recent searches
- Clean up code
- Write README
- Push to GitHub

**Commit:** `Day 21: Weather app complete!`

---

### Thursday, Jan 22 - Day 22
**Topic:** Node.js Introduction
**Sessions:** 2

#### Session 1: Node Basics (50 min)
**Pre-Session Questions:**
1. What is Node.js?
2. How is it different from browser JavaScript?

**Core Topics:**
- Node.js runtime
- Running scripts with `node`
- Global objects (`__dirname`, `__filename`, `process`)
- CommonJS modules (`require`, `module.exports`)

**Resources:**
- [Node.js Introduction](https://nodejs.dev/en/learn/) (15 min)

**Exercises:**
```javascript
// 1. Create hello.js, run with `node hello.js`
console.log("Hello, Node!");

// 2. Log process.argv
console.log(process.argv);

// 3. Create a math.js module with add, subtract
// Export using module.exports
// Require it in another file
```

---

#### Session 2: File System Module (50 min)
**Core Topics:**
- `fs` module
- `readFileSync`, `writeFileSync`
- `readFile`, `writeFile` (async versions)
- `readdirSync`

**Exercises:**
```javascript
const fs = require('fs');

// 1. Read a text file
const content = fs.readFileSync('file.txt', 'utf8');

// 2. Write to a file
fs.writeFileSync('output.txt', 'Hello!');

// 3. Read directory contents
const files = fs.readdirSync('.');

// 4. Create a script that processes a JSON file
// Read users.json, filter active users, write to active-users.json
```

**Commit:** `Day 22: Node.js basics`

---

### Friday, Jan 23 - Day 23
**Topic:** NPM & Packages
**Sessions:** 2

#### Session 1: NPM Basics (50 min)
**Core Topics:**
- `npm init`
- `package.json`
- Installing packages
- `dependencies` vs `devDependencies`
- `node_modules` and `.gitignore`

**Exercises:**
```bash
# 1. Initialize project
npm init -y

# 2. Install a dependency
npm install lodash

# 3. Install a dev dependency
npm install -D nodemon

# 4. Check package.json
```

---

#### Session 2: Using Packages (50 min)
**Core Topics:**
- Importing packages
- npm scripts
- Running with nodemon

**Exercises:**
```javascript
// 1. Use lodash
const _ = require('lodash');
console.log(_.capitalize('hello world'));

// 2. Add script to package.json
// "start": "node index.js",
// "dev": "nodemon index.js"

// 3. Build a simple CLI tool
// Takes arguments, uses a package for colored output
```

**Commit:** `Day 23: NPM and packages`

---

### Saturday, Jan 24 - Day 24
**Topic:** Express.js Basics
**Sessions:** 4

#### Session 1: First Express Server (50 min)
**Core Topics:**
- Installing Express
- Creating a server
- Listening on a port
- Basic routing

**Resources:**
- [Express Hello World](https://expressjs.com/en/starter/hello-world.html) (10 min)

**Setup:**
```javascript
const express = require('express');
const app = express();
const PORT = 3000;

app.get('/', (req, res) => {
  res.send('Hello World!');
});

app.listen(PORT, () => {
  console.log(`Server running on http://localhost:${PORT}`);
});
```

---

#### Session 2: Routing (50 min)
**Core Topics:**
- Route methods (GET, POST, PUT, DELETE)
- Route parameters
- Query strings
- `res.json()`

**Exercises:**
```javascript
// 1. GET /api/users - return array of users
// 2. GET /api/users/:id - return single user
// 3. GET /api/users?active=true - filter by query
// 4. POST /api/users - create user (we'll add body parsing next)
```

---

#### Session 3: Middleware (50 min)
**Core Topics:**
- What is middleware?
- `app.use()`
- `express.json()`
- Custom middleware
- Error handling middleware

**Resources:**
- [Express Middleware](https://expressjs.com/en/guide/using-middleware.html) (15 min)

**Exercises:**
```javascript
// 1. Logger middleware
app.use((req, res, next) => {
  console.log(`${req.method} ${req.url}`);
  next();
});

// 2. JSON body parser
app.use(express.json());

// 3. Auth middleware (check for API key header)
function auth(req, res, next) {
  if (!req.headers['x-api-key']) {
    return res.status(401).json({ error: 'Unauthorized' });
  }
  next();
}
```

---

#### Session 4: Mini API (50 min)
**Build a simple REST API for "notes":**
```javascript
// In-memory data
let notes = [
  { id: 1, title: "First note", content: "Hello!" }
];

// Routes:
// GET /api/notes
// GET /api/notes/:id
// POST /api/notes
// PUT /api/notes/:id
// DELETE /api/notes/:id
```

**Commit:** `Day 24: Express.js basics`

---

### Sunday, Jan 25 - Day 25
**Topic:** REST API Project Start
**Sessions:** 4

#### Session 1: Project Setup (50 min)
**Task Manager API - Portfolio piece**

**Structure:**
```
/task-api
  src/
    index.js
    routes/
      tasks.js
    middleware/
      logger.js
      errorHandler.js
    controllers/
      taskController.js
  package.json
```

---

#### Session 2-3: CRUD Implementation (100 min)
**Implement all routes:**
- GET /api/tasks (with filters)
- GET /api/tasks/:id
- POST /api/tasks (validation)
- PUT /api/tasks/:id
- DELETE /api/tasks/:id

---

#### Session 4: Error Handling (50 min)
- Validation errors
- Not found errors
- Server errors
- Custom error classes

**Commit:** `Day 25: Task API project`

---

### Monday, Jan 26 - Day 26
**Topic:** Task API - Complete
**Sessions:** 2

#### Session 1: Finish API (50 min)
- Add filtering (by status, priority)
- Add sorting
- Add pagination

---

#### Session 2: Documentation (50 min)
- Write comprehensive README
- Document all endpoints
- Push to GitHub

**Commit:** `Day 26: Task API complete!`

---

### Tuesday, Jan 27 - Day 27
**Topic:** Connect Frontend to API
**Sessions:** 2

#### Session 1: Frontend Setup (50 min)
**Create a simple frontend that uses your API:**
- HTML form to add tasks
- List to display tasks
- Delete buttons

---

#### Session 2: CORS & Integration (50 min)
**Core Topics:**
- What is CORS?
- Installing cors package
- Frontend fetch calls

```javascript
// Backend
const cors = require('cors');
app.use(cors());

// Frontend
async function getTasks() {
  const response = await fetch('http://localhost:3000/api/tasks');
  return response.json();
}
```

**Commit:** `Day 27: Frontend-backend integration`

---

### Wednesday, Jan 28 - Day 28
**Topic:** LeetCode Introduction
**Sessions:** 2

#### Session 1: Big O Notation (50 min)
**Core Topics:**
- Time complexity
- Space complexity
- Common complexities: O(1), O(n), O(nÂ²), O(log n)

**Resources:**
- [Big O Cheat Sheet](https://www.bigocheatsheet.com/)
- [NeetCode: Big O for Interviews](https://www.youtube.com/watch?v=BgLTDT03QtU) (Watch this!)

---

#### Session 2: First LeetCode Problems (50 min)
**Solve these (Arrays & Hashing category):**
1. [Two Sum](https://leetcode.com/problems/two-sum/) (Easy)
2. [Contains Duplicate](https://leetcode.com/problems/contains-duplicate/) (Easy)

**Pattern:** For each problem:
1. Read problem carefully
2. Think about brute force first
3. Optimize
4. Code solution
5. Analyze time/space complexity

**Commit:** `Day 28: Big O, first LeetCode`

---

### Thursday, Jan 29 - Day 29
**Topic:** More LeetCode
**Sessions:** 2

#### Session 1: Array Problems (50 min)
- [Valid Anagram](https://leetcode.com/problems/valid-anagram/)
- [Two Sum](https://leetcode.com/problems/two-sum/) (if not done)

---

#### Session 2: Review & Practice (50 min)
- Review solutions
- Understand different approaches
- Practice explaining your solution

**Commit:** `Day 29: LeetCode practice`

---

### Friday, Jan 30 - Day 30
**Topic:** Phase 1 Review
**Sessions:** 2

#### Session 1: Concept Review (50 min)
**Test yourself (no looking!):**
1. JS: closures, promises, async/await
2. DOM: event delegation, localStorage
3. CSS: flexbox, grid, responsive
4. Node: Express basics, middleware
5. Git: basic workflow

---

#### Session 2: Project Review (50 min)
- Check all projects are on GitHub
- All have good READMEs
- Test that everything works

**Portfolio check:**
1. âœ… Todo App (vanilla JS, localStorage)
2. âœ… Weather App (API integration)
3. âœ… Task API (Express, REST)

---

### Saturday, Jan 31 - Day 31
**Topic:** Week Buffer / Catch Up
**Sessions:** 4

Use this day to:
- Catch up on any missed content
- Polish existing projects
- Extra LeetCode practice
- Review weak areas

---

### Sunday, Feb 1 - Day 32
**Topic:** TypeScript Preview
**Sessions:** 4

#### Sessions 1-2: TypeScript Introduction (100 min)
- What is TypeScript?
- Why TypeScript?
- Basic types
- Setup with Node.js

**Resources:**
- [TypeScript in 5 minutes](https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes.html)

#### Sessions 3-4: Practice (100 min)
- Convert a simple JS file to TS
- Experience the benefits

**Commit:** `Day 32: TypeScript introduction`

---

### Monday, Feb 2 - Day 33
**Topic:** Phase 1 Review & Catch Up
**Sessions:** 2

#### Session 1: JavaScript Core Review (50 min)
**Pre-Session Questions:**
1. What are the 7 primitive types in JavaScript?
2. How do closures work in JavaScript?

**Core Topics:**
- Variables and scope (let, const, var)
- Arrow functions and this binding
- Destructuring and spread/rest operators
- Array methods (map, filter, reduce)
- Promises and async/await
- Fetch API and HTTP requests
- DOM manipulation and events

**Resources:**
- Review your notes from Weeks 1-5
- [JavaScript.info Review](https://javascript.info) - Revisit weak topics
- Your previous project code

**Exercises:**
1. Write a function that takes array of numbers: `[1, 2, 3, 4, 5]` and returns `{ sum: 15, average: 3, max: 5, min: 1 }`
2. Create a Promise-based delay function that waits N milliseconds before resolving
3. Build an async function that chains 3 API calls (user â†’ posts â†’ comments)
4. Implement a debounce function using closures (delays function execution)
5. Create an event delegation example for dynamically added elements

**Hints:**
- Hint 1: Use reduce for sum, then calculate average from sum and length
- Hint 2: Wrap setTimeout in a Promise
- Hint 3: Use await for each call in sequence
- Hint 4: Return function that clears timeout on each call
- Hint 5: Attach listener to parent, check e.target

**Post-Session Recall:**
1. What's the difference between map() and forEach()?
2. When does Promise.all() reject?
3. What happens if you don't return in reduce callback?

---

#### Session 2: Weak Areas Practice (50 min)
**Pre-Session Questions:**
1. Which topics from Phase 1 do you find hardest?
2. What would you like to practice more?

**Core Topics:**
- Identify your weakest areas
- Practice those specific concepts
- Watch explanatory videos if needed
- Redo challenging exercises

**Resources:**
- Your session notes
- JavaScript.info for reference
- YouTube: Web Dev Simplified, Fireship

**Tasks:**
1. List 3 topics you struggled with most
2. Re-read documentation for each topic
3. Redo 2-3 exercises from those topics
4. Try explaining the concept out loud (rubber duck debugging)
5. Watch a video explanation if still unclear

**Post-Session Recall:**
1. Can you now explain your weakest topic?
2. What clicked today that didn't before?
3. What still needs more work?

**Commit:** `Day 33: Phase 1 review and practice`

---

### Tuesday, Feb 3 - Day 34
**Topic:** Personal Portfolio Site - Structure
**Sessions:** 2

#### Session 1: Portfolio HTML Structure (50 min)
**Pre-Session Questions:**
1. What sections should a developer portfolio include?
2. Why use semantic HTML over div soup?

**Core Topics:**
- Semantic HTML5 elements (header, nav, main, section, article, footer)
- SEO meta tags and Open Graph
- Accessibility attributes (ARIA labels, alt text)
- Document structure and hierarchy

**Resources:**
- [MDN: Semantic HTML](https://developer.mozilla.org/en-US/docs/Glossary/Semantics#semantics_in_html) (15 min)
- [A11y Project](https://www.a11yproject.com/) - Accessibility guide
- Previous portfolio examples on GitHub

**Exercises:**
1. Create HTML file with proper document structure (DOCTYPE, html, head, body)
2. Build a header with navigation (Home, About, Projects, Skills, Contact)
3. Create a hero section with your name and title
4. Add an "About Me" section describing your journey
5. Build a projects section with 3 project cards (Todo, Weather, Task API)
6. Create skills section listing: JavaScript, TypeScript, React, Node, Express, PostgreSQL, Git
7. Add contact form with fields: name, email, message, submit button
8. Include footer with social links (GitHub, LinkedIn)

**Test Data:**
- Projects: "Todo App", "Weather Dashboard", "Task API"
- Skills: JavaScript, TypeScript, HTML, CSS, React, Node.js, Express, PostgreSQL, Git, Docker
- Social: GitHub username, LinkedIn profile

**Hints:**
- Hint 1: Use `<nav>` with `<ul><li>` for navigation
- Hint 2: Each project should be in an `<article>` or `<div class="card">`
- Hint 3: Form needs proper `name` attributes and labels
- Hint 4: Use `aria-label` for icon-only links

**Post-Session Recall:**
1. What's the difference between `<section>` and `<div>`?
2. Why are semantic elements important for SEO?
3. What accessibility attributes did you add?

---

#### Session 2: Portfolio CSS Styling (50 min)
**Pre-Session Questions:**
1. When should you use Flexbox vs CSS Grid?
2. What is the mobile-first approach?

**Core Topics:**
- CSS variables (custom properties)
- Flexbox for navigation and layouts
- CSS Grid for project cards
- Responsive design with media queries
- Mobile-first methodology

**Resources:**
- [CSS-Tricks: Complete Guide to Flexbox](https://css-tricks.com/snippets/css/a-guide-to-flexbox/)
- [CSS-Tricks: Complete Guide to Grid](https://css-tricks.com/snippets/css/complete-guide-grid/)
- Review Day 17-18 notes

**Exercises:**
1. Create CSS file with variables for: primary color, secondary color, text color, background, font family, spacing values
2. Style navigation bar using Flexbox (logo left, links right)
3. Make navigation sticky on scroll
4. Center hero section content (use Flexbox, full viewport height)
5. Create projects grid: 1 column mobile, 2 columns tablet (768px), 3 columns desktop (1024px)
6. Style project cards with: image, title, description, tech tags, links
7. Make form responsive with proper spacing
8. Add hover effects to buttons and links
9. Ensure text is readable (line-height, font-size, contrast)

**Hints:**
- Hint 1: Use `:root` for CSS variables
- Hint 2: Sticky nav: `position: sticky; top: 0;`
- Hint 3: Grid: `grid-template-columns: repeat(auto-fit, minmax(300px, 1fr))`
- Hint 4: Test in Chrome DevTools mobile view

**Post-Session Recall:**
1. How do CSS variables work?
2. What's the difference between `gap` and `margin` in Grid?
3. Why start with mobile styles first?

**Commit:** `Day 34: Portfolio structure and styling`

---

### Wednesday, Feb 4 - Day 35
**Topic:** Portfolio - Interactivity & Polish
**Sessions:** 2

#### Session 1: JavaScript Interactions (50 min)
**Pre-Session Questions:**
1. What is the Intersection Observer API?
2. How do you implement smooth scrolling?

**Core Topics:**
- Smooth scroll behavior
- Intersection Observer for scroll animations
- Adding/removing classes dynamically
- Event listeners on nav links

**Resources:**
- [MDN: Intersection Observer API](https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API) (15 min)
- [MDN: scrollIntoView](https://developer.mozilla.org/en-US/docs/Web/API/Element/scrollIntoView)

**Exercises:**
1. Add click event to all nav links that start with "#"
2. Prevent default anchor behavior
3. Implement smooth scrolling to the target section
4. Add "active" class to nav link based on current section
5. Create fade-in animation class in CSS
6. Use Intersection Observer to add fade-in class when section enters viewport
7. Observe all sections for animation
8. Add typing effect to hero heading (optional challenge)

**Hints:**
- Hint 1: `element.scrollIntoView({ behavior: 'smooth' })`
- Hint 2: Intersection Observer has `threshold` option
- Hint 3: Add class when `entry.isIntersecting === true`
- Hint 4: Use `setTimeout` in loop for typing effect

**Post-Session Recall:**
1. How does Intersection Observer improve performance vs scroll events?
2. What's the difference between `preventDefault()` and `stopPropagation()`?
3. Why unobserve elements after animating?

---

#### Session 2: Dark Mode & Form Validation (50 min)
**Pre-Session Questions:**
1. How do you persist user preferences?
2. What makes a form submission valid?

**Core Topics:**
- Dark mode implementation with CSS variables
- LocalStorage for persistence
- Form validation (client-side)
- Email regex patterns
- Error message display

**Resources:**
- Review Day 12 (LocalStorage)
- [MDN: Form Validation](https://developer.mozilla.org/en-US/docs/Learn/Forms/Form_validation)

**Exercises:**
1. Add a dark mode toggle button to header
2. Create CSS with `[data-theme="dark"]` styles
3. On toggle click, switch `data-theme` attribute on document
4. Save theme preference to localStorage
5. Load saved theme on page load
6. Add form submit event listener
7. Validate all fields are filled
8. Validate email format with regex
9. Show error messages if validation fails
10. Show success message if validation passes (don't actually send yet)
11. Clear form after successful validation

**Test Data:**
- Valid email: test@example.com
- Invalid emails: test, test@, @example.com, test@example

**Hints:**
- Hint 1: `document.documentElement.setAttribute('data-theme', 'dark')`
- Hint 2: Check `localStorage.getItem('theme')` on load
- Hint 3: Email regex: `/^[^\s@]+@[^\s@]+\.[^\s@]+$/`
- Hint 4: Use `.value` to get input values

**Post-Session Recall:**
1. Why use data attributes for theming?
2. What's the difference between client-side and server-side validation?
3. How does regex pattern matching work?

**Commit:** `Day 35: Portfolio interactivity complete`

---

### Thursday, Feb 5 - Day 36
**Topic:** Review Week 1-5 & Prepare for Phase 2
**Sessions:** 2

#### Session 1: Comprehensive Review (50 min)
**Pre-Session Questions:**
1. What was the hardest concept in Phase 1?
2. What are you most proud of building?

**The Big Phase 1 Test - Answer WITHOUT looking!**

**JavaScript Core:**
1. What's the difference between `let`, `const`, and `var`?
2. Explain closures in 2 sentences.
3. What are the 3 Promise states?
4. How do you convert a Promise chain (fetch with .then) to async/await?

**Arrays:**
5. When to use map vs filter vs reduce?
6. What does `[1,2,3].reduce((a,b) => a+b, 0)` return?

**DOM:**
7. What's event delegation and why use it?
8. Difference between `textContent` and `innerHTML`?

**Async:**
9. What does `Promise.all()` do?
10. How do you handle errors with async/await?

**CSS:**
11. When to use Flexbox vs Grid?
12. What is mobile-first design?

**Node/Express:**
13. What is middleware?
14. What's the order: route handlers vs middleware?

**Git:**
15. Difference between `git add`, `git commit`, `git push`?

**Grading:**
- 12-15 correct: Excellent! Ready for Phase 2
- 9-11 correct: Good, review weak areas
- <9 correct: Review Phase 1 before continuing

**Post-Session Recall:**
1. Which topics did you struggle with?
2. Be honest: What needs more review?

---

#### Session 2: Phase 2 Prep & Goal Setting (50 min)
**Pre-Session Questions:**
1. What are you most excited to learn in Phase 2?
2. What concerns do you have?

**Phase 2 Overview:**
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  PHASE 2: BACKEND MASTERY                   â”‚
â”‚  Duration: 6 weeks (Feb 6 - Mar 21)        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Week 6-7:  TypeScript Deep Dive            â”‚
â”‚  Week 8:    PostgreSQL & Prisma ORM         â”‚
â”‚  Week 9:    Authentication & Security       â”‚
â”‚  Week 10:   Docker & Containerization       â”‚
â”‚  Week 11:   Testing (Jest)                  â”‚
â”‚  Week 12:   Blog API Project                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Setup Tasks (Just install, don't use yet!):**

1. **Download Docker Desktop:**
   - Go to [docker.com](https://www.docker.com/products/docker-desktop/)
   - Download for Windows
   - Install it (you'll learn how to USE it later in Week 10)
   - Just make sure it's installed and running

2. **Download Database GUI Tool (pick one):**
   - [TablePlus](https://tableplus.com/) (free version) OR
   - [DBeaver](https://dbeaver.io/) (completely free)
   - Install it (you'll use it when you start PostgreSQL lessons)

3. **Create Phase 2 Folder Structure:**
   - Create folder: `phase-2-backend`
   - Inside it, create: `ts-practice`, `prisma-practice`, `docker-practice`

4. **Read (Optional) - Just for preview:**
   - Skim [TypeScript in 5 minutes](https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes.html)
   - Skim [What is PostgreSQL?](https://www.postgresql.org/about/)
   - Don't worry if you don't understand yet!

5. **Set Phase 2 Goals - Write these down:**
   By March 21, I will:
   - Understand TypeScript types and generics
   - Build a REST API with Prisma and PostgreSQL
   - Understand JWT authentication
   - Containerize an application with Docker
   - Write tests for my APIs
   - Complete a full blog API with authentication

6. **Review Your Phase 1 Achievements:**
Look at what you've built:
- âœ… Todo App
- âœ… Weather App
- âœ… Task API
- âœ… Portfolio Site
- âœ… Understanding of JS, DOM, Async, Express

Take a moment to appreciate your progress! ðŸŽ‰

**Reflection Questions:**
1. What was hardest in Phase 1?
2. What was easiest?
3. What surprised you?
4. How has your confidence changed?
5. What do you want to do differently in Phase 2?

**Commit:** `Day 36: Phase 1 review complete, Phase 2 prep done`

---

### Friday, Feb 6 - Day 37
**Topic:** Advanced JavaScript Patterns & Code Optimization
**Sessions:** 2

#### Session 1: Performance Optimization Practice (50 min)
**Pre-Session Questions:**
1. What makes JavaScript code slow?
2. How do you measure performance?

**Core Topics:**
- Performance measurement
- Debouncing vs throttling implementation
- Memory leaks and how to avoid them
- Efficient DOM manipulation
- Event delegation patterns

**Resources:**
- [JavaScript Performance](https://developer.mozilla.org/en-US/docs/Web/Performance)
- Review your Phase 1 projects

**Exercises:**
1. Open browser DevTools Performance tab
2. Measure your Weather App performance
3. Find the slowest operations (paint, layout, JavaScript execution)
4. Optimize one slow operation
5. Implement debounce function from scratch (don't copy - figure it out!)
6. Implement throttle function from scratch  
7. Add debounce to search input in one of your projects
8. Add throttle to scroll event handler
9. Test performance improvement with DevTools
10. Document what you learned about performance

**Challenge:**
Create a page with 1000 list items. Implement two versions:
- Version A: Append items one by one
- Version B: Create all items in memory, append once (DocumentFragment)
Measure which is faster and why.

**Hints:**
- Hint 1: Use console.time() and console.timeEnd()
- Hint 2: Debounce delays execution until pause
- Hint 3: Throttle limits execution frequency
- Hint 4: DocumentFragment avoids multiple reflows

**Post-Session Recall:**
1. What's the difference between debounce and throttle?
2. What causes reflows?
3. How do you measure performance?

---

#### Session 2: Design Patterns Practice (50 min)
**Pre-Session Questions:**
1. What is the Module Pattern?
2. What is the Observer Pattern?

**Core Topics:**
- Module Pattern (IIFE, encapsulation)
- Observer Pattern (event-driven)
- Factory Pattern
- Singleton Pattern
- Practical applications

**Resources:**
- [JavaScript Design Patterns](https://www.patterns.dev/posts/classic-design-patterns/)

**Exercises:**
1. Refactor one of your projects to use Module Pattern
2. Create a simple Event Emitter from scratch:
   - Methods: on(event, callback), emit(event, data), off(event, callback)
   - Support multiple listeners per event
   - Test with custom events
3. Create a Factory function that creates user objects with methods
4. Implement Singleton pattern for a config manager
5. Apply Observer pattern to create a simple state management system
6. Refactor your Task API to use better separation of concerns
7. Extract repeated validation logic into reusable functions
8. Improve error handling across all projects
9. Add input sanitization where needed
10. Update Git commits to be more descriptive

**Test Your Event Emitter:**
- Subscribe to 'userLoggedIn' event
- Emit event with user data
- Multiple listeners should receive it
- Unsubscribe and verify listener removed

**Hints:**
- Hint 1: Module Pattern: `const module = (() => { return { public } })()`
- Hint 2: Store listeners in object: `{ eventName: [callbacks] }`
- Hint 3: Factory returns new object each call
- Hint 4: Singleton returns same instance always

**Post-Session Recall:**
1. When would you use Factory Pattern?
2. How does Observer Pattern work?
3. What's the benefit of Module Pattern?

**Commit:** `Day 37: Performance optimization and design patterns`

---

### Saturday, Feb 7 - Day 38
**Topic:** TypeScript Fundamentals - Day 1
**Sessions:** 4

#### Session 1: TypeScript Basics & Setup (50 min)
**Pre-Session Questions:**
1. What is TypeScript?
2. How is TypeScript different from JavaScript?

**Core Topics:**
- What TypeScript is (superset of JavaScript)
- Type safety and catching errors early
- Compilation from TS to JS
- TypeScript development workflow
- tsconfig.json basics

**Resources:**
- [TypeScript Handbook - The Basics](https://www.typescriptlang.org/docs/handbook/2/basic-types.html) (20 min)
- [TypeScript Playground](https://www.typescriptlang.org/play) - Try code online
- [Total TypeScript - Beginners Tutorial](https://www.totaltypescript.com/tutorials/beginners-typescript) (FREE)

**Exercises:**
1. Create new folder `ts-fundamentals`
2. Initialize with `npm init -y`
3. Install: typescript, ts-node, @types/node as dev dependencies
4. Run `npx tsc --init` to create tsconfig.json
5. Create `src` folder and `src/basics.ts`
6. Declare variables with explicit types: string, number, boolean, null, undefined
7. Try type inference (let TypeScript figure out the type)
8. Create arrays of numbers and strings with type annotations
9. Try assigning wrong type to variable - see the error!
10. Compile with `npx tsc` and check the `dist` folder

**Hints:**
- Hint 1: Type annotation: `let name: string = "value"`
- Hint 2: Inference: `let auto = "hello"` (TS knows it's string)
- Hint 3: Arrays: `let nums: number[] = [1, 2, 3]`
- Hint 4: Check tsconfig `outDir` and `rootDir` settings

**Post-Session Recall:**
1. What does TypeScript compile to?
2. What's type inference?
3. Why use TypeScript over JavaScript?

---

#### Session 2: Functions & Objects (50 min)
**Pre-Session Questions:**
1. How do you add types to function parameters?
2. What's a return type annotation?

**Core Topics:**
- Function parameter types
- Return type annotations
- Optional parameters (`?`)
- Default parameters
- Object type annotations
- Function types

**Resources:**
- [TypeScript Handbook - Functions](https://www.typescriptlang.org/docs/handbook/2/functions.html) (15 min)

**Exercises:**
1. Create `src/functions.ts`
2. Write function `add(a: number, b: number): number` that returns sum
3. Create function with optional parameter: `greet(name: string, greeting?: string)`
4. Create function with default parameter: `createUser(name: string, role = "user")`
5. Type a function that takes object parameter: `{ name: string, age: number, email: string }`
6. Write arrow function with types
7. Create function that takes callback: `processData(data: string, callback: (result: string) => void)`
8. Write function with rest parameters: `sum(...numbers: number[]): number`

**Test Data:**
- Test add(5, 3) â†’ 8
- Test greet("John") and greet("John", "Hi")
- Test createUser("Alice") and createUser("Alice", "admin")

**Hints:**
- Hint 1: Return type comes after parameters: `(): number`
- Hint 2: Optional with `?`: `param?: string`
- Hint 3: Callback type: `(param: type) => returnType`

**Post-Session Recall:**
1. How do you make a parameter optional?
2. What happens if you don't specify return type?
3. How do you type a callback function?

---

#### Session 3: Interfaces & Type Aliases (50 min)
**Pre-Session Questions:**
1. What is an interface in TypeScript?
2. When would you use an interface vs inline types?

**Core Topics:**
- Interface declaration syntax
- Optional properties
- Readonly properties
- Extending interfaces
- Type aliases with `type` keyword
- Interface vs Type

**Resources:**
- [TypeScript Handbook - Object Types](https://www.typescriptlang.org/docs/handbook/2/objects.html) (20 min)

**Exercises:**
1. Create `src/interfaces.ts`
2. Define interface `User` with: id (number), name (string), email (string), age (optional number), createdAt (readonly Date)
3. Create a user object using this interface
4. Try to modify `createdAt` - see the error!
5. Create interface `Admin` that extends `User` and adds: permissions (array of strings), superAdmin (boolean)
6. Create an admin object
7. Define type alias `ID` that can be string or number
8. Define type alias `Status` with literal types: "pending" | "approved" | "rejected"
9. Create interface for function: `MathOperation` that takes two numbers and returns number
10. Use this interface to type an add function

**Test Data:**
- User: id=1, name="John", email="john@example.com", createdAt=today
- Admin: extends user, permissions=["read", "write"], superAdmin=false
- Status: try assigning "cancelled" and see error

**Hints:**
- Hint 1: `interface Name { ... }`
- Hint 2: Optional: `age?: number`
- Hint 3: Readonly: `readonly prop: type`
- Hint 4: Extend: `interface Admin extends User { ... }`
- Hint 5: Type alias: `type Name = ...`

**Post-Session Recall:**
1. How do you make a property optional?
2. What does readonly do?
3. How do you extend an interface?

---

#### Session 4: Union & Intersection Types (50 min)
**Pre-Session Questions:**
1. What is a union type?
2. What's the difference between union (|) and intersection (&)?

**Core Topics:**
- Union types (`|` - OR)
- Intersection types (`&` - AND)
- Literal types
- Type narrowing with typeof
- Discriminated unions

**Resources:**
- [TypeScript Handbook - Union Types](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#union-types) (15 min)

**Exercises:**
1. Create `src/types.ts`
2. Create type `ID` that can be string OR number
3. Create type `Status` with literal types: "pending" | "completed" | "cancelled"
4. Write function that accepts `string | number` and uses typeof to narrow type
5. Create type `Person` with name and age
6. Create type `Employee` with employeeId and department
7. Create intersection type `Staff` that combines Person & Employee
8. Create union type `Result` that's either `{ success: true, data: any }` OR `{ success: false, error: string }`
9. Write function that takes Result and narrows based on success property
10. Create discriminated union for shapes (Circle with radius, Square with sideLength)

**Test Data:**
- ID: try "abc123" and 42
- Status: try "pending", try "invalid" (error)
- Result: try both success and failure cases

**Hints:**
- Hint 1: Union: `type X = A | B`
- Hint 2: Intersection: `type X = A & B`
- Hint 3: Narrowing: use `if (typeof value === "string")`
- Hint 4: Discriminated union needs common property (like "kind")

**Post-Session Recall:**
1. What's a union type?
2. What's an intersection type?
3. What are literal types?
4. How does type narrowing work?

**Commit:** `Day 38: TypeScript fundamentals - types and interfaces`

---

### Sunday, Feb 8 - Day 39
**Topic:** TypeScript Fundamentals - Day 2
**Sessions:** 4

#### Session 1: Generics Basics (50 min)
**Pre-Session Questions:**
1. What problem do generics solve?
2. What does `<T>` mean in TypeScript?

**Core Topics:**
- What generics are (reusable with any type)
- Generic function syntax
- Type parameters
- Generic constraints
- Multiple type parameters

**Resources:**
- [TypeScript Handbook - Generics](https://www.typescriptlang.org/docs/handbook/2/generics.html) (20 min)
- [Matt Pocock - Generics Tutorial](https://www.youtube.com/watch?v=EcCTIExsqmI) (video)

**Exercises:**
1. Create `src/generics.ts`
2. Write generic function `identity<T>(value: T): T` that returns same value
3. Test it with string and number
4. Write generic function `getFirst<T>(array: T[]): T | undefined`
5. Create generic function `pair<T, U>(first: T, second: U): [T, U]`
6. Write generic with constraint: function that works with anything that has `length` property
7. Create generic interface `Box<T>` with value property of type T
8. Use Box with different types (Box<string>, Box<number>)
9. Create generic type `Result<T>` for API responses
10. Write function using Result<User>

**Test Data:**
- identity("hello"), identity(42)
- getFirst([1, 2, 3]), getFirst(["a", "b"])
- pair(42, "hello"), pair(true, { name: "John" })

**Hints:**
- Hint 1: Generic syntax: `<T>` after function name
- Hint 2: Constraint: `<T extends { length: number }>`
- Hint 3: Multiple params: `<T, U>`
- Hint 4: Generic interface: `interface Name<T> { ... }`

**Post-Session Recall:**
1. What does `<T>` represent?
2. How do you constrain a generic?
3. Can you have multiple type parameters?

---

#### Session 2: Utility Types (50 min)
**Pre-Session Questions:**
1. What are utility types?
2. Name 3 built-in TypeScript utility types

**Core Topics:**
- Partial<T> - makes all properties optional
- Required<T> - makes all properties required
- Readonly<T> - makes all properties readonly
- Pick<T, K> - select specific properties
- Omit<T, K> - exclude specific properties
- Record<K, T> - create object type

**Resources:**
- [TypeScript Utility Types](https://www.typescriptlang.org/docs/handbook/utility-types.html) (20 min - bookmark this!)

**Exercises:**
1. Create `src/utility-types.ts`
2. Define interface User with: id, name, email, password, age
3. Create type using Partial<User> (all optional)
4. Create type using Pick<User, "id" | "name" | "email"> (no password)
5. Create type using Omit<User, "password"> (all except password)
6. Create type using Readonly<User> (try to modify property - error!)
7. Use Required on interface with optional properties
8. Create Record<string, string[]> for user roles
9. Extract return type of a function using ReturnType<typeof fn>
10. Combine utility types: Partial<Omit<User, "id">>

**Test Data:**
- User: id=1, name="John", email="john@example.com", password="secret", age=25
- Roles: { admin: ["read", "write"], user: ["read"] }

**Hints:**
- Hint 1: Partial makes everything optional
- Hint 2: Pick selects properties, Omit excludes
- Hint 3: Record creates object with specific key/value types
- Hint 4: Can chain utility types

**Post-Session Recall:**
1. What does Partial<T> do?
2. What's the difference between Pick and Omit?
3. When would you use Record?

---

#### Session 3: TypeScript with Node.js (50 min)
**Pre-Session Questions:**
1. How do you set up TypeScript with Node.js?
2. What is @types/node?

**Core Topics:**
- TypeScript + Node.js setup
- tsconfig.json for Node
- @types packages
- Type definitions for Node modules
- Compiling and running

**Resources:**
- [TypeScript Node Starter](https://github.com/microsoft/TypeScript-Node-Starter)
- Review your Day 22-23 Node.js notes

**Exercises:**
1. Create new folder `ts-node-app`
2. Initialize: `npm init -y`
3. Install: typescript, ts-node, @types/node as dev dependencies
4. Create tsconfig with Node settings (target: ES2020, module: commonjs)
5. Set outDir to ./dist and rootDir to ./src
6. Create src/index.ts
7. Import fs and path modules (notice the types!)
8. Create interface Config with port, host, databaseUrl
9. Write function to read config from JSON file (typed)
10. Add npm scripts: "build", "start", "dev"
11. Test: run dev script with ts-node

**Test Data:**
- Create config.json with: { "port": 3000, "host": "localhost", "databaseUrl": "..." }

**Hints:**
- Hint 1: Import: `import fs from 'fs'`
- Hint 2: @types/node provides Node types
- Hint 3: Dev script: "nodemon --exec ts-node src/index.ts"
- Hint 4: Build script: "tsc"

**Post-Session Recall:**
1. What does @types/node provide?
2. What's the purpose of outDir in tsconfig?
3. Why use ts-node in development?

---

#### Session 4: TypeScript with Express (50 min)
**Pre-Session Questions:**
1. How do you type Express request/response?
2. What types does @types/express provide?

**Core Topics:**
- Express with TypeScript setup
- Typing Request and Response
- Typing request body, params, query
- Extending Request interface
- Middleware typing

**Resources:**
- [@types/express documentation](https://www.npmjs.com/package/@types/express)
- Review Day 24 Express notes

**Exercises:**
1. Install: express and @types/express
2. Create src/app.ts
3. Set up basic Express server with types
4. Create interface User with id, name, email
5. Type GET route: `app.get('/users', (req: Request, res: Response) => ...)`
6. Create interface CreateUserBody
7. Type POST route with body type: `Request<{}, {}, CreateUserBody>`
8. Create interface for route params: `{ id: string }`
9. Type GET route with params: `/users/:id`
10. Create interface for query params
11. Type GET route with query: `/search?name=...&limit=...`
12. Create custom middleware with proper types
13. Extend Request interface to add custom properties

**Test Data:**
- Users array: [{ id: 1, name: "John", email: "john@example.com" }]
- CreateUserBody: { name: "Jane", email: "jane@example.com" }

**Hints:**
- Hint 1: Import: `Request, Response, NextFunction` from express
- Hint 2: Request generic: `Request<Params, ResBody, ReqBody, ReqQuery>`
- Hint 3: Extend interface: declare it again with same name
- Hint 4: Middleware: `(req, res, next) => ...`

**Post-Session Recall:**
1. How do you type Express request body?
2. How do you type route parameters?
3. How do you extend the Request interface?

**Commit:** `Day 39: TypeScript with Node.js and Express`

---

### Monday, Feb 9 - Day 40
**Topic:** Convert Task API to TypeScript
**Sessions:** 2

#### Session 1: TypeScript Conversion - Setup (50 min)
**Pre-Session Questions:**
1. What needs to change when converting JS to TS?
2. How do you handle existing JavaScript files?

**Core Topics:**
- Migrating JavaScript project to TypeScript
- Renaming files (.js â†’ .ts)
- Adding type definitions
- Fixing type errors incrementally
- Testing after conversion

**Resources:**
- Your Task API from Phase 1
- [TypeScript Migration Guide](https://www.typescriptlang.org/docs/handbook/migrating-from-javascript.html)

**Exercises:**
1. Open your Task API project
2. Install TypeScript dependencies: typescript, ts-node, @types/node, @types/express
3. Create tsconfig.json with proper settings
4. Rename all .js files to .ts (start with index.js â†’ index.ts)
5. Create src/types.ts file
6. Define interface Task with: id, title, description (optional), completed, priority, createdAt, updatedAt
7. Define interface CreateTaskDTO (what's needed to create task)
8. Define interface UpdateTaskDTO (partial updates)
9. Define interface TaskQuery (query parameters)
10. Fix import errors that appear
11. Run `npx tsc` and fix initial errors

**Hints:**
- Hint 1: Start with types/interfaces first
- Hint 2: Use Partial<> for update DTOs
- Hint 3: Priority as literal type: "low" | "medium" | "high"
- Hint 4: Fix errors one file at a time

**Post-Session Recall:**
1. What's the first step in JS to TS migration?
2. Why create separate types file?
3. What's a DTO?

---

#### Session 2: TypeScript Conversion - Routes & Middleware (50 min)
**Pre-Session Questions:**
1. How do you type Express route handlers?
2. How do you type custom middleware?

**Core Topics:**
- Typing route handlers
- Typing request/response
- Typing middleware functions
- Error handling with types
- Testing typed API

**Exercises:**
1. Type all route handlers in tasks routes
2. Use Request<Params, ResBody, ReqBody, ReqQuery> generics
3. Type GET /tasks route with TaskQuery
4. Type POST /tasks route with CreateTaskDTO
5. Type PUT /tasks/:id with params and UpdateTaskDTO
6. Type DELETE /tasks/:id with params
7. Type any middleware functions (validation, error handling)
8. Create custom error classes with proper types
9. Test all endpoints with Thunder Client/Postman
10. Ensure all type errors are resolved
11. Update README with TypeScript info
12. Commit and push to GitHub

**Test Cases:**
- Create task: { title: "Test", description: "...", priority: "high" }
- Update task: { completed: true }
- Get tasks with query: ?completed=false&priority=high

**Hints:**
- Hint 1: Extract route handler types to separate file
- Hint 2: Use type guards for validation
- Hint 3: Error classes extend Error
- Hint 4: Test after each file conversion

**Post-Session Recall:**
1. How does TypeScript improve API development?
2. What errors did TypeScript catch that JS didn't?
3. How do you feel about TypeScript now?

**Commit:** `Day 40: Task API fully typed with TypeScript`

---

### Tuesday, Feb 10 - Day 41
**Topic:** TypeScript Practice & Advanced Concepts
**Sessions:** 2

#### Session 1: Type Challenges (50 min)
**Pre-Session Questions:**
1. What TypeScript features are you weakest on?
2. What would you like more practice with?

**Core Topics:**
- Practicing TypeScript concepts
- Type challenges and puzzles
- Real-world type scenarios
- Building type confidence

**Resources:**
- [Type Challenges](https://github.com/type-challenges/type-challenges) (Easy ones)
- [TypeScript Exercises](https://typescript-exercises.github.io/)

**Exercises:**
1. Create generic function that swaps two values in tuple
2. Create type that makes all properties of nested object readonly (DeepReadonly)
3. Create type that makes all properties optional recursively (DeepPartial)
4. Extract array element type: if `T = number[]`, get `number`
5. Create type that converts all string properties to number properties
6. Build a type-safe event emitter with typed events
7. Create tuple type of specific length using generics
8. Build type that extracts all function property names from object
9. Create conditional type that checks if type is a Promise
10. Build mapped type that adds prefix to all property names

**Hints:**
- Hint 1: Swap: `[T, U]` â†’ `[U, T]`
- Hint 2: DeepReadonly needs recursion
- Hint 3: Array element: `T extends Array<infer U> ? U : never`
- Hint 4: Use mapped types: `{ [K in keyof T]: ... }`

**Post-Session Recall:**
1. What's a mapped type?
2. What's a conditional type?
3. What does `infer` keyword do?

---

#### Session 2: Review & Consolidate (50 min)
**Pre-Session Questions:**
1. Can you explain generics to someone else?
2. What's still confusing about TypeScript?

**Core Topics:**
- Review all TypeScript concepts
- Clarify confusing topics
- Practice weak areas
- Prepare for database work ahead

**Review Questions (No looking!):**
1. What's the difference between interface and type?
2. Explain generics in one sentence
3. What does Partial<T> do?
4. How do you type function parameters?
5. What's a union type?
6. What's an intersection type?
7. How do you extend an interface?
8. What are literal types?
9. How do you make property optional?
10. What's type narrowing?

**Tasks:**
1. Review your notes from Days 38-40
2. Redo 2-3 exercises you found hard
3. Watch a TypeScript video if needed
4. Test yourself with the questions above
5. Clean up any incomplete code

**Grading:**
- 8-10 correct: Great! Ready to move on
- 6-7 correct: Review specific topics
- <6 correct: Spend extra time on TypeScript

**Post-Session Recall:**
1. What TypeScript concept finally clicked?
2. What do you still need to practice?
3. Feeling confident with TS?

**Commit:** `Day 41: TypeScript review and practice`

---

### Wednesday, Feb 11 - Day 42
**Topic:** PostgreSQL Introduction
**Sessions:** 2

#### Session 1: PostgreSQL Setup with Docker (50 min)
**Pre-Session Questions:**
1. What is PostgreSQL?
2. Why use Docker for databases?

**Core Topics:**
- What PostgreSQL is (relational database)
- Relational database concepts
- Tables, rows, columns
- Primary keys and data types
- Docker for development databases

**Resources:**
- [PostgreSQL Tutorial](https://www.postgresqltutorial.com/) (Bookmark this!)
- [Docker Postgres Image](https://hub.docker.com/_/postgres)

**Exercises:**
1. Open terminal
2. Pull PostgreSQL image: `docker pull postgres:15`
3. Run PostgreSQL container with: password, user, database name, port mapping
4. Check container is running: `docker ps`
5. Connect to PostgreSQL with psql in container
6. Create your first table: users (id, name, email, age, created_at)
7. Use SERIAL for auto-increment id
8. Use VARCHAR for name and email
9. Use INTEGER for age
10. Use TIMESTAMP for created_at with default NOW()
11. View table structure: `\d users`
12. Exit psql

**Docker Command Help:**
- Name container: `--name dev-postgres`
- Set password: `-e POSTGRES_PASSWORD=yourpassword`
- Set database: `-e POSTGRES_DB=devdb`
- Port mapping: `-p 5432:5432`
- Run in background: `-d`

**Hints:**
- Hint 1: SERIAL = auto-incrementing integer
- Hint 2: Use constraints: NOT NULL, UNIQUE
- Hint 3: DEFAULT value for timestamps
- Hint 4: CONSTRAINT for checks

**Post-Session Recall:**
1. What's a primary key?
2. What's the difference between VARCHAR and TEXT?
3. What does SERIAL do?

---

#### Session 2: Basic SQL Operations (CRUD) (50 min)
**Pre-Session Questions:**
1. What does CRUD stand for?
2. What SQL command creates data?

**Core Topics:**
- INSERT - creating data
- SELECT - reading data
- UPDATE - modifying data
- DELETE - removing data
- WHERE clauses
- ORDER BY and LIMIT

**Resources:**
- [SQL Tutorial - CRUD](https://www.postgresqltutorial.com/postgresql-tutorial/postgresql-insert/)

**Exercises:**
1. INSERT 5 users into users table with different names, emails, ages
2. SELECT all users
3. SELECT only names and emails
4. SELECT users WHERE age > 25
5. SELECT users WHERE name starts with 'J' (use LIKE)
6. SELECT users ordered by age (ascending)
7. SELECT users ordered by created_at (descending)
8. SELECT only 3 users (use LIMIT)
9. UPDATE a user's age WHERE id = 1
10. UPDATE multiple users WHERE condition
11. DELETE a user WHERE id = 5
12. DELETE all users WHERE age < 18

**Test Data:**
- User 1: John Doe, john@example.com, 30
- User 2: Jane Smith, jane@example.com, 25
- User 3: Bob Johnson, bob@example.com, 35
- User 4: Alice Williams, alice@example.com, 22
- User 5: Charlie Brown, charlie@example.com, 28

**Hints:**
- Hint 1: INSERT: `INSERT INTO table (columns) VALUES (values)`
- Hint 2: WHERE: `SELECT * FROM table WHERE condition`
- Hint 3: LIKE: use % for wildcards
- Hint 4: ORDER BY: ASC or DESC

**Post-Session Recall:**
1. What's the syntax for INSERT?
2. How do you filter results?
3. What does LIMIT do?

**Commit:** `Day 42: PostgreSQL basics - setup and CRUD`

---

### Thursday, Feb 12 - Day 43
**Topic:** PostgreSQL Relationships
**Sessions:** 2

#### Session 1: Foreign Keys & One-to-Many (50 min)
**Pre-Session Questions:**
1. What is a foreign key?
2. What's a one-to-many relationship?

**Core Topics:**
- Foreign keys
- Referential integrity
- ON DELETE CASCADE
- One-to-many relationships
- INNER JOIN
- LEFT JOIN

**Resources:**
- [PostgreSQL Foreign Keys](https://www.postgresqltutorial.com/postgresql-tutorial/postgresql-foreign-key/)
- [PostgreSQL Joins](https://www.postgresqltutorial.com/postgresql-tutorial/postgresql-joins/)

**Exercises:**
1. Create posts table with: id, title, content, user_id (foreign key), created_at
2. Add foreign key constraint: user_id REFERENCES users(id)
3. Add ON DELETE CASCADE (delete posts when user deleted)
4. INSERT 10 posts (link to different users)
5. SELECT all posts
6. SELECT posts with user information (INNER JOIN)
7. SELECT all users and their posts (LEFT JOIN)
8. SELECT posts WHERE user_id = 1
9. COUNT posts per user (GROUP BY)
10. Find users who have more than 2 posts
11. Delete a user and verify their posts are also deleted

**Test Data:**
- Post 1: "First Post", "Content here", user_id=1
- Post 2: "Another Post", "More content", user_id=1
- Post 3: "Hello World", "Content", user_id=2
- (Create 7 more posts linking to different users)

**Hints:**
- Hint 1: Foreign key: `user_id INTEGER REFERENCES users(id) ON DELETE CASCADE`
- Hint 2: INNER JOIN: `FROM posts JOIN users ON posts.user_id = users.id`
- Hint 3: LEFT JOIN includes all from left table
- Hint 4: GROUP BY with COUNT: `COUNT(*) GROUP BY user_id`

**Post-Session Recall:**
1. What does ON DELETE CASCADE do?
2. What's the difference between INNER JOIN and LEFT JOIN?
3. When would you use GROUP BY?

---

#### Session 2: Many-to-Many Relationships (50 min)
**Pre-Session Questions:**
1. What is a many-to-many relationship?
2. How do you implement it in SQL?

**Core Topics:**
- Many-to-many relationships
- Junction/join tables
- Composite primary keys
- Querying many-to-many relationships
- Array aggregation

**Resources:**
- [PostgreSQL Many-to-Many](https://www.postgresqltutorial.com/postgresql-tutorial/postgresql-many-to-many-relationship/)

**Exercises:**
1. Create tags table with: id, name (unique)
2. Create post_tags junction table with: post_id, tag_id
3. Both columns reference their respective tables
4. Set PRIMARY KEY as combination of both columns
5. INSERT 5 tags: "javascript", "typescript", "node", "react", "postgres"
6. Link posts to tags (each post can have multiple tags)
7. SELECT all tags for a specific post
8. SELECT all posts for a specific tag
9. SELECT posts with their tags (use array_agg)
10. Find posts that have both "javascript" AND "typescript" tags
11. Count posts per tag
12. Find tags that aren't used on any posts

**Test Data:**
- Tags: javascript, typescript, node, react, postgres
- Post 1 has tags: javascript, node
- Post 2 has tags: typescript, react
- Post 3 has tags: javascript, typescript, postgres

**Hints:**
- Hint 1: Junction table: two foreign keys, composite PK
- Hint 2: array_agg aggregates values into array
- Hint 3: Multiple tags: need multiple JOINs or subqueries
- Hint 4: HAVING clause for filtering aggregates

**Post-Session Recall:**
1. Why do we need junction tables?
2. What's a composite primary key?
3. What does array_agg do?

**Commit:** `Day 43: PostgreSQL relationships and JOINs`

---

### Friday, Feb 13 - Day 44
**Topic:** Prisma ORM Introduction
**Sessions:** 2

#### Session 1: Prisma Setup & Schema (50 min)
**Pre-Session Questions:**
1. What is an ORM?
2. Why use Prisma instead of raw SQL?

**Core Topics:**
- What Prisma is (ORM for Node.js/TypeScript)
- Prisma Client
- Prisma schema syntax
- Models and fields
- Relationships in Prisma
- Migrations

**Resources:**
- [Prisma Documentation](https://www.prisma.io/docs) (BOOKMARK THIS!)
- [Prisma Get Started](https://www.prisma.io/docs/getting-started)

**Exercises:**
1. Create new folder `prisma-intro`
2. Initialize Node project
3. Install prisma and @prisma/client
4. Install dev dependencies: typescript, ts-node, @types/node
5. Run `npx prisma init`
6. Edit .env with your PostgreSQL DATABASE_URL
7. Open prisma/schema.prisma
8. Create User model with: id, email (unique), name, age (optional), posts (relation), createdAt, updatedAt
9. Create Post model with: id, title, content (optional), published (default false), author (relation), authorId, createdAt, updatedAt
10. Define relationship between User and Post (one-to-many)
11. Run migration: `npx prisma migrate dev --name init`
12. Generate Prisma Client: `npx prisma generate`

**Schema Syntax Help:**
- Field: `name Type @attribute`
- ID: `@id @default(autoincrement())`
- Unique: `@unique`
- Optional: `?`
- Relation: `model[]` and `@relation`

**Hints:**
- Hint 1: One User has many Posts: `posts Post[]`
- Hint 2: One Post belongs to User: `author User @relation`
- Hint 3: Need authorId field for foreign key
- Hint 4: @updatedAt auto-updates on changes

**Post-Session Recall:**
1. What does `npx prisma generate` do?
2. How do you define a one-to-many relationship?
3. What's a migration?

---

#### Session 2: Prisma CRUD Operations (50 min)
**Pre-Session Questions:**
1. How do you create data with Prisma?
2. What's an "include" in Prisma?

**Core Topics:**
- Prisma Client usage
- CRUD operations with Prisma
- Create, findMany, findUnique
- Update, delete
- Relations and include
- Where clauses
- Ordering and pagination

**Resources:**
- [Prisma Client API](https://www.prisma.io/docs/concepts/components/prisma-client)

**Exercises:**
1. Create src/index.ts
2. Import PrismaClient and instantiate
3. Create a user (name, email)
4. Create user with nested post creation
5. Find all users
6. Find all users with their posts (include relation)
7. Find unique user by email
8. Find unique user by id with posts
9. Update user's name
10. Create a post linked to existing user
11. Find all posts where published = true
12. Delete a post
13. Delete a user (see cascade delete)
14. Implement: findMany with pagination (skip, take)
15. Implement: findMany with ordering (orderBy)
16. Disconnect Prisma Client at end

**Test Data:**
- User 1: John Doe, john@example.com
- User 2: Jane Smith, jane@example.com
- Posts for User 1: "First Post", "Second Post"
- Posts for User 2: "Hello World"

**Hints:**
- Hint 1: create: `prisma.user.create({ data: {...} })`
- Hint 2: Nested: `data: { ..., posts: { create: [...] } }`
- Hint 3: Include: `prisma.user.findMany({ include: { posts: true } })`
- Hint 4: Pagination: `skip: 0, take: 10`
- Hint 5: Always disconnect: `prisma.$disconnect()`

**Post-Session Recall:**
1. What's the difference between findUnique and findFirst?
2. How do you include relations?
3. How do you create nested data?

**Commit:** `Day 44: Prisma ORM basics`

---

### Saturday, Feb 14 - Day 45
**Topic:** Prisma Advanced & Blog API Start
**Sessions:** 4

#### Session 1: Prisma Advanced Queries (50 min)
**Pre-Session Questions:**
1. How do you filter data in Prisma?
2. What's the difference between AND and OR filters?

**Core Topics:**
- Where filters (equals, contains, gt, lt)
- Combining filters (AND, OR, NOT)
- Searching across relationships
- Aggregations (count, avg, sum)
- Grouping results

**Resources:**
- [Prisma Filtering](https://www.prisma.io/docs/concepts/components/prisma-client/filtering-and-sorting)

**Exercises:**
1. Find users where name contains "John"
2. Find users where age greater than 25
3. Find users where email ends with "@example.com"
4. Find users where age between 20 and 30 (use AND)
5. Find posts where title contains "typescript" OR "javascript"
6. Find users who have at least one published post
7. Count total users
8. Count total posts per user
9. Find user with most posts
10. Find posts with specific tags (add Tag model to schema)
11. Search posts by title AND user name
12. Implement full-text search on posts

**Hints:**
- Hint 1: contains: `{ name: { contains: "text" } }`
- Hint 2: Comparison: `{ age: { gt: 25 } }`
- Hint 3: AND: `{ AND: [condition1, condition2] }`
- Hint 4: Relations: `{ posts: { some: { published: true } } }`

**Post-Session Recall:**
1. What's the difference between some, every, none?
2. How do you combine multiple filters?
3. How do you count related records?

---

#### Session 2: Blog API Project Setup (50 min)
**Pre-Session Questions:**
1. What makes a good blog API?
2. What features should it have?

**Core Topics:**
- Blog API requirements
- Project structure
- Database schema design
- Planning routes and endpoints

**Project Planning:**

**Required Features:**
- User authentication (coming soon)
- CRUD posts
- CRUD comments
- Tags for posts
- Published vs draft posts
- Author relationships

**Exercises:**
1. Create new folder `blog-api`
2. Initialize Node + TypeScript project
3. Install: express, @types/express, prisma, @prisma/client
4. Set up folder structure: src/(routes, controllers, middleware, types, utils)
5. Initialize Prisma
6. Design Prisma schema with models: User, Post, Comment, Tag
7. User fields: id, email (unique), password, name, posts, comments
8. Post fields: id, title, slug (unique), content, excerpt, published, author, authorId, comments, tags
9. Comment fields: id, content, author, authorId, post, postId
10. Tag fields: id, name (unique), posts (many-to-many)
11. Run migration
12. Create basic Express server in src/index.ts
13. Plan routes (don't implement yet): GET/POST/PUT/DELETE for posts, comments, tags

**Hints:**
- Hint 1: Slug for URL-friendly post titles
- Hint 2: Many-to-many needs implicit or explicit join
- Hint 3: Comment belongs to both User and Post
- Hint 4: published boolean for draft functionality

**Post-Session Recall:**
1. Why use slug instead of ID in URLs?
2. What's an implicit vs explicit many-to-many?
3. How should the folder structure be organized?

---

#### Session 3: Blog API - User Routes (50 min)
**Pre-Session Questions:**
1. What user operations does the API need?
2. Should passwords be stored as plain text?

**Core Topics:**
- User CRUD routes
- Input validation
- Password hashing (bcrypt - install it)
- Error handling
- Response formatting

**Exercises:**
1. Install bcrypt and @types/bcrypt
2. Create src/routes/users.ts
3. Create src/controllers/userController.ts
4. Implement GET /api/users (list all, exclude passwords)
5. Implement GET /api/users/:id (single user, with posts)
6. Implement POST /api/users (create, hash password before saving)
7. Implement PUT /api/users/:id (update, hash password if changed)
8. Implement DELETE /api/users/:id
9. Add validation middleware for email format
10. Add validation for required fields
11. Handle errors (user not found, duplicate email)
12. Type all route handlers with TypeScript
13. Test all endpoints

**Validation Rules:**
- Email must be valid format
- Password minimum 8 characters
- Name required
- Email unique

**Hints:**
- Hint 1: bcrypt.hash() before creating user
- Hint 2: Exclude password: `select: { password: false }`
- Hint 3: Check existing email before creating
- Hint 4: Return 404 if user not found

**Post-Session Recall:**
1. Why hash passwords?
2. How do you exclude fields in Prisma?
3. What HTTP status for "not found"?

---

#### Session 4: Blog API - Post Routes (50 min)
**Pre-Session Questions:**
1. What post operations are needed?
2. How should filtering work?

**Core Topics:**
- Post CRUD routes
- Slug generation
- Query parameters for filtering
- Pagination
- Including relations

**Exercises:**
1. Create src/routes/posts.ts
2. Create src/controllers/postController.ts
3. Implement GET /api/posts (all posts, with filters: published, authorId, tag)
4. Add pagination with query params: page, limit
5. Implement GET /api/posts/:slug (single post by slug, include author and comments)
6. Implement POST /api/posts (create, generate slug from title)
7. Implement PUT /api/posts/:id (update)
8. Implement DELETE /api/posts/:id
9. Add route to publish/unpublish: PATCH /api/posts/:id/publish
10. Filter by tags: GET /api/posts?tag=javascript
11. Search posts: GET /api/posts?search=query
12. Type all handlers
13. Test all endpoints

**Slug Generation:**
- Convert title to lowercase
- Replace spaces with hyphens
- Remove special characters
- Ensure uniqueness

**Hints:**
- Hint 1: Generate slug before creating post
- Hint 2: Pagination: skip = (page - 1) * limit
- Hint 3: Search: use contains on title and content
- Hint 4: Use where with multiple conditions

**Post-Session Recall:**
1. Why use slugs instead of IDs?
2. How does pagination work?
3. How do you filter by related data?

**Commit:** `Day 45: Blog API setup with User and Post routes`

---

## ðŸŽ‰ PHASE 1 COMPLETE!
npm init -y
npm install -D typescript ts-node @types/node
npx tsc --init
```

**Edit tsconfig.json:**
```json
{
  "compilerOptions": {
    "target": "ES2020",
    "module": "commonjs",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "outDir": "./dist",
    "rootDir": "./src"
  }
}
```

**Create src/basics.ts:**
```typescript
// Primitive types
let name: string = "Sebastian";
let age: number = 25;
let isActive: boolean = true;
let nothing: null = null;
let notDefined: undefined = undefined;

// Type inference (TypeScript figures it out)
let inferredString = "Hello"; // Type: string
let inferredNumber = 42; // Type: number

// Arrays
let numbers: number[] = [1, 2, 3, 4, 5];
let strings: Array<string> = ["a", "b", "c"];

// Tuple (fixed-length array with specific types)
let person: [string, number] = ["Sebastian", 25];

// Enum
enum Role {
  Admin = "ADMIN",
  User = "USER",
  Guest = "GUEST"
}
let userRole: Role = Role.User;

// Any (avoid this!)
let anything: any = "could be anything";
anything = 42;
anything = true;

// Unknown (safer than any)
let userInput: unknown;
userInput = 5;
userInput = "hello";
// Can't use without type checking:
if (typeof userInput === "string") {
  console.log(userInput.toUpperCase()); // Now TS knows it's a string
}

// Void (function returns nothing)
function logMessage(message: string): void {
  console.log(message);
}

// Never (function never returns)
function throwError(message: string): never {
  throw new Error(message);
}
```

**Exercises (NO SOLUTIONS):**
1. Create variables of each primitive type
2. Create an array of numbers and an array of strings
3. Create a tuple representing a user: [id, name, age]
4. Create an enum for HTTP status codes (200, 404, 500, etc.)
5. Write a function that takes `unknown` and safely checks if it's a number before using it

**Hints:**
- Hint 1: Tuples have exact length and order
- Hint 2: Use typeof for type narrowing
- Hint 3: Enums can have string or number values

**Post-Session Recall:**
1. What's the difference between `any` and `unknown`?
2. When would a function return `never`?
3. What is type inference?

---

#### Session 2: Functions & Objects (50 min)
**Pre-Session Questions:**
1. How do you type function parameters?
2. How do you type function return values?

**Core Topics:**
- Function parameter types
- Return type annotations
- Optional parameters (`?`)
- Default parameters
- Object type annotations

**Create src/functions.ts:**
```typescript
// Basic function typing
function add(a: number, b: number): number {
  return a + b;
}

// Function with optional parameter
function greet(name: string, greeting?: string): string {
  return `${greeting || "Hello"}, ${name}!`;
}

// Function with default parameter
function createUser(name: string, role: string = "user"): object {
  return { name, role };
}

// Object parameter type
function printUser(user: { name: string; age: number; email: string }): void {
  console.log(`${user.name} (${user.age}): ${user.email}`);
}

// Arrow function
const multiply = (a: number, b: number): number => a * b;

// Function type
let mathFunc: (x: number, y: number) => number;
mathFunc = (a, b) => a + b;

// Rest parameters
function sum(...numbers: number[]): number {
  return numbers.reduce((total, n) => total + n, 0);
}

// Type for callback
function processData(
  data: string,
  callback: (result: string) => void
): void {
  const processed = data.toUpperCase();
  callback(processed);
}

// Multiple return types (union)
function getConfig(key: string): string | number | boolean {
  // Implementation
  return "value";
}
```

**Exercises:**
1. Create a function `calculateArea(width: number, height: number): number`
2. Create a function with optional `tax` parameter that calculates total price
3. Create a function that takes an object `{ firstName: string, lastName: string, age?: number }`
4. Create a function that takes a callback: `executeTask(task: string, onComplete: (result: string) => void)`
5. Create a function with rest parameters that finds the maximum number

**Post-Session Recall:**
1. How do you make a parameter optional?
2. What's the syntax for typing a callback function?
3. Can a function return multiple types? How?

---

#### Session 3: Interfaces (50 min)
**Pre-Session Questions:**
1. What is an interface in TypeScript?
2. Why use interfaces instead of inline object types?

**Core Topics:**
- Interface declaration
- Optional properties
- Readonly properties
- Extending interfaces
- Interface for functions

**Create src/interfaces.ts:**
```typescript
// Basic interface
interface User {
  id: number;
  name: string;
  email: string;
  age?: number; // optional
  readonly createdAt: Date; // readonly
}

// Using the interface
const user: User = {
  id: 1,
  name: "Sebastian",
  email: "seb@example.com",
  createdAt: new Date()
};

// user.createdAt = new Date(); // Error! readonly property

// Extending interfaces
interface Admin extends User {
  permissions: string[];
  superAdmin: boolean;
}

const admin: Admin = {
  id: 2,
  name: "Admin User",
  email: "admin@example.com",
  createdAt: new Date(),
  permissions: ["read", "write", "delete"],
  superAdmin: true
};

// Interface for array
interface UserList {
  users: User[];
  total: number;
}

// Interface for functions
interface MathOperation {
  (a: number, b: number): number;
}

const add: MathOperation = (x, y) => x + y;
const subtract: MathOperation = (x, y) => x - y;

// Interface for API response
interface ApiResponse<T> {
  data: T;
  status: number;
  message: string;
  timestamp: Date;
}

// Using generic interface
const userResponse: ApiResponse<User> = {
  data: user,
  status: 200,
  message: "Success",
  timestamp: new Date()
};

// Multiple inheritance
interface Timestamps {
  createdAt: Date;
  updatedAt: Date;
}

interface Deletable {
  deletedAt?: Date;
  isDeleted: boolean;
}

interface Post extends Timestamps, Deletable {
  id: number;
  title: string;
  content: string;
  authorId: number;
}
```

**Exercises:**
1. Create a `Product` interface with: id, name, price, inStock (optional), category
2. Create a `CartItem` interface that extends Product and adds: quantity
3. Create a `ShoppingCart` interface with: items (CartItem[]), total, userId
4. Create an interface for a function that calculates discount: `(price: number, percentage: number) => number`
5. Create a generic `Result<T>` interface that represents either success or error

**Hints:**
- Hint 1: Use `?` for optional properties
- Hint 2: Extend with `extends` keyword
- Hint 3: Generic with `<T>` after interface name

**Post-Session Recall:**
1. How do you make a property optional?
2. How do you extend an interface?
3. What's the benefit of interfaces over inline types?

---

#### Session 4: Type Aliases & Union Types (50 min)
**Pre-Session Questions:**
1. What's the difference between `interface` and `type`?
2. What is a union type?

**Core Topics:**
- Type aliases
- Union types (`|`)
- Intersection types (`&`)
- Literal types
- Type narrowing

**Create src/types.ts:**
```typescript
// Type alias for primitives
type ID = string | number;
type Email = string;

// Union types
type Status = "pending" | "approved" | "rejected";
let orderStatus: Status = "pending";
// orderStatus = "cancelled"; // Error!

// Type alias for objects
type Point = {
  x: number;
  y: number;
};

// Intersection types (&) - combine types
type Timestamped = {
  createdAt: Date;
  updatedAt: Date;
};

type User = {
  id: number;
  name: string;
};

type TimestampedUser = User & Timestamped;

const user: TimestampedUser = {
  id: 1,
  name: "Sebastian",
  createdAt: new Date(),
  updatedAt: new Date()
};

// Union with objects
type SuccessResponse = {
  success: true;
  data: any;
};

type ErrorResponse = {
  success: false;
  error: string;
};

type ApiResponse = SuccessResponse | ErrorResponse;

// Type narrowing
function handleResponse(response: ApiResponse) {
  if (response.success) {
    console.log(response.data); // TS knows it's SuccessResponse
  } else {
    console.log(response.error); // TS knows it's ErrorResponse
  }
}

// Discriminated unions (tagged unions)
type Circle = {
  kind: "circle";
  radius: number;
};

type Square = {
  kind: "square";
  sideLength: number;
};

type Rectangle = {
  kind: "rectangle";
  width: number;
  height: number;
};

type Shape = Circle | Square | Rectangle;

function getArea(shape: Shape): number {
  switch (shape.kind) {
    case "circle":
      return Math.PI * shape.radius ** 2;
    case "square":
      return shape.sideLength ** 2;
    case "rectangle":
      return shape.width * shape.height;
  }
}

// Type guards
function isString(value: unknown): value is string {
  return typeof value === "string";
}

function processValue(value: string | number) {
  if (typeof value === "string") {
    return value.toUpperCase();
  } else {
    return value.toFixed(2);
  }
}
```

**Exercises:**
1. Create a type `UserRole` with literal types: "admin" | "user" | "guest"
2. Create types for HTTP methods: "GET" | "POST" | "PUT" | "DELETE"
3. Create a `Result<T>` type that's either `{ ok: true, value: T }` or `{ ok: false, error: string }`
4. Create types for different payment methods (CreditCard, PayPal, BankTransfer) using discriminated unions
5. Write a type guard function `isValidEmail(value: unknown): value is string`

**Interface vs Type - When to use what:**
```typescript
// Use INTERFACE when:
// - Defining object shapes
// - You might extend it later
// - Working with classes

// Use TYPE when:
// - Union types
// - Intersection types
// - Mapped types
// - Function types
// - Anything that's not an object
```

**Post-Session Recall:**
1. What's a union type?
2. What's an intersection type?
3. What are literal types?
4. Explain type narrowing.

**Commit:** `Day 38: TypeScript fundamentals - types and interfaces`

---

### Sunday, Feb 8 - Day 39
**Topic:** TypeScript Fundamentals Day 2
**Sessions:** 4

#### Session 1: Generics Basics (50 min)
**Pre-Session Questions:**
1. What problem do generics solve?
2. What does `<T>` mean?

**Core Topics:**
- Generic functions
- Generic constraints
- Multiple type parameters
- Generic interfaces/types

**Create src/generics.ts:**
```typescript
// Generic function
function identity<T>(value: T): T {
  return value;
}

const str = identity<string>("hello"); // T is string
const num = identity<number>(42); // T is number
const auto = identity("auto"); // T inferred as string

// Generic with arrays
function getFirst<T>(array: T[]): T | undefined {
  return array[0];
}

const firstNumber = getFirst([1, 2, 3]); // number | undefined
const firstName = getFirst(["a", "b"]); // string | undefined

// Multiple type parameters
function pair<T, U>(first: T, second: U): [T, U] {
  return [first, second];
}

const numberAndString = pair(42, "hello"); // [number, string]
const boolAndObject = pair(true, { key: "value" }); // [boolean, object]

// Generic with constraints
interface HasLength {
  length: number;
}

function logLength<T extends HasLength>(item: T): void {
  console.log(item.length);
}

logLength("hello"); // OK - string has length
logLength([1, 2, 3]); // OK - array has length
logLength({ length: 10 }); // OK - object has length
// logLength(42); // Error! number doesn't have length

// Generic interface
interface Box<T> {
  value: T;
}

const stringBox: Box<string> = { value: "hello" };
const numberBox: Box<number> = { value: 42 };

// Generic type
type Result<T> = {
  success: boolean;
  data?: T;
  error?: string;
};

const userResult: Result<User> = {
  success: true,
  data: { id: 1, name: "Sebastian" }
};

// Generic class
class DataStore<T> {
  private data: T[] = [];

  add(item: T): void {
    this.data.push(item);
  }

  getAll(): T[] {
    return [...this.data];
  }

  find(predicate: (item: T) => boolean): T | undefined {
    return this.data.find(predicate);
  }
}

const numberStore = new DataStore<number>();
numberStore.add(1);
numberStore.add(2);

const userStore = new DataStore<User>();
userStore.add({ id: 1, name: "John" });

// Generic constraints with keyof
function getProperty<T, K extends keyof T>(obj: T, key: K): T[K] {
  return obj[key];
}

const user = { id: 1, name: "Sebastian", age: 25 };
const userName = getProperty(user, "name"); // string
const userAge = getProperty(user, "age"); // number
// getProperty(user, "invalid"); // Error!
```

**Exercises:**
1. Create a generic `wrapInArray<T>(value: T): T[]` function
2. Create a generic `findByProperty<T, K extends keyof T>(array: T[], key: K, value: T[K]): T | undefined`
3. Create a generic `Result<T, E>` type with success/error variants
4. Create a generic `AsyncResult<T>` that wraps `Promise<Result<T>>`
5. Create a generic `Pair<T>` class that holds two values of the same type

**Hints:**
- Hint 1: Wrap with array literal: [value]
- Hint 2: Use array.find() with comparison
- Hint 3: Two type parameters for Result
- Hint 4: Combine Promise<...> with Result<T>

**Post-Session Recall:**
1. What does `<T>` represent?
2. How do you constrain a generic type?
3. What does `keyof T` do?

---

#### Session 2: Utility Types (50 min)
**Pre-Session Questions:**
1. What are utility types?
2. Name 3 built-in TypeScript utility types.

**Core Topics:**
- `Partial<T>`
- `Required<T>`
- `Readonly<T>`
- `Pick<T, K>`
- `Omit<T, K>`
- `Record<K, T>`
- `ReturnType<T>`
- `Parameters<T>`

**Create src/utility-types.ts:**
```typescript
interface User {
  id: number;
  name: string;
  email: string;
  age: number;
  password: string;
}

// Partial - makes all properties optional
type PartialUser = Partial<User>;
const updateData: PartialUser = {
  name: "New Name"
  // Other fields are optional
};

// Required - makes all properties required
interface OptionalUser {
  id?: number;
  name?: string;
}
type RequiredUser = Required<OptionalUser>;
// Now id and name are required

// Readonly - makes all properties readonly
type ReadonlyUser = Readonly<User>;
const user: ReadonlyUser = {
  id: 1,
  name: "John",
  email: "john@example.com",
  age: 25,
  password: "secret"
};
// user.name = "Jane"; // Error!

// Pick - select specific properties
type UserPreview = Pick<User, "id" | "name" | "email">;
// Has only: id, name, email

// Omit - exclude specific properties
type UserWithoutPassword = Omit<User, "password">;
// Has all except password

type PublicUser = Omit<User, "password" | "email">;
// Has only: id, name, age

// Record - create object type with specific keys and value type
type UserRoles = Record<string, string[]>;
const roles: UserRoles = {
  admin: ["read", "write", "delete"],
  user: ["read"],
  guest: []
};

type HttpStatusCodes = Record<number, string>;
const statusMessages: HttpStatusCodes = {
  200: "OK",
  404: "Not Found",
  500: "Internal Server Error"
};

// ReturnType - extract return type of function
function getUser() {
  return { id: 1, name: "John", email: "john@example.com" };
}
type UserType = ReturnType<typeof getUser>;
// Same as: { id: number; name: string; email: string }

// Parameters - extract parameter types
function createUser(name: string, age: number, email: string) {
  return { name, age, email };
}
type CreateUserParams = Parameters<typeof createUser>;
// [string, number, string]

// Awaited - unwrap Promise type
type AsyncUser = Promise<User>;
type UnwrappedUser = Awaited<AsyncUser>;
// Same as User

// NonNullable - remove null and undefined
type MaybeString = string | null | undefined;
type DefinitelyString = NonNullable<MaybeString>;
// string

// Combining utility types
type UserDTO = Omit<User, "password" | "id"> & {
  confirmPassword: string;
};

type UpdateUserDTO = Partial<Omit<User, "id" | "password">>;
```

**Exercises:**
1. Create a `CreatePostDTO` that omits `id`, `createdAt`, `updatedAt` from Post
2. Create a `PartialUpdate<T>` generic that makes all properties optional except `id`
3. Create `Config` object using Record with keys: "apiUrl", "timeout", "retries" (all strings)
4. Extract the return type of: `async function fetchUsers() { return [{ id: 1, name: "John" }]; }`
5. Create a type that represents all keys of User as strings: "id" | "name" | "email" ...

**Hints:**
- Hint 1: Use Omit<Post, "id" | "createdAt" | "updatedAt">
- Hint 2: Combine Partial and Required
- Hint 3: Record<"key1" | "key2", string>
- Hint 4: Use ReturnType<typeof fn> then Awaited
- Hint 5: Use keyof User

**Post-Session Recall:**
1. What does Partial do?
2. What's the difference between Pick and Omit?
3. When would you use Record?

---

#### Session 3: TypeScript with Node.js (50 min)
**Pre-Session Questions:**
1. How do you set up TypeScript with Node.js?
2. What is the `@types` scope in npm?

**Setup TypeScript Node Project:**
```bash
mkdir ts-node-app && cd ts-node-app
npm init -y
npm install -D typescript ts-node @types/node nodemon
npx tsc --init
```

**Configure tsconfig.json:**
```json
{
  "compilerOptions": {
    "target": "ES2020",
    "module": "commonjs",
    "lib": ["ES2020"],
    "outDir": "./dist",
    "rootDir": "./src",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "resolveJsonModule": true,
    "moduleResolution": "node"
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules", "dist"]
}
```

**Configure package.json scripts:**
```json
{
  "scripts": {
    "build": "tsc",
    "start": "node dist/index.js",
    "dev": "nodemon --exec ts-node src/index.ts",
    "type-check": "tsc --noEmit"
  }
}
```

**Create src/index.ts:**
```typescript
import fs from 'fs/promises';
import path from 'path';

interface Config {
  port: number;
  host: string;
  databaseUrl: string;
}

async function loadConfig(): Promise<Config> {
  try {
    const configPath = path.join(__dirname, '..', 'config.json');
    const data = await fs.readFile(configPath, 'utf-8');
    return JSON.parse(data);
  } catch (error) {
    console.error('Failed to load config:', error);
    process.exit(1);
  }
}

interface User {
  id: number;
  name: string;
  email: string;
}

class UserService {
  private users: User[] = [];

  addUser(user: Omit<User, 'id'>): User {
    const newUser: User = {
      id: this.users.length + 1,
      ...user
    };
    this.users.push(newUser);
    return newUser;
  }

  getUsers(): readonly User[] {
    return Object.freeze([...this.users]);
  }

  getUserById(id: number): User | undefined {
    return this.users.find(u => u.id === id);
  }
}

async function main() {
  const config = await loadConfig();
  console.log(`Starting server on ${config.host}:${config.port}`);

  const userService = new UserService();
  userService.addUser({ name: 'John', email: 'john@example.com' });
  
  console.log('Users:', userService.getUsers());
}

main();
```

**Exercises:**
1. Add error handling types (create Error classes)
2. Create a Logger class with different log levels (typed)
3. Create a file-based data store with generic type
4. Add environment variable typing (process.env)
5. Create a CLI tool that takes typed arguments

**Post-Session Recall:**
1. What does `@types/node` provide?
2. What's the purpose of `outDir` in tsconfig?
3. Why use `ts-node` in development?

---

#### Session 4: TypeScript with Express (50 min)
**Pre-Session Questions:**
1. How do you type Express request/response?
2. What types does `@types/express` provide?

**Setup:**
```bash
npm install express
npm install -D @types/express
```

**Create src/app.ts:**
```typescript
import express, { Request, Response, NextFunction } from 'express';

const app = express();
app.use(express.json());

// Basic types
interface User {
  id: number;
  name: string;
  email: string;
}

let users: User[] = [];

// Type route handlers
app.get('/users', (req: Request, res: Response) => {
  res.json(users);
});

// Type request body
interface CreateUserBody {
  name: string;
  email: string;
}

app.post('/users', (req: Request<{}, {}, CreateUserBody>, res: Response) => {
  const { name, email } = req.body;
  
  const newUser: User = {
    id: users.length + 1,
    name,
    email
  };
  
  users.push(newUser);
  res.status(201).json(newUser);
});

// Type route parameters
interface UserParams {
  id: string;
}

app.get('/users/:id', (req: Request<UserParams>, res: Response) => {
  const id = parseInt(req.params.id);
  const user = users.find(u => u.id === id);
  
  if (!user) {
    return res.status(404).json({ error: 'User not found' });
  }
  
  res.json(user);
});

// Type query parameters
interface UserQuery {
  name?: string;
  limit?: string;
}

app.get('/search', (req: Request<{}, {}, {}, UserQuery>, res: Response) => {
  const { name, limit } = req.query;
  let result = users;
  
  if (name) {
    result = result.filter(u => u.name.toLowerCase().includes(name.toLowerCase()));
  }
  
  if (limit) {
    result = result.slice(0, parseInt(limit));
  }
  
  res.json(result);
});

// Type middleware
interface AuthRequest extends Request {
  userId?: number;
}

const authMiddleware = (req: AuthRequest, res: Response, next: NextFunction) => {
  const token = req.headers.authorization;
  
  if (!token) {
    return res.status(401).json({ error: 'No token provided' });
  }
  
  // Fake auth - just set userId
  req.userId = 1;
  next();
};

app.get('/profile', authMiddleware, (req: AuthRequest, res: Response) => {
  const user = users.find(u => u.id === req.userId);
  res.json(user);
});

// Error handler
interface ErrorResponse {
  error: string;
  status: number;
}

app.use((err: Error, req: Request, res: Response, next: NextFunction) => {
  console.error(err.stack);
  const response: ErrorResponse = {
    error: err.message,
    status: 500
  };
  res.status(500).json(response);
});

const PORT = process.env.PORT || 3000;
app.listen(PORT, () => {
  console.log(`Server running on port ${PORT}`);
});
```

**Exercises:**
1. Add update user endpoint with proper types
2. Add delete user endpoint
3. Create custom error classes (NotFoundError, ValidationError)
4. Add request validation middleware (typed)
5. Create API response wrapper type

**Post-Session Recall:**
1. How do you type Express request body?
2. How do you type route parameters?
3. How do you extend the Request type?

**Commit:** `Day 39: TypeScript with Node.js and Express`

---

### Monday, Feb 9 - Day 40
**Topic:** Convert Task API to TypeScript
**Sessions:** 2

#### Session 1: Setup & Basic Conversion (50 min)
**Take your Task API from Phase 1 and convert it to TypeScript**

**Tasks:**
1. Add TypeScript dependencies
2. Create tsconfig.json
3. Rename .js files to .ts
4. Add types for Task model
5. Fix all type errors

**Create src/types.ts:**
```typescript
export interface Task {
  id: number;
  title: string;
  description?: string;
  completed: boolean;
  priority: 'low' | 'medium' | 'high';
  createdAt: Date;
  updatedAt: Date;
}

export interface CreateTaskDTO {
  title: string;
  description?: string;
  priority?: 'low' | 'medium' | 'high';
}

export interface UpdateTaskDTO {
  title?: string;
  description?: string;
  completed?: boolean;
  priority?: 'low' | 'medium' | 'high';
}

export interface TaskQuery {
  completed?: string;
  priority?: string;
  search?: string;
}
```

---

#### Session 2: Complete Conversion (50 min)
**Tasks:**
1. Type all route handlers
2. Type middleware functions
3. Add proper error types
4. Test everything works
5. Push to GitHub

**Commit:** `Day 40: Task API fully typed with TypeScript`

---

### Tuesday, Feb 10 - Day 41
**Topic:** TypeScript Advanced Concepts
**Sessions:** 2

#### Session 1: Mapped Types & Conditional Types (50 min)
**Pre-Session Questions:**
1. What is a mapped type?
2. What is a conditional type?

**Create src/advanced.ts:**
```typescript
// Mapped types
type ReadonlyProps<T> = {
  readonly [K in keyof T]: T[K];
};

interface User {
  id: number;
  name: string;
}

type ReadonlyUser = ReadonlyProps<User>;
// All properties are readonly

// Make all properties optional
type Optional<T> = {
  [K in keyof T]?: T[K];
};

// Make all properties nullable
type Nullable<T> = {
  [K in keyof T]: T[K] | null;
};

// Conditional types
type IsString<T> = T extends string ? true : false;
type A = IsString<string>; // true
type B = IsString<number>; // false

// More practical conditional type
type NonNullableProps<T> = {
  [K in keyof T]: NonNullable<T[K]>;
};

// Infer keyword
type GetReturnType<T> = T extends (...args: any[]) => infer R ? R : never;

function getUser() {
  return { id: 1, name: 'John' };
}

type UserReturn = GetReturnType<typeof getUser>;
// { id: number; name: string }
```

**Exercises:**
1. Create a mapped type that makes all properties required
2. Create a conditional type that extracts array element type
3. Create a type that converts all string properties to numbers
4. Create a DeepReadonly type (recursive)
5. Create a DeepPartial type (recursive)

---

#### Session 2: Practice & Review (50 min)
**Review everything learned about TypeScript**

**Quiz yourself:**
1. Explain generics
2. When to use interface vs type?
3. What are utility types?
4. How do you type Express routes?
5. What's type narrowing?

**Commit:** `Day 41: TypeScript advanced concepts`

---

### Wednesday, Feb 11 - Day 42
**Topic:** PostgreSQL with Docker
**Sessions:** 2

#### Session 1: Docker PostgreSQL Setup (50 min)
**Pre-Session Questions:**
1. What is Docker?
2. Why use Docker for databases?

**Setup:**
```bash
# Pull PostgreSQL image
docker pull postgres:15

# Run PostgreSQL container
docker run --name dev-postgres \
  -e POSTGRES_PASSWORD=password \
  -e POSTGRES_USER=postgres \
  -e POSTGRES_DB=devdb \
  -p 5432:5432 \
  -d postgres:15

# Check it's running
docker ps

# Connect with psql
docker exec -it dev-postgres psql -U postgres -d devdb
```

**Basic SQL Practice:**
```sql
-- Create users table
CREATE TABLE users (
  id SERIAL PRIMARY KEY,
  name VARCHAR(100) NOT NULL,
  email VARCHAR(255) UNIQUE NOT NULL,
  age INTEGER CHECK (age >= 0),
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Insert data
INSERT INTO users (name, email, age) VALUES 
  ('John Doe', 'john@example.com', 30),
  ('Jane Smith', 'jane@example.com', 25);

-- Query
SELECT * FROM users;
SELECT * FROM users WHERE age > 25;
SELECT * FROM users ORDER BY created_at DESC;

-- Update
UPDATE users SET age = 31 WHERE email = 'john@example.com';

-- Delete
DELETE FROM users WHERE id = 2;
```

**Exercises:**
1. Create a `posts` table with foreign key to users
2. Insert 5 users and 10 posts
3. Query all posts with user information (JOIN)
4. Find all users who have posts
5. Delete a user and see what happens to posts

---

#### Session 2: PostgreSQL Relationships (50 min)
**Practice foreign keys, JOINs, and relationships**

```sql
-- One-to-many: users and posts
CREATE TABLE posts (
  id SERIAL PRIMARY KEY,
  title VARCHAR(255) NOT NULL,
  content TEXT,
  user_id INTEGER REFERENCES users(id) ON DELETE CASCADE,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Many-to-many: posts and tags
CREATE TABLE tags (
  id SERIAL PRIMARY KEY,
  name VARCHAR(50) UNIQUE NOT NULL
);

CREATE TABLE post_tags (
  post_id INTEGER REFERENCES posts(id) ON DELETE CASCADE,
  tag_id INTEGER REFERENCES tags(id) ON DELETE CASCADE,
  PRIMARY KEY (post_id, tag_id)
);

-- Queries
SELECT p.title, u.name as author
FROM posts p
INNER JOIN users u ON p.user_id = u.id;

SELECT p.title, array_agg(t.name) as tags
FROM posts p
LEFT JOIN post_tags pt ON p.id = pt.post_id
LEFT JOIN tags t ON pt.tag_id = t.id
GROUP BY p.id, p.title;
```

**Commit:** `Day 42: PostgreSQL fundamentals`

---

### Thursday, Feb 12 - Day 43
**Topic:** Prisma ORM Setup
**Sessions:** 2

#### Session 1: Prisma Basics (50 min)
**Pre-Session Questions:**
1. What is an ORM?
2. Why use Prisma over raw SQL?

**Setup:**
```bash
mkdir prisma-project && cd prisma-project
npm init -y
npm install prisma @prisma/client
npm install -D typescript ts-node @types/node
npx prisma init
```

**Edit .env:**
```
DATABASE_URL="postgresql://postgres:password@localhost:5432/devdb"
```

**Edit prisma/schema.prisma:**
```prisma
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id        Int      @id @default(autoincrement())
  email     String   @unique
  name      String
  age       Int?
  posts     Post[]
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Post {
  id        Int      @id @default(autoincrement())
  title     String
  content   String?
  published Boolean  @default(false)
  author    User     @relation(fields: [authorId], references: [id])
  authorId  Int
  tags      Tag[]    @relation("PostTags")
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Tag {
  id    Int    @id @default(autoincrement())
  name  String @unique
  posts Post[] @relation("PostTags")
}
```

**Run migration:**
```bash
npx prisma migrate dev --name init
npx prisma generate
```

---

#### Session 2: Prisma CRUD (50 min)
**Create src/index.ts:**
```typescript
import { PrismaClient } from '@prisma/client';

const prisma = new PrismaClient();

async function main() {
  // Create user
  const user = await prisma.user.create({
    data: {
      name: 'John Doe',
      email: 'john@example.com',
      age: 30
    }
  });
  console.log('Created user:', user);

  // Create user with posts
  const userWithPosts = await prisma.user.create({
    data: {
      name: 'Jane Smith',
      email: 'jane@example.com',
      posts: {
        create: [
          { title: 'First Post', content: 'Hello!' },
          { title: 'Second Post', content: 'World!' }
        ]
      }
    },
    include: { posts: true }
  });
  console.log('User with posts:', userWithPosts);

  // Find all users with their posts
  const users = await prisma.user.findMany({
    include: { posts: true }
  });
  console.log('All users:', users);

  // Update
  const updated = await prisma.user.update({
    where: { id: 1 },
    data: { age: 31 }
  });

  // Delete
  await prisma.post.delete({
    where: { id: 1 }
  });
}

main()
  .catch(console.error)
  .finally(() => prisma.$disconnect());
```

**Exercises:**
1. Create complex queries with filtering
2. Implement pagination
3. Implement sorting
4. Add tags to posts (many-to-many)
5. Implement search functionality

**Commit:** `Day 43: Prisma ORM mastery`

---

### Friday, Feb 13 - Day 44
**Topic:** Blog API Project Start
**Sessions:** 2

#### Session 1: Project Setup (50 min)
**Start building a complete Blog API with TypeScript + Prisma**

**Structure:**
```
/blog-api
  prisma/
    schema.prisma
  src/
    types/
    middleware/
    routes/
    controllers/
    services/
    utils/
    index.ts
  .env
  tsconfig.json
  package.json
```

**Set up Prisma schema for blog:**
```prisma
model User {
  id        Int      @id @default(autoincrement())
  email     String   @unique
  password  String
  name      String
  posts     Post[]
  comments  Comment[]
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Post {
  id        Int       @id @default(autoincrement())
  title     String
  slug      String    @unique
  content   String
  excerpt   String?
  published Boolean   @default(false)
  author    User      @relation(fields: [authorId], references: [id])
  authorId  Int
  comments  Comment[]
  tags      Tag[]
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
}

model Comment {
  id        Int      @id @default(autoincrement())
  content   String
  author    User     @relation(fields: [authorId], references: [id])
  authorId  Int
  post      Post     @relation(fields: [postId], references: [id])
  postId    Int
  createdAt DateTime @default(now())
}

model Tag {
  id    Int    @id @default(autoincrement())
  name  String @unique
  posts Post[]
}
```

---

#### Session 2: Basic Routes Setup (50 min)
**Set up Express with TypeScript and create basic structure**

**Exercises:**
1. Set up Express with TypeScript
2. Create route structure
3. Set up error handling
4. Add request validation
5. Test with Postman/Thunder Client

**Commit:** `Day 44: Blog API project setup`

---

### Saturday, Feb 14 - Day 45
**Topic:** Blog API - User Routes
**Sessions:** 4

#### Sessions 1-4: Implement User CRUD (200 min)
**Implement complete user management:**

1. GET /api/users - List users
2. GET /api/users/:id - Get single user
3. POST /api/users - Create user
4. PUT /api/users/:id - Update user
5. DELETE /api/users/:id - Delete user

**Add:**
- Input validation
- Error handling
- TypeScript types for everything
- Password hashing (bcrypt)

**Commit:** `Day 45: Blog API user routes complete`

---

## ðŸŽ‰ PHASE 1 COMPLETE!

You've finished Phase 1 (45 days)! You now have:
- âœ… Strong JavaScript fundamentals
- âœ… TypeScript proficiency
- âœ… DOM manipulation skills
- âœ… Node.js & Express knowledge
- âœ… PostgreSQL & Prisma basics
- âœ… 4+ projects in portfolio
- âœ… Git/GitHub workflow

**Take a moment to celebrate! You've covered a TON of material. ðŸš€**

---

# PHASE 2: BACKEND MASTERY (CONTINUED)
## February 15 - March 28 (6 weeks, Days 46-87)

**Focus:** Authentication, Testing, Docker, NestJS, Advanced Backend Patterns

**What You'll Build:**
- Complete Blog API with auth
- NestJS applications
- Dockerized applications
- Testing pipelines

---

### Sunday, Feb 15 - Day 46
**Topic:** Blog API - Comment & Tag Routes
**Sessions:** 4

#### Session 1: Comment Routes (50 min)
**Pre-Session Questions:**
1. How do comments relate to posts and users?
2. What operations should comment routes support?

**Core Topics:**
- Comment CRUD routes
- Nested resource routing
- Validating relationships
- Error handling

**Resources:**
- Review Prisma relations from Day 44
- REST API best practices for nested resources

**Exercises:**
1. Create src/routes/comments.ts
2. Create src/controllers/commentController.ts
3. Implement POST /api/posts/:postId/comments (create comment on a post)
4. Implement GET /api/posts/:postId/comments (get all comments for a post)
5. Implement GET /api/comments/:id (get single comment)
6. Implement PUT /api/comments/:id (update comment)
7. Implement DELETE /api/comments/:id (delete comment)
8. Add validation: post must exist before creating comment
9. Add validation: comment content required (minimum 1 character)
10. Include author information when fetching comments
11. Type all route handlers
12. Test all endpoints

**Test Data:**
- Comment on Post 1: "Great post!", authorId=2
- Comment on Post 1: "Thanks for sharing", authorId=3
- Comment on Post 2: "Interesting read", authorId=1

**Hints:**
- Hint 1: Nested routes: `/posts/:postId/comments`
- Hint 2: Check post exists: `prisma.post.findUnique`
- Hint 3: Include author: `include: { author: { select: { name: true, email: true } } }`
- Hint 4: Return 404 if post not found

**Post-Session Recall:**
1. Why use nested routes for comments?
2. How do you validate related resources exist?
3. What fields should be included when returning comments?

---

#### Session 2: Tag Routes (50 min)
**Pre-Session Questions:**
1. What's the relationship between tags and posts?
2. How should tag filtering work?

**Core Topics:**
- Tag CRUD routes
- Many-to-many relationships
- Connecting/disconnecting tags
- Tag usage statistics

**Exercises:**
1. Create src/routes/tags.ts
2. Create src/controllers/tagController.ts
3. Implement GET /api/tags (all tags with post count)
4. Implement GET /api/tags/:id (single tag with posts)
5. Implement POST /api/tags (create new tag)
6. Implement PUT /api/tags/:id (update tag name)
7. Implement DELETE /api/tags/:id (only if no posts use it)
8. Add endpoint: POST /api/posts/:postId/tags/:tagId (connect tag to post)
9. Add endpoint: DELETE /api/posts/:postId/tags/:tagId (disconnect tag from post)
10. Prevent duplicate tag names
11. Type all handlers
12. Test all endpoints

**Test Data:**
- Tags: "javascript", "typescript", "tutorial", "advanced", "backend"
- Post 1 has tags: javascript, tutorial
- Post 2 has tags: typescript, advanced, backend

**Hints:**
- Hint 1: Count posts: `_count: { select: { posts: true } }`
- Hint 2: Connect: `prisma.post.update({ data: { tags: { connect: { id } } } })`
- Hint 3: Disconnect: use `disconnect` instead of `connect`
- Hint 4: Check if tag used before deleting

**Post-Session Recall:**
1. How do you connect/disconnect many-to-many relations in Prisma?
2. Why prevent deleting tags that are in use?
3. How do you count related records?

---

#### Session 3: API Testing with Thunder Client (50 min)
**Pre-Session Questions:**
1. How do you test an API systematically?
2. What edge cases should you test?

**Core Topics:**
- Comprehensive API testing
- Test collections
- Edge case testing
- Error scenario testing

**Exercises:**
1. Create Thunder Client collection "Blog API"
2. Add environment variables: baseUrl, userId, postId
3. Test all User routes (CRUD)
4. Test all Post routes (CRUD, filters, pagination)
5. Test all Comment routes
6. Test all Tag routes
7. Test edge cases: invalid IDs, missing fields, duplicate emails
8. Test error responses: 400, 404, 500
9. Test pagination: different page sizes, out of bounds
10. Test filters: published/unpublished posts, posts by author, posts by tag
11. Save all tests in collection
12. Document expected responses

**Test Scenarios:**
- Create user without email â†’ 400 error
- Get non-existent post â†’ 404 error
- Create post with non-existent author â†’ 404 error
- Pagination: page=1 limit=5, page=2 limit=5
- Filter: published=true, authorId=1, tag=javascript

**Hints:**
- Hint 1: Save IDs in environment after creation
- Hint 2: Test happy path first, then edge cases
- Hint 3: Document status codes and response format
- Hint 4: Test both success and failure scenarios

**Post-Session Recall:**
1. What HTTP status codes did you use?
2. What edge cases did you discover?
3. Are error messages helpful to users?

---

#### Session 4: API Documentation & Cleanup (50 min)
**Pre-Session Questions:**
1. Why is API documentation important?
2. What should good documentation include?

**Core Topics:**
- API documentation
- Code organization
- README updates
- Preparing for authentication

**Exercises:**
1. Create API.md in project root
2. Document all endpoints with: method, path, description, request body, response
3. Add example requests and responses
4. Document error codes and messages
5. Refactor any duplicate code
6. Extract validation logic to middleware
7. Extract error handling to utility functions
8. Update main README with: setup instructions, database setup, running the app
9. Add .env.example file
10. Clean up console.logs
11. Ensure consistent code formatting
12. Review TypeScript types for completeness

**Documentation Structure:**
- Overview
- Base URL
- Authentication (coming soon)
- Endpoints grouped by resource
- Request/Response examples
- Error codes
- Setup instructions

**Hints:**
- Hint 1: Use markdown tables for endpoints
- Hint 2: Show example JSON for body/response
- Hint 3: Include HTTP status codes
- Hint 4: Document query parameters

**Post-Session Recall:**
1. How complete is your documentation?
2. Can someone else use your API docs?
3. What needs improvement?

**Commit:** `Day 46: Blog API comments, tags, testing, documentation`

---

### Monday, Feb 16 - Day 47
**Topic:** Authentication Fundamentals
**Sessions:** 2

#### Session 1: Authentication Concepts (50 min)
**Pre-Session Questions:**
1. What is authentication?
2. What's the difference between authentication and authorization?

**Core Topics:**
- Authentication vs Authorization
- Password hashing (bcrypt)
- JSON Web Tokens (JWT)
- Session-based vs Token-based auth
- Secure authentication best practices

**Resources:**
- [JWT Introduction](https://jwt.io/introduction)
- [bcrypt explained](https://auth0.com/blog/hashing-in-action-understanding-bcrypt/)
- [Auth best practices](https://cheatsheetseries.owasp.org/cheatsheets/Authentication_Cheat_Sheet.html)

**Conceptual Exercises (Answer These):**
1. Explain authentication in one sentence
2. Explain authorization in one sentence
3. Why hash passwords instead of encrypting them?
4. What are the three parts of a JWT?
5. What information should be in a JWT payload?
6. What information should NOT be in a JWT payload?
7. Where should JWTs be stored on the client?
8. What's the difference between access token and refresh token?
9. What does "stateless authentication" mean?
10. What are common authentication vulnerabilities?

**Research Tasks:**
1. Read about bcrypt work factors
2. Learn about JWT signing algorithms (HS256 vs RS256)
3. Research token expiration strategies
4. Look up OWASP authentication guidelines
5. Watch a video on JWT authentication flow

**Hints:**
- Hint 1: Authentication = verifying identity, Authorization = verifying permissions
- Hint 2: Hashing is one-way, encryption is two-way
- Hint 3: JWT parts: header, payload, signature
- Hint 4: Never store sensitive data (passwords) in JWT

**Post-Session Recall:**
1. What is a JWT and how does it work?
2. Why use bcrypt instead of other hashing?
3. What's the difference between access and refresh tokens?

---

#### Session 2: JWT & bcrypt Practice (50 min)
**Pre-Session Questions:**
1. How do you hash a password with bcrypt?
2. How do you create a JWT?

**Core Topics:**
- bcrypt API usage
- jsonwebtoken library
- Signing and verifying JWTs
- Password comparison
- Environment variables for secrets

**Resources:**
- [bcrypt npm](https://www.npmjs.com/package/bcrypt)
- [jsonwebtoken npm](https://www.npmjs.com/package/jsonwebtoken)

**Exercises:**
1. Create new folder `auth-practice`
2. Initialize Node + TypeScript
3. Install: bcrypt, @types/bcrypt, jsonwebtoken, @types/jsonwebtoken, dotenv
4. Create .env file with JWT_SECRET=your-secret-key
5. Create practice file to hash a password
6. Create practice file to compare password with hash
7. Create practice file to sign a JWT with payload: { userId: 1, email: "test@example.com" }
8. Set token expiration: 1 hour
9. Create practice file to verify and decode JWT
10. Try verifying with wrong secret - see error
11. Try verifying expired token - see error
12. Test different bcrypt salt rounds (10, 12, 14)

**Test Data:**
- Password: "MySecurePassword123!"
- Payload: { userId: 1, email: "test@example.com", role: "user" }
- Secret: "your-super-secret-key-change-this"

**Hints:**
- Hint 1: bcrypt.hash(password, saltRounds)
- Hint 2: bcrypt.compare(password, hash)
- Hint 3: jwt.sign(payload, secret, { expiresIn: '1h' })
- Hint 4: jwt.verify(token, secret)

**Post-Session Recall:**
1. What salt rounds should you use?
2. How do you set token expiration?
3. What happens when you verify with wrong secret?

**Commit:** `Day 47: Authentication fundamentals and practice`

---

### Tuesday, Feb 17 - Day 48
**Topic:** Blog API - Authentication Implementation
**Sessions:** 2

#### Session 1: Register & Login Routes (50 min)
**Pre-Session Questions:**
1. What should a register endpoint do?
2. What should a login endpoint return?

**Core Topics:**
- Register endpoint
- Login endpoint
- Password hashing on registration
- Password verification on login
- JWT generation on successful login
- Input validation

**Resources:**
- Your auth practice from Day 47
- Blog API project

**Exercises:**
1. Install bcrypt and jsonwebtoken in Blog API
2. Add JWT_SECRET to .env
3. Create src/routes/auth.ts
4. Create src/controllers/authController.ts
5. Implement POST /api/auth/register (email, password, name)
6. Hash password before storing user
7. Return user data (exclude password) and JWT
8. Implement POST /api/auth/login (email, password)
9. Find user by email
10. Compare password with stored hash
11. Return user data and JWT on success
12. Return 401 if credentials invalid
13. Type all handlers
14. Test with Thunder Client

**Validation Rules:**
- Email required and valid format
- Password minimum 8 characters
- Name required
- Email must be unique

**Hints:**
- Hint 1: Hash before create: `const hash = await bcrypt.hash(password, 10)`
- Hint 2: Compare: `const match = await bcrypt.compare(password, user.password)`
- Hint 3: Sign JWT: `jwt.sign({ userId: user.id }, JWT_SECRET, { expiresIn: '7d' })`
- Hint 4: Return 401 for invalid credentials

**Post-Session Recall:**
1. When should you hash passwords?
2. What data goes in the JWT?
3. What status code for invalid login?

---

#### Session 2: Auth Middleware & Protected Routes (50 min)
**Pre-Session Questions:**
1. How do you protect routes that require authentication?
2. Where is the JWT sent in requests?

**Core Topics:**
- Authentication middleware
- Bearer token format
- Extracting and verifying JWT
- Adding user to request object
- Protecting routes
- Authorization basics

**Resources:**
- Express middleware patterns
- HTTP Authorization header

**Exercises:**
1. Create src/middleware/auth.ts
2. Create authenticate middleware function
3. Extract token from Authorization header: "Bearer TOKEN"
4. Verify token with jwt.verify
5. Decode token to get userId
6. Fetch user from database
7. Attach user to req object (extend Request type)
8. Handle errors: missing token, invalid token, expired token
9. Apply middleware to protected routes
10. Modify post routes to use authenticated user as author
11. Allow only post authors to update/delete their posts
12. Test protected routes without token â†’ 401
13. Test protected routes with valid token â†’ success

**Extended Request Type:**
```typescript
// Add to types file
declare global {
  namespace Express {
    interface Request {
      user?: { id: number, email: string, name: string }
    }
  }
}
```

**Hints:**
- Hint 1: Get token: `req.headers.authorization?.split(' ')[1]`
- Hint 2: Verify: `jwt.verify(token, JWT_SECRET)`
- Hint 3: Middleware signature: `(req, res, next) => ...`
- Hint 4: Return 401 if token missing/invalid

**Post-Session Recall:**
1. Where is the JWT sent in requests?
2. How do you extend Express Request type?
3. What's the difference between authentication and authorization?

**Commit:** `Day 48: Blog API authentication complete`

---

### Wednesday, Feb 18 - Day 49
**Topic:** Authorization & Role-Based Access
**Sessions:** 2

#### Session 1: Role-Based Authorization (50 min)
**Pre-Session Questions:**
1. What's the difference between authentication and authorization?
2. What are user roles?

**Core Topics:**
- User roles (user, admin, moderator)
- Role-based access control (RBAC)
- Authorization middleware
- Protecting routes by role
- Permission checking

**Resources:**
- [RBAC explained](https://auth0.com/docs/manage-users/access-control/rbac)

**Exercises:**
1. Update User model in Prisma schema: add role field (enum: USER, ADMIN, MODERATOR)
2. Default role should be USER
3. Run migration
4. Create src/middleware/authorize.ts
5. Create authorize middleware that takes required roles: `authorize('ADMIN')`
6. Check if req.user has required role
7. Return 403 if user doesn't have permission
8. Protect admin routes: DELETE /api/users/:id (admin only)
9. Protect moderator routes: DELETE /api/comments/:id (moderator or author)
10. Allow users to only edit their own resources
11. Update register to set role as USER by default
12. Type all middleware
13. Test with different user roles

**Authorization Scenarios:**
- Regular user can create/edit their own posts
- Regular user CANNOT delete other users' posts
- Moderator can delete any comment
- Admin can delete any user

**Hints:**
- Hint 1: Enum in Prisma: `role Role @default(USER)`
- Hint 2: Middleware: `authorize(...roles: string[])`
- Hint 3: Check: `if (!roles.includes(req.user.role))`
- Hint 4: 403 = Forbidden (authenticated but not authorized)

**Post-Session Recall:**
1. What HTTP status for insufficient permissions?
2. How do you implement role-based authorization?
3. What's the difference between 401 and 403?

---

#### Session 2: Resource Ownership & Permissions (50 min)
**Pre-Session Questions:**
1. How do you ensure users can only edit their own resources?
2. What are resource permissions?

**Core Topics:**
- Resource ownership
- Permission checking helpers
- Combining authentication and authorization
- Fine-grained access control

**Exercises:**
1. Create src/utils/permissions.ts
2. Create helper: `canUpdatePost(user, post)` - check if user is author or admin
3. Create helper: `canDeletePost(user, post)` - check if user is author or admin
4. Create helper: `canUpdateComment(user, comment)` - check if author or moderator
5. Create helper: `canDeleteComment(user, comment)` - check if author or moderator
6. Apply permission checks in controllers before updates/deletes
7. Return 403 if user doesn't have permission
8. Update post controller to check ownership
9. Update comment controller to check ownership
10. Allow admins to bypass ownership checks
11. Test: user tries to edit another user's post â†’ 403
12. Test: admin can edit any post â†’ success
13. Test: moderator can delete any comment â†’ success

**Test Scenarios:**
- User A creates post, User B tries to edit â†’ 403
- User A creates post, User A edits â†’ success
- Admin edits any post â†’ success
- User A creates comment, Moderator deletes â†’ success

**Hints:**
- Hint 1: Check authorId: `post.authorId === user.id`
- Hint 2: Admin bypass: `user.role === 'ADMIN' || post.authorId === user.id`
- Hint 3: Return 403 early if check fails
- Hint 4: Fetch resource first, then check permissions

**Post-Session Recall:**
1. How do you check resource ownership?
2. When should admins bypass ownership checks?
3. What order: authenticate then authorize, or reverse?

**Commit:** `Day 49: Authorization and permissions complete`

---

### Thursday, Feb 19 - Day 50
**Topic:** Refresh Tokens & Token Management
**Sessions:** 2

#### Session 1: Refresh Token Implementation (50 min)
**Pre-Session Questions:**
1. Why use refresh tokens?
2. What's the difference between access and refresh tokens?

**Core Topics:**
- Access tokens (short-lived)
- Refresh tokens (long-lived)
- Token rotation
- Storing refresh tokens
- Refresh token endpoint

**Resources:**
- [Refresh Token pattern](https://auth0.com/blog/refresh-tokens-what-are-they-and-when-to-use-them/)

**Exercises:**
1. Update User model: add refreshToken field (nullable string)
2. Run migration
3. Update login to generate both access token (15min) and refresh token (7days)
4. Store refresh token in database
5. Return both tokens to client
6. Create POST /api/auth/refresh endpoint
7. Accept refresh token in request body
8. Verify refresh token
9. Check if token matches stored token in database
10. Generate new access token
11. Optionally rotate refresh token (generate new one)
12. Return new access token
13. Create POST /api/auth/logout endpoint to clear refresh token
14. Test token refresh flow

**Token Lifetimes:**
- Access token: 15 minutes
- Refresh token: 7 days

**Hints:**
- Hint 1: Store hash of refresh token, not plain text
- Hint 2: Verify against stored token: `user.refreshToken === providedToken`
- Hint 3: Clear token on logout: `user.refreshToken = null`
- Hint 4: Include token type in payload: `{ type: 'refresh' }`

**Post-Session Recall:**
1. Why short-lived access tokens?
2. Where should refresh tokens be stored?
3. What's token rotation?

---

#### Session 2: Token Security & Best Practices (50 min)
**Pre-Session Questions:**
1. What are common JWT vulnerabilities?
2. How should tokens be stored on the client?

**Core Topics:**
- Token storage (httpOnly cookies vs localStorage)
- XSS and CSRF protection
- Token blacklisting
- Security headers
- Rate limiting

**Resources:**
- [JWT security best practices](https://curity.io/resources/learn/jwt-best-practices/)
- [OWASP Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/JSON_Web_Token_for_Java_Cheat_Sheet.html)

**Research & Implementation:**
1. Research httpOnly cookies vs localStorage for token storage
2. Decide on storage strategy for your API
3. Install helmet for security headers
4. Add helmet middleware to Express app
5. Install express-rate-limit
6. Add rate limiting to auth endpoints (5 attempts per 15 minutes)
7. Add rate limiting to general API (100 requests per 15 minutes)
8. Research token blacklisting strategies
9. Consider implementing token versioning in user model
10. Document your security decisions in API.md
11. Update authentication documentation
12. Test rate limiting with multiple requests

**Security Checklist:**
- [ ] Passwords hashed with bcrypt (salt rounds >= 10)
- [ ] JWT secret stored in environment variable
- [ ] Short-lived access tokens
- [ ] Refresh tokens stored securely
- [ ] Rate limiting on auth endpoints
- [ ] Security headers with helmet
- [ ] HTTPS in production (document this)
- [ ] Input validation on all auth routes
- [ ] SQL injection protection (Prisma handles this)
- [ ] Error messages don't leak information

**Hints:**
- Hint 1: helmet: `app.use(helmet())`
- Hint 2: Rate limit: `rateLimit({ windowMs, max, message })`
- Hint 3: Apply rate limit to specific routes
- Hint 4: Document decisions for future reference

**Post-Session Recall:**
1. Why use httpOnly cookies?
2. What does helmet do?
3. Why rate limit auth endpoints?

**Commit:** `Day 50: Refresh tokens and security hardening`

---

### Friday, Feb 20 - Day 51
**Topic:** Testing Introduction - Jest Setup
**Sessions:** 2

#### Session 1: Testing Fundamentals & Jest Setup (50 min)
**Pre-Session Questions:**
1. What is unit testing?
2. Why write tests?

**Core Topics:**
- Testing pyramid (unit, integration, e2e)
- Jest testing framework
- Test structure (AAA: Arrange, Act, Assert)
- Test runners and assertions
- Mocking basics

**Resources:**
- [Jest Documentation](https://jestjs.io/docs/getting-started)
- [Testing best practices](https://testingjavascript.com/)

**Exercises:**
1. Create new folder `testing-practice`
2. Initialize Node + TypeScript
3. Install: jest, @types/jest, ts-jest
4. Run `npx ts-jest config:init`
5. Update package.json with test script: `"test": "jest"`
6. Create src/math.ts with functions: add, subtract, multiply, divide
7. Create src/math.test.ts
8. Write test: "adds two numbers correctly"
9. Write test: "subtracts two numbers correctly"
10. Write test: "divides throws error on divide by zero"
11. Run tests with `npm test`
12. See tests pass!

**Test Structure:**
```typescript
describe('Math functions', () => {
  test('adds two numbers', () => {
    // Arrange
    const a = 2, b = 3;
    // Act
    const result = add(a, b);
    // Assert
    expect(result).toBe(5);
  });
});
```

**Hints:**
- Hint 1: describe() groups related tests
- Hint 2: test() or it() defines individual test
- Hint 3: expect() for assertions
- Hint 4: toBe() for primitive equality

**Post-Session Recall:**
1. What's the AAA pattern?
2. What's the difference between toBe and toEqual?
3. What does describe do?

---

#### Session 2: Jest Matchers & Async Testing (50 min)
**Pre-Session Questions:**
1. How do you test async functions?
2. What are Jest matchers?

**Core Topics:**
- Common Jest matchers
- Testing async code
- Testing Promises
- Testing async/await
- Error testing

**Resources:**
- [Jest Matchers](https://jestjs.io/docs/expect)
- [Jest Async](https://jestjs.io/docs/asynchronous)

**Exercises:**
1. Create src/utils.ts with various functions
2. Test toBe, toEqual, toBeTruthy, toBeFalsy
3. Test toContain for arrays
4. Test toMatch for strings
5. Test toBeGreaterThan, toBeLessThan
6. Create async function: `fetchUser(id)` that returns Promise
7. Test async function with async/await
8. Test Promise rejection with rejects matcher
9. Create function that throws error
10. Test error throwing with toThrow matcher
11. Run all tests and ensure they pass

**Test Examples:**
- Test array contains value: `expect([1,2,3]).toContain(2)`
- Test string matches pattern: `expect('hello').toMatch(/ell/)`
- Test async: `await expect(fetchUser(1)).resolves.toHaveProperty('name')`
- Test error: `expect(() => divide(5, 0)).toThrow('Cannot divide by zero')`

**Hints:**
- Hint 1: Use async/await in tests: `test('name', async () => { ... })`
- Hint 2: resolves/rejects for Promises: `.resolves.toBe(value)`
- Hint 3: toThrow needs function wrapper: `() => functionThatThrows()`
- Hint 4: Use .not for negation: `.not.toBe(value)`

**Post-Session Recall:**
1. How do you test async functions?
2. What's the difference between resolves and rejects?
3. How do you test if function throws error?

**Commit:** `Day 51: Jest fundamentals and practice`

---

### Saturday, Feb 21 - Day 52
**Topic:** Unit Testing Blog API
**Sessions:** 4

#### Session 1: Testing Setup for Blog API (50 min)
**Pre-Session Questions:**
1. What parts of the Blog API should be tested?
2. What's the difference between unit and integration tests?

**Core Topics:**
- Setting up Jest in existing project
- Test database setup
- Mocking Prisma Client
- Testing utilities
- Test file structure

**Resources:**
- [Testing Prisma](https://www.prisma.io/docs/guides/testing)
- Your Blog API project

**Exercises:**
1. Install Jest in Blog API: jest, @types/jest, ts-jest
2. Initialize Jest config for TypeScript
3. Create jest.config.js with proper settings
4. Update package.json: add test script
5. Create tests folder structure: tests/(unit, integration, e2e)
6. Install @prisma/client for mocking: `npm i -D jest-mock-extended`
7. Create tests/mocks/prisma.ts for mocked Prisma Client
8. Create tests/setup.ts for test configuration
9. Update Jest config to use setup file
10. Create sample test file: tests/unit/utils.test.ts
11. Test a utility function
12. Run tests and verify setup works

**Jest Config:**
```typescript
module.exports = {
  preset: 'ts-jest',
  testEnvironment: 'node',
  setupFilesAfterEnv: ['<rootDir>/tests/setup.ts'],
  testMatch: ['**/__tests__/**/*.ts', '**/?(*.)+(spec|test).ts'],
};
```

**Hints:**
- Hint 1: Separate test database from development database
- Hint 2: Mock Prisma Client for unit tests
- Hint 3: Use actual database for integration tests
- Hint 4: Group tests by type (unit, integration)

**Post-Session Recall:**
1. Why mock Prisma Client?
2. What's the difference between unit and integration tests?
3. How do you configure Jest for TypeScript?

---

#### Session 2: Testing Utility Functions (50 min)
**Pre-Session Questions:**
1. What are pure functions?
2. Why are pure functions easy to test?

**Core Topics:**
- Testing utility functions
- Testing validation logic
- Testing transformation functions
- Test coverage

**Exercises:**
1. Create tests/unit/slugify.test.ts
2. Test slug generation function (if you have one)
3. Test cases: "Hello World" â†’ "hello-world"
4. Test edge cases: empty string, special characters, spaces
5. Create tests/unit/validation.test.ts
6. Test email validation function
7. Test password validation function
8. Test cases: valid emails, invalid emails, edge cases
9. Create tests for permission helpers from Day 49
10. Test canUpdatePost, canDeletePost, etc.
11. Test different user roles and scenarios
12. Run tests with coverage: `npm test -- --coverage`

**Test Cases for slug:**
- "Hello World" â†’ "hello-world"
- "TypeScript 101!" â†’ "typescript-101"
- "   spaces   " â†’ "spaces"
- "" â†’ throws error or returns default

**Hints:**
- Hint 1: Test happy path first
- Hint 2: Then test edge cases
- Hint 3: Test error conditions
- Hint 4: Use describe blocks to group related tests

**Post-Session Recall:**
1. What's test coverage?
2. Why test edge cases?
3. What makes a good test?

---

#### Session 3: Testing Controllers (50 min)
**Pre-Session Questions:**
1. How do you test Express controllers?
2. What should you mock?

**Core Topics:**
- Testing controllers
- Mocking request/response objects
- Mocking Prisma Client
- Testing error handling
- Testing success responses

**Resources:**
- [Testing Express](https://www.albertgao.xyz/2017/05/24/how-to-test-expressjs-with-jest-and-supertest/)

**Exercises:**
1. Install supertest and @types/supertest
2. Create tests/unit/controllers/userController.test.ts
3. Mock Prisma Client
4. Mock Express req, res, next objects
5. Test getUsers controller function
6. Test createUser controller function
7. Test success scenarios
8. Test error scenarios (user not found, validation errors)
9. Verify Prisma methods called with correct arguments
10. Verify response status codes
11. Verify response bodies
12. Run tests and ensure they pass

**Test Structure:**
```typescript
describe('UserController', () => {
  describe('getUsers', () => {
    it('should return all users', async () => {
      // Arrange: mock Prisma
      // Act: call controller
      // Assert: check response
    });
  });
});
```

**Hints:**
- Hint 1: Mock res.json: `res.json = jest.fn()`
- Hint 2: Mock Prisma: `prismaMock.user.findMany.mockResolvedValue([])`
- Hint 3: Check if functions called: `expect(res.json).toHaveBeenCalledWith(...)`
- Hint 4: Test both success and error paths

**Post-Session Recall:**
1. How do you mock Prisma Client?
2. How do you mock Express req/res?
3. What should controller tests verify?

---

#### Session 4: Testing Authentication (50 min)
**Pre-Session Questions:**
1. How do you test authentication logic?
2. What about JWT and bcrypt?

**Core Topics:**
- Testing auth controller
- Mocking bcrypt
- Mocking JWT
- Testing middleware
- Testing password hashing

**Exercises:**
1. Create tests/unit/controllers/authController.test.ts
2. Mock bcrypt.hash and bcrypt.compare
3. Mock jwt.sign and jwt.verify
4. Test register function: password hashing, user creation, JWT generation
5. Test login function: email lookup, password comparison, JWT generation
6. Test login failure: wrong email, wrong password
7. Create tests/unit/middleware/auth.test.ts
8. Test authenticate middleware: valid token, invalid token, missing token
9. Test authorize middleware: correct role, wrong role
10. Verify user attached to request
11. Verify 401/403 responses
12. Run all tests

**Test Scenarios:**
- Register with valid data â†’ success
- Register with duplicate email â†’ error
- Login with correct credentials â†’ success, returns JWT
- Login with wrong password â†’ 401
- Protected route without token â†’ 401
- Protected route with valid token â†’ success
- Protected route with expired token â†’ 401

**Hints:**
- Hint 1: Mock bcrypt: `jest.mock('bcrypt')`
- Hint 2: Mock jwt: `jest.mock('jsonwebtoken')`
- Hint 3: Cast mocks: `(bcrypt.hash as jest.Mock).mockResolvedValue('hashedPassword')`
- Hint 4: Test middleware by calling it with mock req/res/next

**Post-Session Recall:**
1. Why mock bcrypt and jwt in tests?
2. How do you test Express middleware?
3. What edge cases did you test?

**Commit:** `Day 52: Unit tests for Blog API`

---

### Sunday, Feb 22 - Day 53
**Topic:** Integration Testing
**Sessions:** 4

#### Session 1: Integration Testing Setup (50 min)
**Pre-Session Questions:**
1. What's the difference between unit and integration tests?
2. Why use a test database?

**Core Topics:**
- Integration testing concepts
- Test database setup
- Database seeding for tests
- Supertest for API testing
- Test lifecycle (beforeAll, afterAll)

**Resources:**
- [Supertest docs](https://github.com/ladjs/supertest)
- [Testing with databases](https://www.prisma.io/docs/guides/testing/integration-testing)

**Exercises:**
1. Create separate test database
2. Add TEST_DATABASE_URL to .env.test
3. Update Prisma schema to use env variable
4. Create tests/integration/setup.ts
5. Create helper to reset database before tests
6. Create helper to seed test data
7. Install supertest
8. Create tests/integration/auth.test.ts
9. Set up beforeAll to seed database
10. Set up afterAll to cleanup
11. Create first integration test: POST /api/auth/register
12. Run test against actual database

**Test Database Workflow:**
1. beforeAll: Connect, migrate, seed
2. Run tests
3. afterAll: Cleanup, disconnect

**Hints:**
- Hint 1: Use separate database for tests
- Hint 2: Reset database before each test suite
- Hint 3: Seed consistent test data
- Hint 4: Use supertest to make actual HTTP requests

**Post-Session Recall:**
1. Why separate test database?
2. What's seeding?
3. What does supertest do?

---

#### Session 2: Testing Auth Endpoints (50 min)
**Pre-Session Questions:**
1. What should integration tests verify?
2. How do you test protected endpoints?

**Core Topics:**
- Testing registration flow
- Testing login flow
- Testing token refresh
- Testing protected endpoints
- Verifying database state

**Exercises:**
1. Test POST /api/auth/register
   - Send valid registration data
   - Verify 201 status
   - Verify response contains user and token
   - Verify user exists in database
   - Verify password is hashed in database
2. Test POST /api/auth/login
   - Create user first
   - Send correct credentials
   - Verify 200 status
   - Verify response contains user and token
3. Test login with wrong password â†’ 401
4. Test login with non-existent email â†’ 401
5. Test GET /api/users (protected route)
   - Without token â†’ 401
   - With valid token â†’ 200
6. Test token in Authorization header: "Bearer TOKEN"
7. Verify database state after operations

**Test Example:**
```typescript
describe('POST /api/auth/register', () => {
  it('should register new user', async () => {
    const response = await request(app)
      .post('/api/auth/register')
      .send({ email: 'test@example.com', password: 'password123', name: 'Test' });
    
    expect(response.status).toBe(201);
    expect(response.body).toHaveProperty('token');
    // Verify in database
    const user = await prisma.user.findUnique({ where: { email: 'test@example.com' } });
    expect(user).toBeTruthy();
  });
});
```

**Hints:**
- Hint 1: Use supertest: `request(app).post('/path').send(data)`
- Hint 2: Set headers: `.set('Authorization', `Bearer ${token}`)`
- Hint 3: Verify database: query after operation
- Hint 4: Clean up test data between tests

**Post-Session Recall:**
1. How do you test protected routes?
2. Why verify database state?
3. What's the difference between unit and integration tests?

---

#### Session 3: Testing CRUD Endpoints (50 min)
**Pre-Session Questions:**
1. How do you test full CRUD flow?
2. What edge cases should be tested?

**Core Topics:**
- Testing create operations
- Testing read operations
- Testing update operations
- Testing delete operations
- Testing filters and pagination

**Exercises:**
1. Create tests/integration/posts.test.ts
2. Create authenticated user for tests
3. Test POST /api/posts (create post)
   - With valid data â†’ 201
   - Without auth â†’ 401
   - With invalid data â†’ 400
4. Test GET /api/posts (list posts)
   - Verify pagination works
   - Verify filters work (published, authorId)
   - Verify response structure
5. Test GET /api/posts/:slug (single post)
   - Existing post â†’ 200
   - Non-existent post â†’ 404
6. Test PUT /api/posts/:id (update)
   - By author â†’ 200
   - By non-author â†’ 403
   - Non-existent post â†’ 404
7. Test DELETE /api/posts/:id (delete)
   - By author â†’ 200
   - By non-author â†’ 403
8. Verify database state after each operation

**Test Data:**
- User 1: test1@example.com (author)
- User 2: test2@example.com (non-author)
- Post 1: belongs to User 1
- Post 2: belongs to User 2

**Hints:**
- Hint 1: Create test users in beforeAll
- Hint 2: Get JWT for authenticated requests
- Hint 3: Test both success and failure cases
- Hint 4: Verify actual database changes

**Post-Session Recall:**
1. How do you test authorization in integration tests?
2. What edge cases did you discover?
3. Why test database state?

---

#### Session 4: Testing Relationships & Edge Cases (50 min)
**Pre-Session Questions:**
1. What edge cases are important to test?
2. How do you test cascading deletes?

**Core Topics:**
- Testing relationships
- Testing edge cases
- Testing error scenarios
- Testing data consistency
- Test coverage analysis

**Exercises:**
1. Test creating post with comments
2. Test deleting post cascades to comments
3. Test many-to-many: posts and tags
4. Test edge cases:
   - Empty request body â†’ 400
   - Invalid IDs â†’ 404
   - SQL injection attempts (Prisma protects)
   - Very long strings â†’ validation error
   - Negative pagination values â†’ error
5. Test concurrent requests
6. Test rate limiting
7. Run full test suite: `npm test`
8. Check test coverage: `npm test -- --coverage`
9. Identify untested code
10. Add tests to reach >80% coverage

**Edge Cases Checklist:**
- [ ] Invalid input data
- [ ] Missing required fields
- [ ] Non-existent resources (404)
- [ ] Unauthorized access (401)
- [ ] Forbidden access (403)
- [ ] Duplicate data (409)
- [ ] Pagination edge cases
- [ ] Empty result sets
- [ ] Large datasets
- [ ] Special characters in input

**Hints:**
- Hint 1: Test one edge case at a time
- Hint 2: Use describe blocks to organize tests
- Hint 3: Coverage goal: >80% is good
- Hint 4: Focus on critical paths first

**Post-Session Recall:**
1. What's good test coverage?
2. What edge cases are most important?
3. How do you organize integration tests?

**Commit:** `Day 53: Integration tests for Blog API`

---

### Monday, Feb 23 - Day 54
**Topic:** Docker Introduction
**Sessions:** 2

#### Session 1: Docker Fundamentals (50 min)
**Pre-Session Questions:**
1. What is Docker?
2. What problem does Docker solve?

**Core Topics:**
- What Docker is (containerization)
- Images vs Containers
- Dockerfile basics
- Docker commands
- Benefits of containers

**Resources:**
- [Docker Get Started](https://docs.docker.com/get-started/)
- [Docker for Beginners](https://docker-curriculum.com/)

**Conceptual Learning:**
1. What is a container?
2. What is an image?
3. How is Docker different from a VM?
4. What is a Dockerfile?
5. What is Docker Hub?
6. What are Docker layers?
7. What is docker-compose?

**Practical Exercises:**
1. Verify Docker installed: `docker --version`
2. Run hello-world: `docker run hello-world`
3. List images: `docker images`
4. List containers: `docker ps -a`
5. Run nginx: `docker run -d -p 8080:80 nginx`
6. Visit http://localhost:8080
7. Stop container: `docker stop <container-id>`
8. Remove container: `docker rm <container-id>`
9. Pull image: `docker pull node:18-alpine`
10. Explore Docker Hub website

**Hints:**
- Hint 1: Images are templates, containers are running instances
- Hint 2: -d runs in background (detached)
- Hint 3: -p maps ports: host:container
- Hint 4: Use container ID or name

**Post-Session Recall:**
1. What's the difference between image and container?
2. What does docker run do?
3. How do you expose ports?

---

#### Session 2: Creating Your First Dockerfile (50 min)
**Pre-Session Questions:**
1. What goes in a Dockerfile?
2. What's a base image?

**Core Topics:**
- Dockerfile syntax
- Base images
- Building images
- Running containers from custom images
- Environment variables

**Resources:**
- [Dockerfile reference](https://docs.docker.com/engine/reference/builder/)
- [Best practices](https://docs.docker.com/develop/develop-images/dockerfile_best-practices/)

**Exercises:**
1. Create new folder `docker-node-app`
2. Create simple Node.js app: express server on port 3000
3. Create Dockerfile:
   - FROM node:18-alpine
   - WORKDIR /app
   - COPY package*.json ./
   - RUN npm install
   - COPY . .
   - EXPOSE 3000
   - CMD ["node", "index.js"]
4. Create .dockerignore (node_modules, .git)
5. Build image: `docker build -t my-node-app .`
6. Run container: `docker run -p 3000:3000 my-node-app`
7. Test app: visit http://localhost:3000
8. View logs: `docker logs <container-id>`
9. Stop and remove container
10. Rebuild with changes

**Dockerfile Instructions:**
- FROM: base image
- WORKDIR: working directory
- COPY: copy files
- RUN: execute commands during build
- EXPOSE: document port
- CMD: command to run container

**Hints:**
- Hint 1: Order matters for layer caching
- Hint 2: Copy package.json before code
- Hint 3: .dockerignore prevents copying unwanted files
- Hint 4: Use alpine images for smaller size

**Post-Session Recall:**
1. What's the difference between RUN and CMD?
2. Why copy package.json separately?
3. What does .dockerignore do?

**Commit:** `Day 54: Docker fundamentals and first Dockerfile`

---

### Tuesday, Feb 24 - Day 55
**Topic:** Dockerizing Blog API
**Sessions:** 2

#### Session 1: Multi-Stage Dockerfile for Production (50 min)
**Pre-Session Questions:**
1. What's a multi-stage build?
2. Why optimize Docker images for production?

**Core Topics:**
- Multi-stage builds
- Production vs development images
- Image size optimization
- Security best practices

**Resources:**
- [Multi-stage builds](https://docs.docker.com/develop/develop-images/multistage-build/)

**Exercises:**
1. Open Blog API project
2. Create Dockerfile in project root
3. Use multi-stage build:
   - Stage 1 (builder): install dependencies, build TypeScript
   - Stage 2 (production): copy built files, install production dependencies only
4. FROM node:18-alpine AS builder
5. Copy package files, run npm ci
6. Copy source code
7. Build TypeScript: npx tsc
8. FROM node:18-alpine AS production
9. Copy package files, run npm ci --production
10. Copy built files from builder stage
11. Set NODE_ENV=production
12. Build image: `docker build -t blog-api .`
13. Run container: `docker run -p 3000:3000 --env-file .env blog-api`

**Optimization Tips:**
- Use alpine images (smaller)
- Multi-stage builds (smaller final image)
- .dockerignore (exclude unnecessary files)
- npm ci instead of npm install (faster, reproducible)
- Install production dependencies only in final stage

**Hints:**
- Hint 1: COPY --from=builder copies from previous stage
- Hint 2: --env-file passes environment variables
- Hint 3: Layer caching: copy package.json before source
- Hint 4: Use specific Node version for reproducibility

**Post-Session Recall:**
1. What's a multi-stage build?
2. Why use alpine images?
3. What's the difference between npm install and npm ci?

---

#### Session 2: Docker Compose for Development (50 min)
**Pre-Session Questions:**
1. What is Docker Compose?
2. Why use it?

**Core Topics:**
- Docker Compose basics
- Services definition
- Networking between containers
- Volumes for data persistence
- Environment variables

**Resources:**
- [Docker Compose docs](https://docs.docker.com/compose/)

**Exercises:**
1. Create docker-compose.yml in project root
2. Define postgres service:
   - image: postgres:15-alpine
   - environment: POSTGRES_PASSWORD, POSTGRES_DB
   - ports: 5432:5432
   - volume for data persistence
3. Define app service:
   - build: current directory
   - ports: 3000:3000
   - depends_on: postgres
   - environment: DATABASE_URL
   - volume for hot reload (bind mount source code)
4. Define network for services
5. Start services: `docker-compose up`
6. Test app connects to database
7. Stop services: `docker-compose down`
8. Run migrations: `docker-compose exec app npx prisma migrate dev`
9. View logs: `docker-compose logs -f`
10. Scale services (explore)

**docker-compose.yml Structure:**
```yaml
version: '3.8'
services:
  postgres:
    # configuration
  app:
    # configuration
volumes:
  # named volumes
```

**Hints:**
- Hint 1: depends_on ensures postgres starts first
- Hint 2: Named volumes persist data
- Hint 3: Bind mounts allow hot reload in development
- Hint 4: Use .env file with docker-compose

**Post-Session Recall:**
1. What does docker-compose up do?
2. How do services communicate?
3. What's the difference between volumes and bind mounts?

**Commit:** `Day 55: Dockerized Blog API with Docker Compose`

---

### Wednesday, Feb 25 - Day 56
**Topic:** NestJS Introduction
**Sessions:** 2

#### Session 1: NestJS Fundamentals (50 min)
**Pre-Session Questions:**
1. What is NestJS?
2. How is it different from Express?

**Core Topics:**
- NestJS architecture
- Modules, Controllers, Services
- Dependency Injection
- Decorators
- TypeScript-first design

**Resources:**
- [NestJS Documentation](https://docs.nestjs.com/)
- [NestJS First Steps](https://docs.nestjs.com/first-steps)

**Conceptual Learning:**
1. What problems does NestJS solve?
2. What is dependency injection?
3. What are decorators?
4. What is the module pattern?
5. How does routing work in NestJS?
6. What is a provider?

**Exercises:**
1. Install NestJS CLI: `npm i -g @nestjs/cli`
2. Create new project: `nest new nest-intro`
3. Explore generated project structure
4. Understand app.module.ts, app.controller.ts, app.service.ts
5. Run development server: `npm run start:dev`
6. Visit http://localhost:3000
7. Make changes to controller, see hot reload
8. Read through main.ts (application entry point)
9. Understand how modules, controllers, services connect
10. Read NestJS overview documentation

**Project Structure:**
- src/
  - main.ts (bootstrap)
  - app.module.ts (root module)
  - app.controller.ts (routes)
  - app.service.ts (business logic)
  - app.controller.spec.ts (tests)

**Hints:**
- Hint 1: Decorators are TypeScript features (@Module, @Controller, @Get)
- Hint 2: Services are providers injected into controllers
- Hint 3: Modules organize code
- Hint 4: NestJS uses Express under the hood (or Fastify)

**Post-Session Recall:**
1. What are the three main building blocks of NestJS?
2. What is dependency injection?
3. How do decorators work?

---

#### Session 2: Controllers & Services (50 min)
**Pre-Session Questions:**
1. What's the responsibility of a controller?
2. What's the responsibility of a service?

**Core Topics:**
- Creating controllers
- Creating services
- Request handling
- Dependency injection
- Route parameters and query params

**Resources:**
- [NestJS Controllers](https://docs.nestjs.com/controllers)
- [NestJS Providers](https://docs.nestjs.com/providers)

**Exercises:**
1. Generate controller: `nest g controller cats`
2. Generate service: `nest g service cats`
3. Observe how CLI adds to module automatically
4. Create GET /cats route in controller
5. Implement findAll() method in service
6. Inject service into controller via constructor
7. Create POST /cats route
8. Create GET /cats/:id route
9. Use @Param decorator to get route parameters
10. Use @Query decorator to get query parameters
11. Use @Body decorator to get request body
12. Test all routes with Thunder Client
13. Return mock data from service

**Controller Example:**
```typescript
@Controller('cats')
export class CatsController {
  constructor(private catsService: CatsService) {}
  
  @Get()
  findAll() {
    return this.catsService.findAll();
  }
}
```

**Hints:**
- Hint 1: Controllers handle HTTP, services handle business logic
- Hint 2: Inject service: `constructor(private service: Service) {}`
- Hint 3: Decorators define routes: @Get(), @Post(), @Put(), @Delete()
- Hint 4: Use DTOs for type safety

**Post-Session Recall:**
1. How do you inject a service?
2. What decorators extract request data?
3. What's the separation of concerns?

**Commit:** `Day 56: NestJS fundamentals - controllers and services`

---

### Thursday, Feb 26 - Day 57
**Topic:** NestJS with Prisma
**Sessions:** 2

#### Session 1: Integrating Prisma with NestJS (50 min)
**Pre-Session Questions:**
1. How do you use Prisma with NestJS?
2. What's a Prisma module?

**Core Topics:**
- Setting up Prisma in NestJS
- Creating Prisma module
- Prisma service
- Database connection lifecycle
- Module imports and exports

**Resources:**
- [NestJS Prisma](https://docs.nestjs.com/recipes/prisma)
- [Prisma with NestJS](https://www.prisma.io/nestjs)

**Exercises:**
1. Create new NestJS project: `nest new blog-nest`
2. Install Prisma: `npm i @prisma/client` and `npm i -D prisma`
3. Initialize Prisma: `npx prisma init`
4. Define User and Post models in schema (simple version)
5. Run migration
6. Generate Prisma module: `nest g module prisma`
7. Generate Prisma service: `nest g service prisma`
8. Implement Prisma service that extends PrismaClient
9. Add onModuleInit to connect
10. Add onModuleDestroy to disconnect
11. Export PrismaService from PrismaModule
12. Test database connection works

**PrismaService Example:**
```typescript
@Injectable()
export class PrismaService extends PrismaClient implements OnModuleInit {
  async onModuleInit() {
    await this.$connect();
  }
  async onModuleDestroy() {
    await this.$disconnect();
  }
}
```

**Hints:**
- Hint 1: PrismaService should be a global module
- Hint 2: Implement lifecycle hooks
- Hint 3: Export service so other modules can import
- Hint 4: Use @Global() decorator for global access

**Post-Session Recall:**
1. Why extend PrismaClient?
2. What are lifecycle hooks?
3. Why export PrismaService?

---

#### Session 2: CRUD with NestJS & Prisma (50 min)
**Pre-Session Questions:**
1. How do you implement CRUD in NestJS?
2. What are DTOs?

**Core Topics:**
- Data Transfer Objects (DTOs)
- Class validation
- CRUD operations with Prisma
- Error handling in NestJS

**Resources:**
- [NestJS Validation](https://docs.nestjs.com/techniques/validation)
- [class-validator](https://github.com/typestack/class-validator)

**Exercises:**
1. Install validation: `npm i class-validator class-transformer`
2. Enable global validation in main.ts: `app.useGlobalPipes(new ValidationPipe())`
3. Generate users module: `nest g resource users` (choose REST API, no CRUD)
4. Create DTOs: create-user.dto.ts, update-user.dto.ts
5. Add validation decorators: @IsEmail(), @IsString(), @MinLength()
6. Inject PrismaService into UsersService
7. Implement create user (hash password with bcrypt)
8. Implement find all users
9. Implement find one user
10. Implement update user
11. Implement delete user
12. Handle errors: user not found â†’ NotFoundException
13. Test all endpoints

**DTO Example:**
```typescript
export class CreateUserDto {
  @IsEmail()
  email: string;
  
  @IsString()
  @MinLength(8)
  password: string;
  
  @IsString()
  name: string;
}
```

**Hints:**
- Hint 1: DTOs define shape and validation
- Hint 2: Use NestJS exceptions: NotFoundException, BadRequestException
- Hint 3: Exclude password when returning user
- Hint 4: Use Prisma service methods in users service

**Post-Session Recall:**
1. What are DTOs used for?
2. How does class-validator work?
3. What NestJS exceptions did you use?

**Commit:** `Day 57: NestJS with Prisma - CRUD operations`

---

### Friday, Feb 27 - Day 58
**Topic:** NestJS Guards & Authentication
**Sessions:** 2

#### Session 1: JWT Authentication in NestJS (50 min)
**Pre-Session Questions:**
1. How does authentication work in NestJS?
2. What is a Guard?

**Core Topics:**
- NestJS Guards
- Passport.js integration
- JWT strategy
- Auth module setup
- Login and registration

**Resources:**
- [NestJS Authentication](https://docs.nestjs.com/security/authentication)
- [NestJS Guards](https://docs.nestjs.com/guards)

**Exercises:**
1. Install packages: `npm i @nestjs/passport @nestjs/jwt passport passport-jwt bcrypt`
2. Install types: `npm i -D @types/passport-jwt @types/bcrypt`
3. Generate auth module: `nest g module auth`
4. Generate auth service: `nest g service auth`
5. Generate auth controller: `nest g controller auth`
6. Implement register endpoint (hash password, create user, return JWT)
7. Implement login endpoint (verify password, return JWT)
8. Configure JwtModule in auth module with secret and expiration
9. Create JWT strategy (extends PassportStrategy)
10. Validate JWT and attach user to request
11. Export JwtStrategy as provider
12. Test registration and login

**Auth Module Setup:**
- Import JwtModule with configuration
- Import UsersModule for user operations
- Provide AuthService and JwtStrategy
- Export AuthService for use in other modules

**Hints:**
- Hint 1: Register JwtModule: `JwtModule.register({ secret, signOptions })`
- Hint 2: JWT Strategy validates token and returns user
- Hint 3: Use ConfigModule for JWT secret
- Hint 4: Hash password on registration, verify on login

**Post-Session Recall:**
1. What does a strategy do?
2. How does JWT module work?
3. Where is the JWT secret stored?

---

#### Session 2: Guards & Protected Routes (50 min)
**Pre-Session Questions:**
1. How do you protect routes in NestJS?
2. What's the execution order of guards?

**Core Topics:**
- Creating auth guard
- Using @UseGuards decorator
- Global guards
- Custom decorators for user
- Role-based guards

**Resources:**
- [NestJS Guards](https://docs.nestjs.com/guards)
- [Custom decorators](https://docs.nestjs.com/custom-decorators)

**Exercises:**
1. Create JWT auth guard: `nest g guard auth/jwt-auth`
2. Implement guard using AuthGuard('jwt') from Passport
3. Apply guard to protected routes: @UseGuards(JwtAuthGuard)
4. Create custom decorator @GetUser() to extract user from request
5. Use decorator in controllers: `@GetUser() user: User`
6. Test protected routes without token â†’ 401
7. Test protected routes with valid token â†’ success
8. Create roles guard for role-based access
9. Create @Roles() decorator
10. Implement RolesGuard that checks user roles
11. Apply both guards to admin routes
12. Test role-based access

**Custom Decorator Example:**
```typescript
export const GetUser = createParamDecorator(
  (data: unknown, ctx: ExecutionContext) => {
    const request = ctx.switchToHttp().getRequest();
    return request.user;
  },
);
```

**Hints:**
- Hint 1: Guards return true (allow) or false (deny)
- Hint 2: @UseGuards() applies guard to route/controller
- Hint 3: Multiple guards execute in order
- Hint 4: Custom decorators extract data from request

**Post-Session Recall:**
1. How do guards work?
2. How do you create custom decorators?
3. What's the difference between authentication and authorization guards?

**Commit:** `Day 58: NestJS authentication with Guards`

---

### Saturday, Feb 28 - Day 59
**Topic:** NestJS Advanced Patterns
**Sessions:** 4

#### Session 1: Interceptors & Pipes (50 min)
**Pre-Session Questions:**
1. What is an interceptor?
2. What is a pipe?

**Core Topics:**
- NestJS Interceptors
- Transformation interceptors
- Logging interceptors
- NestJS Pipes
- Custom pipes

**Resources:**
- [NestJS Interceptors](https://docs.nestjs.com/interceptors)
- [NestJS Pipes](https://docs.nestjs.com/pipes)

**Exercises:**
1. Create logging interceptor: logs request method, URL, execution time
2. Apply interceptor globally or to specific routes
3. Create transform interceptor: wraps all responses in standard format `{ success, data, timestamp }`
4. Create custom pipe for password validation
5. Create custom pipe for trimming strings
6. Apply pipes to specific parameters
7. Test interceptors and pipes work correctly

**Interceptor Example:**
```typescript
@Injectable()
export class LoggingInterceptor implements NestInterceptor {
  intercept(context: ExecutionContext, next: CallHandler) {
    console.log('Before...');
    const now = Date.now();
    return next.handle().pipe(
      tap(() => console.log(`After... ${Date.now() - now}ms`))
    );
  }
}
```

**Hints:**
- Hint 1: Interceptors can transform responses
- Hint 2: Pipes validate/transform input
- Hint 3: Use RxJS operators in interceptors
- Hint 4: Apply globally in main.ts

**Post-Session Recall:**
1. When do interceptors run?
2. What's the difference between interceptors and middleware?
3. What are built-in pipes?

---

#### Session 2: Exception Filters & Error Handling (50 min)
**Pre-Session Questions:**
1. How does error handling work in NestJS?
2. What is an exception filter?

**Core Topics:**
- Exception filters
- Custom exception filters
- HTTP exceptions
- Error response formatting
- Global error handling

**Resources:**
- [NestJS Exception Filters](https://docs.nestjs.com/exception-filters)

**Exercises:**
1. Understand built-in exceptions: NotFoundException, BadRequestException, UnauthorizedException
2. Create custom exception: UserNotFoundException
3. Create global exception filter
4. Format error responses consistently
5. Log errors with details
6. Handle Prisma errors (unique constraint, not found)
7. Test different error scenarios
8. Verify error responses are consistent

**Exception Filter Example:**
```typescript
@Catch()
export class AllExceptionsFilter implements ExceptionFilter {
  catch(exception: unknown, host: ArgumentsHost) {
    const ctx = host.switchToHttp();
    const response = ctx.getResponse();
    const request = ctx.getRequest();
    // Format and send error response
  }
}
```

**Hints:**
- Hint 1: @Catch() catches all exceptions
- Hint 2: @Catch(HttpException) catches specific type
- Hint 3: Format errors: { statusCode, message, timestamp, path }
- Hint 4: Log errors for monitoring

**Post-Session Recall:**
1. What's an exception filter?
2. How do you handle Prisma errors?
3. Why format error responses consistently?

---

#### Session 3: Configuration & Environment Variables (50 min)
**Pre-Session Questions:**
1. How do you manage configuration in NestJS?
2. Why use ConfigModule?

**Core Topics:**
- ConfigModule setup
- Environment variables
- Configuration validation
- Type-safe configuration
- Different environments (dev, prod)

**Resources:**
- [NestJS Configuration](https://docs.nestjs.com/techniques/configuration)

**Exercises:**
1. Install @nestjs/config: `npm i @nestjs/config`
2. Import ConfigModule.forRoot() in AppModule
3. Create .env file with variables: DATABASE_URL, JWT_SECRET, PORT
4. Create .env.example (template)
5. Access config in services: inject ConfigService
6. Create config validation schema with Joi
7. Create typed configuration objects
8. Use configuration in different modules
9. Test with different environment files (.env.development, .env.production)
10. Update Docker setup to use environment variables

**Configuration Example:**
```typescript
ConfigModule.forRoot({
  isGlobal: true,
  validationSchema: Joi.object({
    DATABASE_URL: Joi.string().required(),
    JWT_SECRET: Joi.string().required(),
  }),
})
```

**Hints:**
- Hint 1: Make ConfigModule global
- Hint 2: Validate configuration on startup
- Hint 3: Use typed config objects
- Hint 4: Never commit .env files

**Post-Session Recall:**
1. Why validate configuration?
2. How do you access config values?
3. What's the benefit of typed configuration?

---

#### Session 4: Testing NestJS Applications (50 min)
**Pre-Session Questions:**
1. How do you test NestJS apps?
2. What's TestingModule?

**Core Topics:**
- Unit testing controllers
- Unit testing services
- Mocking dependencies
- Integration testing
- E2E testing basics

**Resources:**
- [NestJS Testing](https://docs.nestjs.com/fundamentals/testing)

**Exercises:**
1. Understand generated test files (.spec.ts)
2. Use Test.createTestingModule() to create test module
3. Test UsersService: mock PrismaService
4. Test UsersController: mock UsersService
5. Write test for create user
6. Write test for find user
7. Write test for error scenarios
8. Run tests: `npm test`
9. Run tests with coverage: `npm test -- --coverage`
10. Explore e2e tests in test folder

**Test Example:**
```typescript
describe('UsersService', () => {
  let service: UsersService;
  let prisma: PrismaService;
  
  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [UsersService, { provide: PrismaService, useValue: mockPrisma }],
    }).compile();
    
    service = module.get<UsersService>(UsersService);
  });
  
  it('should create user', async () => {
    // Test implementation
  });
});
```

**Hints:**
- Hint 1: Use TestingModule to create isolated tests
- Hint 2: Mock dependencies with useValue
- Hint 3: Test success and error scenarios
- Hint 4: E2E tests use actual HTTP requests

**Post-Session Recall:**
1. How do you create a testing module?
2. How do you mock providers?
3. What's the difference between unit and e2e tests?

**Commit:** `Day 59: NestJS advanced patterns and testing`

---

### Sunday, Mar 1 - Day 60
**Topic:** NestJS Project - Task API Rebuild
**Sessions:** 4

#### Session 1-4: Rebuild Task API with NestJS (200 min)
**Project Goal:** Rebuild your Phase 1 Task API using NestJS with all best practices

**Requirements:**
- Use NestJS framework
- TypeScript throughout
- Prisma for database
- JWT authentication
- Role-based authorization
- Validation with DTOs
- Custom decorators
- Exception filters
- Interceptors for logging
- Configuration management
- Comprehensive tests
- Docker setup
- API documentation

**Features:**
- User registration/login
- CRUD tasks (title, description, status, priority, dueDate)
- Filter tasks (status, priority, overdue)
- Pagination and sorting
- Only users can see/edit their own tasks
- Admin role can see all tasks

**Implementation Plan:**
1. **Setup (30 min)**
   - Create new NestJS project
   - Setup Prisma with User and Task models
   - Configure environment variables
   - Setup Docker Compose

2. **Auth Module (40 min)**
   - Implement registration/login
   - JWT strategy
   - Auth guard
   - Custom @GetUser() decorator

3. **Tasks Module (60 min)**
   - DTOs with validation
   - CRUD operations
   - Filter, pagination, sorting
   - Authorization (user can only access their tasks)

4. **Advanced Features (40 min)**
   - Logging interceptor
   - Transform interceptor
   - Exception filter
   - Role-based guard (admin)

5. **Testing (30 min)**
   - Unit tests for services
   - E2E tests for endpoints
   - Test coverage >70%

**Test Your Implementation:**
- Register new user
- Login and get JWT
- Create tasks
- Get tasks with filters
- Update tasks (own tasks only)
- Delete tasks
- Try accessing other user's tasks (should fail)
- Test admin access

**Hints:**
- Hint 1: Use `nest g resource tasks` to scaffold
- Hint 2: Add userId to Task model
- Hint 3: Use @GetUser() to get current user
- Hint 4: Apply JwtAuthGuard to protect routes
- Hint 5: Filter tasks: `where: { userId: user.id }`

**Commit:** `Day 60: NestJS Task API complete`

**Reflection Questions:**
1. How does NestJS compare to Express?
2. What do you like about NestJS?
3. What's challenging about NestJS?
4. How has your code organization improved?

---

## ðŸŽ¯ Phase 2 Checkpoint (Days 46-60)

**You've completed:**
- âœ… Authentication & Authorization (JWT, bcrypt, refresh tokens)
- âœ… Testing (Jest, unit tests, integration tests, TDD basics)
- âœ… Docker (containers, images, Dockerfile, Docker Compose)
- âœ… NestJS (architecture, modules, guards, interceptors, testing)
- âœ… Built Blog API with auth
- âœ… Rebuilt Task API with NestJS

**Skills Acquired:**
- Secure authentication implementation
- Comprehensive testing strategies
- Containerization with Docker
- Enterprise-grade NestJS applications
- Advanced TypeScript patterns

**Remaining Phase 2 (Days 61-87):**
- Advanced database patterns
- Caching with Redis
- Message queues
- Microservices basics
- Performance optimization
- Production deployment preparation

Take a day to review and consolidate if needed before continuing!

---

### Monday, Mar 2 - Day 61
**Topic:** Advanced Database Patterns - Transactions
**Sessions:** 2

#### Session 1: Database Transactions with Prisma (50 min)
**Pre-Session Questions:**
1. What is a database transaction?
2. When do you need transactions?

**Core Topics:**
- ACID properties
- Prisma transactions
- Nested writes
- Transaction rollback
- Error handling in transactions

**Resources:**
- [Prisma Transactions](https://www.prisma.io/docs/concepts/components/prisma-client/transactions)

**Exercises:**
1. Create test scenario: transfer funds between user accounts
2. Implement without transaction - see the problem (partial updates)
3. Implement with Prisma transaction: `prisma.$transaction()`
4. Test rollback on error
5. Use interactive transactions for complex operations
6. Implement: create post with tags in single transaction
7. Implement: delete user and cascade delete all related data
8. Test transaction isolation
9. Handle transaction errors properly
10. Verify data consistency

**Transaction Example:**
```typescript
await prisma.$transaction([
  prisma.account.update({ where: { id: from }, data: { balance: { decrement: amount } } }),
  prisma.account.update({ where: { id: to }, data: { balance: { increment: amount } } }),
]);
```

**Hints:**
- Hint 1: Array notation for simple sequential transactions
- Hint 2: Callback notation for interactive transactions
- Hint 3: All-or-nothing: if one fails, all roll back
- Hint 4: Use for data consistency requirements

**Post-Session Recall:**
1. What are ACID properties?
2. When should you use transactions?
3. What happens if transaction fails?

---

#### Session 2: Database Indexing & Query Optimization (50 min)
**Pre-Session Questions:**
1. What is a database index?
2. How do indexes improve performance?

**Core Topics:**
- Database indexes
- When to add indexes
- Composite indexes
- Query performance analysis
- N+1 query problem

**Resources:**
- [Prisma Performance](https://www.prisma.io/docs/guides/performance-and-optimization)
- [Database Indexing Basics](https://use-the-index-luke.com/)

**Exercises:**
1. Add index to frequently queried fields in Prisma schema
2. Add index: email on User (unique index)
3. Add composite index: (authorId, published) on Post
4. Run migration
5. Identify N+1 queries in your code
6. Fix N+1 with Prisma include/select
7. Use Prisma query logging to analyze queries
8. Test query performance before/after indexes
9. Document when to use indexes
10. Understand trade-offs (write performance vs read performance)

**Index Example:**
```prisma
model Post {
  id        Int     @id @default(autoincrement())
  title     String
  authorId  Int
  published Boolean
  
  @@index([authorId, published])
}
```

**Hints:**
- Hint 1: Index columns used in WHERE clauses
- Hint 2: Index foreign keys
- Hint 3: Don't over-index (slows writes)
- Hint 4: Use select/include to avoid N+1

**Post-Session Recall:**
1. When should you add an index?
2. What's the N+1 problem?
3. What are trade-offs of indexing?

**Commit:** `Day 61: Transactions and database optimization`

---

### Saturday, Mar 1 - Day 62
**Topic:** Redis Introduction & Basic Caching
**Sessions:** 2

#### Session 1: Redis Fundamentals (50 min)
**Pre-Session Questions:**
1. What is in-memory caching and why is it faster than databases?
2. What problems does Redis solve?
3. What's the difference between Redis and PostgreSQL?

**Core Topics:**
- In-memory data structures
- Key-value storage patterns
- Redis data types (strings, hashes, lists, sets, sorted sets)
- TTL (Time To Live) and expiration
- Redis use cases: caching, sessions, rate limiting, real-time

**Resources:**
- [Redis University - Introduction](https://university.redis.com/courses/ru101/) (30 min)
- [Redis Documentation - Data Types](https://redis.io/docs/data-types/) (20 min)

**Setup:**
```bash
# Install Redis with Docker
docker run -d --name redis-dev -p 6379:6379 redis:alpine

# Install Redis client in your blog-api project
cd blog-api
npm install ioredis @types/ioredis
```

**Exercises:**
1. Create Redis connection service in NestJS
2. Store and retrieve a simple key-value pair
3. Set key with 60-second expiration
4. Store user object as hash
5. Create list of recent posts IDs
6. Implement sorted set for post rankings by views

**Practice Problems:**
- Problem 1: Create `CacheService` with get/set/delete methods
- Problem 2: Add TTL support to cache service (default 5 minutes)
- Problem 3: Create method to check if key exists
- Problem 4: Implement cache invalidation pattern
- Problem 5: Store JSON objects in cache

**Hints:**
- Use `@nestjs/cache-manager` for cleaner integration
- Redis automatically serializes primitives, manually serialize objects
- Always handle Redis connection errors gracefully

#### Session 2: Basic Caching Implementation (50 min)
**Topics:** Cache-aside pattern, cache warming, invalidation strategies

**Exercises:**
1. Cache blog post by ID (cache-aside pattern)
2. Cache list of all posts
3. Implement cache warming on app startup
4. Add cache invalidation on post update/delete
5. Create cache hit/miss logging
6. Measure performance improvement with/without cache

**Practice Problems:**
- Problem 1: Implement `findPostById` with caching (check cache first, then DB)
- Problem 2: Cache search results for common queries
- Problem 3: Invalidate post cache when post is updated
- Problem 4: Implement "cache stampede" prevention with locks
- Problem 5: Add cache statistics endpoint (hits, misses, hit rate)

**Hints:**
- Cache key naming convention: `post:${id}`, `posts:all`, `search:${query}`
- Invalidate specific keys, not entire cache
- Consider stale-while-revalidate pattern for better UX

**Commit:** `Day 62: Redis integration and basic caching`

---

### Sunday, Mar 2 - Day 63
**Topic:** Advanced Caching Patterns
**Sessions:** 2

#### Session 1: Cache Strategies (50 min)
**Pre-Session Questions:**
1. What's the difference between cache-aside and write-through caching?
2. When would you use cache-aside vs write-through?
3. What is cache invalidation and why is it hard?

**Core Topics:**
- Cache-aside (lazy loading)
- Write-through caching
- Write-behind caching
- Cache invalidation strategies
- Cache warming vs cold cache
- Stampede prevention

**Resources:**
- [AWS - Caching Best Practices](https://aws.amazon.com/caching/best-practices/) (20 min)
- [Cache Strategies Explained](https://codeahoy.com/2017/08/11/caching-strategies-and-how-to-choose-the-right-one/) (15 min)

**Exercises:**
1. Implement write-through caching for post creation
2. Add cache warming for popular posts on startup
3. Create cache invalidation middleware
4. Implement LRU eviction simulation
5. Add cache versioning for breaking changes
6. Create cache health check endpoint

**Practice Problems:**
- Problem 1: Implement write-through cache for user profile updates
- Problem 2: Cache user's own posts list with automatic invalidation
- Problem 3: Implement tag-based cache invalidation (invalidate all posts with tag:javascript)
- Problem 4: Create cache decorator for controller methods
- Problem 5: Add Redis cluster support for high availability

**Hints:**
- Use Redis pub/sub for distributed cache invalidation
- Consider using cache tags for grouped invalidation
- Monitor cache memory usage to prevent OOM

#### Session 2: Performance Optimization (50 min)
**Topics:** Query optimization with caching, pagination caching, aggregate caching

**Exercises:**
1. Cache paginated results (page 1, page 2, etc.)
2. Cache user authentication checks
3. Cache database aggregations (post count, user count)
4. Implement cache preloading for predictable queries
5. Add cache compression for large objects
6. Benchmark API response times with various cache strategies

**Practice Problems:**
- Problem 1: Cache expensive aggregation queries (e.g., posts per category)
- Problem 2: Implement sliding window cache for recent activity
- Problem 3: Cache computed fields (e.g., post read time calculation)
- Problem 4: Add cache warming for frequently accessed data
- Problem 5: Create cache invalidation queue for batch updates

**Hints:**
- Cache expensive computations, not cheap DB queries
- Use shorter TTL for frequently changing data
- Consider partial caching (cache expensive parts only)

**Commit:** `Day 63: Advanced caching patterns and optimization`

---

### Monday, Mar 3 - Day 64
**Topic:** Rate Limiting & Throttling
**Sessions:** 2

#### Session 1: Rate Limiting Fundamentals (50 min)
**Pre-Session Questions:**
1. Why do APIs need rate limiting?
2. What's the difference between rate limiting and throttling?
3. What is a token bucket algorithm?

**Core Topics:**
- Rate limiting strategies (fixed window, sliding window, token bucket)
- IP-based vs user-based rate limiting
- Rate limit headers (X-RateLimit-*)
- 429 Too Many Requests response
- Rate limiting with Redis

**Resources:**
- [Rate Limiting Algorithms](https://blog.logrocket.com/rate-limiting-node-js/) (15 min)
- [NestJS Throttler Documentation](https://docs.nestjs.com/security/rate-limiting) (10 min)

**Setup:**
```bash
npm install @nestjs/throttler
```

**Exercises:**
1. Install and configure @nestjs/throttler
2. Add global rate limit: 100 requests per 15 minutes
3. Create custom rate limit for auth endpoints (5 login attempts per minute)
4. Add rate limit headers to responses
5. Create rate limit exceeded exception filter
6. Test rate limiting with multiple requests

**Practice Problems:**
- Problem 1: Implement IP-based rate limiting (10 req/min per IP)
- Problem 2: Implement user-based rate limiting (100 req/hour per user)
- Problem 3: Create different rate limits for different endpoints (public vs authenticated)
- Problem 4: Add rate limiting bypass for admin users
- Problem 5: Create rate limit monitoring dashboard data

**Hints:**
- Use Redis for distributed rate limiting (multiple servers)
- Return remaining requests in headers: `X-RateLimit-Remaining`
- Consider different limits for read vs write operations

#### Session 2: Advanced Throttling (50 min)
**Topics:** Dynamic rate limits, burst handling, graceful degradation

**Exercises:**
1. Implement sliding window rate limiter with Redis
2. Create dynamic rate limits based on user tier (free vs premium)
3. Add burst allowance (allow 10 requests instantly, then throttle)
4. Implement graceful degradation (return cached data when rate limited)
5. Add rate limit reset timer in response headers
6. Create rate limit analytics (who's hitting limits, which endpoints)

**Practice Problems:**
- Problem 1: Implement token bucket algorithm manually with Redis
- Problem 2: Create API key-based rate limiting
- Problem 3: Add rate limiting for expensive operations (e.g., search limited to 10 req/min)
- Problem 4: Implement progressive delay (delay increases with each request)
- Problem 5: Create rate limit warming system (gradually increase limits for new users)

**Hints:**
- Store rate limit counters in Redis with TTL
- Use Redis sorted sets for sliding window implementation
- Add monitoring to detect abuse patterns

**Commit:** `Day 64: Rate limiting and throttling implementation`

---

### Tuesday, Mar 4 - Day 65
**Topic:** API Documentation with Swagger/OpenAPI
**Sessions:** 2

#### Session 1: Swagger Setup & Basic Documentation (50 min)
**Pre-Session Questions:**
1. What is OpenAPI specification?
2. Why is API documentation important?
3. What information should API docs contain?

**Core Topics:**
- OpenAPI 3.0 specification
- Swagger UI integration
- Auto-generated docs from decorators
- Request/response schemas
- Authentication documentation

**Resources:**
- [NestJS Swagger Documentation](https://docs.nestjs.com/openapi/introduction) (20 min)
- [OpenAPI Specification](https://swagger.io/specification/) (15 min)

**Setup:**
```bash
npm install @nestjs/swagger swagger-ui-express
```

**Exercises:**
1. Install and configure Swagger in NestJS
2. Access Swagger UI at `/api-docs`
3. Document post endpoints with @ApiTags, @ApiOperation
4. Add @ApiResponse decorators for success/error responses
5. Document request DTOs with @ApiProperty
6. Add authentication documentation with @ApiBearerAuth

**Practice Problems:**
- Problem 1: Document all blog post CRUD endpoints
- Problem 2: Add examples for request/response bodies
- Problem 3: Document query parameters for pagination
- Problem 4: Add error response schemas (400, 401, 404, 500)
- Problem 5: Document authentication flow with examples

**Hints:**
- Use @ApiProperty({ example: '...' }) for better docs
- Group endpoints with @ApiTags
- Document all possible HTTP status codes

#### Session 2: Advanced API Documentation (50 min)
**Topics:** Schema generation, API versioning docs, testing from Swagger UI

**Exercises:**
1. Auto-generate schemas from TypeScript classes
2. Add enum documentation for post status
3. Document file upload endpoints
4. Add API versioning to documentation
5. Create separate docs for public vs admin API
6. Add "Try it out" functionality testing

**Practice Problems:**
- Problem 1: Document nested objects and relationships
- Problem 2: Add deprecation warnings for old endpoints
- Problem 3: Document webhooks in Swagger
- Problem 4: Create API changelog section
- Problem 5: Add authentication testing directly from Swagger UI

**Hints:**
- Use @ApiExtraModels for reusable schemas
- Keep docs up-to-date with code (use decorators, not manual docs)
- Add useful descriptions and examples

**Commit:** `Day 65: Complete API documentation with Swagger`

---

### Wednesday, Mar 5 - Day 66
**Topic:** Background Jobs with BullMQ - Part 1
**Sessions:** 2

#### Session 1: Job Queues Fundamentals (50 min)
**Pre-Session Questions:**
1. Why would you run tasks in the background instead of in the request?
2. What is a message queue?
3. What happens if a background job fails?

**Core Topics:**
- Job queues concept (producer-consumer pattern)
- BullMQ architecture (Redis-backed queues)
- Use cases: emails, image processing, reports, cleanup tasks
- Job lifecycle: waiting â†’ active â†’ completed/failed
- Job retries and dead letter queues

**Resources:**
- [BullMQ Documentation](https://docs.bullmq.io/) (20 min)
- [@nestjs/bull Documentation](https://docs.nestjs.com/techniques/queues) (15 min)

**Setup:**
```bash
npm install @nestjs/bull bull bullmq
```

**Exercises:**
1. Install BullMQ and configure with Redis
2. Create email queue
3. Add job to send welcome email on user registration
4. Create worker to process email jobs
5. Add job completion logging
6. Test job processing with multiple jobs

**Practice Problems:**
- Problem 1: Create email queue with producer and consumer
- Problem 2: Add job to send "New comment" notification email
- Problem 3: Implement job retry logic (max 3 attempts)
- Problem 4: Add job progress tracking (0%, 50%, 100%)
- Problem 5: Create job failure handler with logging

**Hints:**
- Separate queue producers (controllers) from consumers (processors)
- Use job IDs for tracking
- Always handle job failures gracefully

#### Session 2: Job Configuration & Monitoring (50 min)
**Topics:** Job options, priority queues, delayed jobs, job events

**Exercises:**
1. Add job priority (high priority for password reset emails)
2. Implement delayed jobs (send reminder email in 24 hours)
3. Add job timeouts (fail if job takes >30 seconds)
4. Create job removal on completion/failure
5. Implement job event listeners (completed, failed, progress)
6. Add queue health monitoring endpoint

**Practice Problems:**
- Problem 1: Create priority queue (high/medium/low priority jobs)
- Problem 2: Schedule delayed job for post publication (publish at specific time)
- Problem 3: Implement job throttling (max 10 emails per minute)
- Problem 4: Add job deduplication (don't send duplicate emails)
- Problem 5: Create job dashboard data (pending, active, completed, failed counts)

**Hints:**
- Use `opts.priority` for job prioritization
- Use `opts.delay` for delayed execution
- Monitor queue size to prevent memory issues

**Commit:** `Day 66: Background jobs with BullMQ fundamentals`

---

### Thursday, Mar 6 - Day 67
**Topic:** Background Jobs with BullMQ - Part 2
**Sessions:** 2

#### Session 1: Advanced Job Patterns (50 min)
**Pre-Session Questions:**
1. How do you handle jobs that depend on other jobs?
2. What is a cron job?
3. How do you scale job processing?

**Core Topics:**
- Cron jobs (scheduled recurring tasks)
- Job chaining (job B runs after job A completes)
- Batch jobs (process multiple items together)
- Job concurrency control
- Scaling workers

**Resources:**
- [BullMQ Patterns](https://docs.bullmq.io/patterns/patterns) (20 min)

**Exercises:**
1. Create cron job to clean up old posts daily
2. Implement job chaining (image upload â†’ resize â†’ save â†’ notify)
3. Create batch job processor (process 100 posts at once)
4. Add concurrency limit (max 5 jobs running simultaneously)
5. Create separate worker instance for testing
6. Implement graceful shutdown for workers

**Practice Problems:**
- Problem 1: Create daily digest email cron job (runs every day at 9 AM)
- Problem 2: Implement job chaining for multi-step process
- Problem 3: Create bulk email job (send to 1000 users in batches of 50)
- Problem 4: Add job timeout and automatic retry
- Problem 5: Implement worker scaling (multiple worker processes)

**Hints:**
- Use `@Cron('0 9 * * *')` for daily 9 AM execution
- Chain jobs using job return values
- Process in batches to avoid memory issues

#### Session 2: Job Monitoring & Error Handling (50 min)
**Topics:** Dead letter queues, job metrics, debugging failed jobs

**Exercises:**
1. Create dead letter queue for permanently failed jobs
2. Add structured logging for all job events
3. Implement job metrics collection (duration, success rate)
4. Create job retry with exponential backoff
5. Add job failure alerts (log to monitoring service)
6. Build job dashboard endpoint with stats

**Practice Problems:**
- Problem 1: Implement custom error handling for different error types
- Problem 2: Create job replay functionality (retry failed jobs manually)
- Problem 3: Add job performance monitoring (track slow jobs)
- Problem 4: Implement circuit breaker for external service failures
- Problem 5: Create job archive system (move old completed jobs to archive)

**Hints:**
- Store failed jobs for manual review
- Add contextual data to job errors for debugging
- Monitor job queue length to detect bottlenecks

**Commit:** `Day 67: Advanced background job patterns and monitoring`

---

### Friday, Mar 7 - Day 68
**Topic:** WebSockets & Real-Time Features - Part 1
**Sessions:** 2

#### Session 1: WebSocket Fundamentals (50 min)
**Pre-Session Questions:**
1. What's the difference between HTTP and WebSocket?
2. When would you use WebSockets instead of polling?
3. What is a full-duplex connection?

**Core Topics:**
- WebSocket protocol (ws://)
- Socket.IO vs native WebSockets
- Connection lifecycle (connect, disconnect, reconnect)
- Event-based communication
- Rooms and namespaces

**Resources:**
- [NestJS WebSockets](https://docs.nestjs.com/websockets/gateways) (20 min)
- [Socket.IO Documentation](https://socket.io/docs/v4/) (20 min)

**Setup:**
```bash
npm install @nestjs/websockets @nestjs/platform-socket.io socket.io
```

**Exercises:**
1. Create WebSocket gateway in NestJS
2. Handle client connection/disconnection events
3. Emit "hello" event to connected client
4. Receive message from client and broadcast to all
5. Test with WebSocket client (Postman or socket.io-client)
6. Add connection logging

**Practice Problems:**
- Problem 1: Create chat gateway that broadcasts messages to all users
- Problem 2: Implement typing indicator (user is typing...)
- Problem 3: Add online users count display
- Problem 4: Create private messages between two users
- Problem 5: Handle WebSocket authentication (JWT in handshake)

**Hints:**
- Use `@WebSocketGateway()` decorator
- Emit events with `server.emit(event, data)`
- Store connected users in Map for tracking

#### Session 2: Real-Time Blog Features (50 min)
**Topics:** Live updates, notifications, collaborative features

**Exercises:**
1. Emit event when new post is created (notify all users)
2. Broadcast comment additions in real-time
3. Implement live post view counter
4. Add real-time like notifications
5. Create "New activity" notification system
6. Test with multiple browser windows

**Practice Problems:**
- Problem 1: Broadcast new posts to all connected users
- Problem 2: Implement real-time comment stream for a post
- Problem 3: Add notification when someone likes your post
- Problem 4: Create live user activity feed
- Problem 5: Implement "user is viewing post" indicator

**Hints:**
- Use rooms to group users (e.g., all users viewing post:123)
- Emit only to relevant users, not everyone
- Handle edge cases (user disconnects mid-update)

**Commit:** `Day 68: WebSocket integration and real-time features`

---

### Saturday, Mar 8 - Day 69
**Topic:** WebSockets & Real-Time Features - Part 2
**Sessions:** 2

#### Session 1: Advanced WebSocket Patterns (50 min)
**Pre-Session Questions:**
1. How do you scale WebSockets across multiple servers?
2. What is a WebSocket room?
3. How do you handle reconnection?

**Core Topics:**
- Rooms and namespaces for organization
- Broadcasting strategies (to all, to room, except sender)
- WebSocket middleware (authentication, logging)
- Adapter pattern for scaling (Redis adapter)
- Reconnection handling

**Resources:**
- [Socket.IO Rooms](https://socket.io/docs/v4/rooms/) (15 min)
- [Scaling with Redis Adapter](https://socket.io/docs/v4/redis-adapter/) (10 min)

**Exercises:**
1. Create room for each blog post (users join when viewing post)
2. Broadcast comment only to users in that post's room
3. Implement namespace for admin-only events
4. Add WebSocket middleware for JWT authentication
5. Set up Redis adapter for multi-server WebSocket support
6. Handle automatic client reconnection

**Practice Problems:**
- Problem 1: Implement post-specific rooms (users auto-join when viewing post)
- Problem 2: Create admin namespace for admin-only real-time updates
- Problem 3: Add authentication middleware (reject unauthorized connections)
- Problem 4: Implement presence system (who's online, who's viewing what)
- Problem 5: Handle disconnection cleanup (remove user from all rooms)

**Hints:**
- Use `socket.join(room)` to add user to room
- Emit to room with `server.to(room).emit(event, data)`
- Store user-socket mapping for targeted messages

#### Session 2: Real-Time Dashboard (50 min)
**Topics:** Live metrics, server-sent events alternative, performance

**Exercises:**
1. Create real-time analytics dashboard (posts created, users online)
2. Implement live metrics updates (every 5 seconds)
3. Add real-time error notifications for admins
4. Create live log streaming
5. Optimize WebSocket payload size
6. Add heartbeat/ping-pong for connection health

**Practice Problems:**
- Problem 1: Create admin dashboard with live stats (active users, posts today, errors)
- Problem 2: Implement real-time error alerting
- Problem 3: Add live activity feed (last 10 actions)
- Problem 4: Create real-time search suggestions
- Problem 5: Implement graceful degradation (fallback to polling if WebSocket fails)

**Hints:**
- Send only changed data, not full state every time
- Use compression for large payloads
- Implement exponential backoff for reconnection

**Commit:** `Day 69: Advanced WebSocket patterns and real-time dashboard`

---

### Sunday, Mar 9 - Day 70
**Topic:** File Uploads & Cloud Storage - Part 1
**Sessions:** 2

#### Session 1: File Upload Basics (50 min)
**Pre-Session Questions:**
1. How do you handle file uploads in HTTP?
2. What is multipart/form-data?
3. Where should uploaded files be stored in production?

**Core Topics:**
- Multipart form data
- File validation (size, type, extension)
- Local file storage vs cloud storage
- File streaming for large uploads
- Security considerations (file validation, path traversal)

**Resources:**
- [NestJS File Upload](https://docs.nestjs.com/techniques/file-upload) (15 min)
- [Multer Documentation](https://github.com/expressjs/multer) (10 min)

**Setup:**
```bash
npm install @nestjs/platform-express multer @types/multer
```

**Exercises:**
1. Create file upload endpoint for post images
2. Validate file size (max 5MB)
3. Validate file type (only images: jpg, png, webp)
4. Save uploaded file to `uploads/` directory
5. Return file URL in response
6. Serve uploaded files via static endpoint

**Practice Problems:**
- Problem 1: Create POST `/posts/:id/image` endpoint for post cover image
- Problem 2: Validate uploaded file is actually an image (check MIME type and magic bytes)
- Problem 3: Limit file size to 5MB, return error if exceeded
- Problem 4: Generate unique filename (avoid collisions)
- Problem 5: Create GET endpoint to serve uploaded images

**Hints:**
- Use `@UseInterceptors(FileInterceptor('file'))` for single file
- Validate file in pipe before saving
- Store filename in database, not binary data

#### Session 2: Multiple Files & Optimization (50 min)
**Topics:** Multiple file uploads, image optimization, thumbnails

**Exercises:**
1. Handle multiple file uploads (up to 5 images per post)
2. Generate thumbnails for uploaded images
3. Implement image compression (reduce file size by 60%)
4. Add file deletion endpoint
5. Clean up orphaned files (files not referenced in DB)
6. Add upload progress tracking

**Practice Problems:**
- Problem 1: Allow multiple image uploads for post gallery
- Problem 2: Generate 3 sizes: thumbnail (150x150), medium (800x600), original
- Problem 3: Compress images without visible quality loss
- Problem 4: Delete old image when post cover is replaced
- Problem 5: Create cleanup job to remove unused files

**Hints:**
- Use `sharp` library for image processing: `npm install sharp`
- Process images in background job for large files
- Store multiple sizes and serve appropriate size based on request

**Commit:** `Day 70: File uploads and image processing`

---

### Monday, Mar 10 - Day 71
**Topic:** File Uploads & Cloud Storage - Part 2 (AWS S3)
**Sessions:** 2

#### Session 1: AWS S3 Integration (50 min)
**Pre-Session Questions:**
1. Why use cloud storage instead of local file system?
2. What is S3 and what are its benefits?
3. How do you secure files in S3?

**Core Topics:**
- AWS S3 basics (buckets, objects, keys)
- S3 SDK for Node.js
- Presigned URLs for secure access
- S3 bucket policies and ACLs
- Cost optimization (storage classes)

**Resources:**
- [AWS S3 Documentation](https://docs.aws.amazon.com/s3/) (20 min)
- [AWS SDK for JavaScript](https://docs.aws.amazon.com/sdk-for-javascript/v3/developer-guide/welcome.html) (15 min)

**Setup:**
```bash
npm install @aws-sdk/client-s3 @aws-sdk/s3-request-presigner
# Create free AWS account and S3 bucket
```

**Exercises:**
1. Set up AWS credentials (access key, secret key)
2. Create S3 service in NestJS
3. Upload file to S3 bucket
4. Generate public URL for uploaded file
5. Download file from S3
6. Delete file from S3

**Practice Problems:**
- Problem 1: Upload post image to S3 instead of local storage
- Problem 2: Generate unique S3 key (path) for each file
- Problem 3: Set proper content-type for uploaded files
- Problem 4: Make uploaded images publicly accessible
- Problem 5: Update post record with S3 URL

**Hints:**
- Use S3 key format: `posts/${postId}/${filename}`
- Set content-type to enable browser preview
- Store S3 credentials in environment variables

#### Session 2: Advanced S3 Features (50 min)
**Topics:** Presigned URLs, direct browser uploads, CDN integration

**Exercises:**
1. Generate presigned URL for temporary file access
2. Implement direct browser-to-S3 upload (bypass server)
3. Set file expiration (auto-delete after 30 days)
4. Add CloudFront CDN for faster file delivery
5. Implement S3 multipart upload for large files
6. Add upload progress tracking

**Practice Problems:**
- Problem 1: Generate presigned upload URL (let client upload directly to S3)
- Problem 2: Create presigned download URL with 1-hour expiration
- Problem 3: Implement S3 lifecycle policy (delete old files automatically)
- Problem 4: Set up CloudFront distribution for S3 bucket
- Problem 5: Add CORS configuration for direct browser uploads

**Hints:**
- Presigned URLs avoid exposing AWS credentials to client
- Use multipart upload for files >100MB
- CDN reduces S3 request costs and improves speed

**Commit:** `Day 71: AWS S3 integration and cloud file storage`

---

### Tuesday, Mar 11 - Day 72
**Topic:** Email Integration - Part 1
**Sessions:** 2

#### Session 1: Email Service Setup (50 min)
**Pre-Session Questions:**
1. How do you send emails from a Node.js application?
2. What is SMTP?
3. What are transactional emails?

**Core Topics:**
- SMTP protocol basics
- Email service providers (SendGrid, AWS SES, Mailgun, Resend)
- Email templates (HTML emails)
- Transactional vs marketing emails
- Email deliverability basics

**Resources:**
- [Nodemailer Documentation](https://nodemailer.com/) (15 min)
- [SendGrid Node.js Quickstart](https://docs.sendgrid.com/for-developers/sending-email/quickstart-nodejs) (15 min)

**Setup:**
```bash
npm install @nestjs-modules/mailer nodemailer handlebars
# Create free SendGrid or Resend account
```

**Exercises:**
1. Set up email service with Nodemailer
2. Configure SMTP credentials from SendGrid/Resend
3. Send plain text email
4. Send HTML email with basic styling
5. Create email template with Handlebars
6. Test email sending in development (use Mailtrap or similar)

**Practice Problems:**
- Problem 1: Create EmailService with `sendEmail(to, subject, body)` method
- Problem 2: Send welcome email when user registers
- Problem 3: Create HTML email template for welcome email
- Problem 4: Send password reset email with reset link
- Problem 5: Add email sending to background job (don't block requests)

**Hints:**
- Use environment variables for SMTP credentials
- Always send emails in background jobs
- Use Mailtrap.io for testing emails in development

#### Session 2: Email Templates & Styling (50 min)
**Topics:** HTML email templates, inline CSS, responsive emails

**Exercises:**
1. Create reusable email layout template
2. Design welcome email with logo and branding
3. Add inline CSS (email clients don't support external CSS)
4. Create responsive email (mobile-friendly)
5. Add "View in browser" link
6. Implement unsubscribe link

**Practice Problems:**
- Problem 1: Create email template for "New comment on your post" notification
- Problem 2: Design email template for weekly digest (list of new posts)
- Problem 3: Add email header/footer with branding
- Problem 4: Create password reset email with styled button
- Problem 5: Test emails across different email clients (Gmail, Outlook, Apple Mail)

**Hints:**
- Use tables for layout (old-school but works in all email clients)
- Inline all CSS (use tools like juice or preprocessors)
- Keep emails under 102KB to avoid Gmail clipping

**Commit:** `Day 72: Email service integration and templates`

---

### Wednesday, Mar 12 - Day 73
**Topic:** Email Integration - Part 2
**Sessions:** 2

#### Session 1: Advanced Email Features (50 min)
**Pre-Session Questions:**
1. How do you track email opens?
2. What are email attachments?
3. How do you handle email bounces?

**Core Topics:**
- Email tracking (opens, clicks)
- Attachments
- Email webhooks (delivery status, bounces, complaints)
- Batch email sending
- Email analytics

**Resources:**
- [SendGrid Event Webhook](https://docs.sendgrid.com/for-developers/tracking-events/event) (15 min)

**Exercises:**
1. Add attachment support (PDF invoices, reports)
2. Implement email open tracking (invisible pixel)
3. Add click tracking for links in emails
4. Set up webhook endpoint for email events
5. Handle bounce and complaint notifications
6. Store email sending history in database

**Practice Problems:**
- Problem 1: Send post summary as PDF attachment
- Problem 2: Track email opens (when user opens email)
- Problem 3: Track link clicks in emails
- Problem 4: Create webhook handler for email delivery status
- Problem 5: Mark user email as invalid if bounced

**Hints:**
- Use 1x1 transparent GIF for open tracking
- Replace links with tracking URLs
- Store email events for analytics

#### Session 2: Email Automation (50 min)
**Topics:** Scheduled emails, drip campaigns, email preferences

**Exercises:**
1. Schedule daily digest email (cron job)
2. Implement drip campaign (welcome series: day 1, day 3, day 7 emails)
3. Add email preferences (user can opt out of certain email types)
4. Create email queue with retry logic
5. Implement email rate limiting (don't spam users)
6. Add email unsubscribe functionality

**Practice Problems:**
- Problem 1: Create daily digest email sent every morning with new posts
- Problem 2: Implement 3-email welcome sequence (sent on days 0, 3, 7)
- Problem 3: Add user email preferences (notifications, marketing, digests)
- Problem 4: Respect unsubscribe requests (don't send marketing emails)
- Problem 5: Implement "1 email per day max" rule to avoid spam

**Hints:**
- Use background jobs with delays for drip campaigns
- Store email preferences in user table
- Always include unsubscribe link in marketing emails

**Commit:** `Day 73: Advanced email features and automation`

---

### Thursday, Mar 13 - Day 74
**Topic:** Logging & Monitoring - Part 1
**Sessions:** 2

#### Session 1: Structured Logging (50 min)
**Pre-Session Questions:**
1. Why is logging important in production?
2. What information should you log?
3. What's the difference between console.log and proper logging?

**Core Topics:**
- Log levels (debug, info, warn, error, fatal)
- Structured logging (JSON format)
- Contextual logging (request ID, user ID)
- Log aggregation
- Log retention and rotation

**Resources:**
- [Winston Documentation](https://github.com/winstonjs/winston) (15 min)
- [NestJS Logger](https://docs.nestjs.com/techniques/logger) (10 min)

**Setup:**
```bash
npm install winston nest-winston
```

**Exercises:**
1. Replace console.log with Winston logger
2. Configure log levels for different environments (debug in dev, info in prod)
3. Add structured logging with JSON format
4. Include request ID in all logs
5. Log HTTP requests and responses
6. Save logs to files (daily rotation)

**Practice Problems:**
- Problem 1: Create logger service with Winston
- Problem 2: Add request ID to all logs in a request context
- Problem 3: Log all API requests (method, path, status, duration)
- Problem 4: Log errors with full stack traces
- Problem 5: Implement log file rotation (new file daily, keep 14 days)

**Hints:**
- Use middleware to generate and attach request ID
- Log objects, not strings: `logger.info({ userId, action: 'post_created' })`
- Never log sensitive data (passwords, tokens)

#### Session 2: Error Tracking & Monitoring (50 min)
**Topics:** Error tracking services, alerting, performance monitoring

**Resources:**
- [Sentry Node.js Documentation](https://docs.sentry.io/platforms/node/) (20 min)

**Setup:**
```bash
npm install @sentry/node
# Create free Sentry account
```

**Exercises:**
1. Integrate Sentry for error tracking
2. Capture exceptions automatically
3. Add contextual data to error reports (user, request)
4. Create custom error tracking for business logic errors
5. Set up Sentry source maps for better stack traces
6. Test error alerting

**Practice Problems:**
- Problem 1: Configure Sentry in NestJS
- Problem 2: Capture unhandled exceptions
- Problem 3: Add user context to Sentry errors
- Problem 4: Track custom events (e.g., "Payment failed")
- Problem 5: Set up Sentry alerts for critical errors

**Hints:**
- Sentry automatically captures unhandled errors
- Add breadcrumbs for debugging (user actions before error)
- Set up alerting rules (notify on new errors)

**Commit:** `Day 74: Structured logging and error tracking`

---

### Friday, Mar 14 - Day 75
**Topic:** Logging & Monitoring - Part 2
**Sessions:** 2

#### Session 1: Application Metrics (50 min)
**Pre-Session Questions:**
1. What metrics should you track in a backend API?
2. How do you monitor API performance?
3. What is APM (Application Performance Monitoring)?

**Core Topics:**
- Application metrics (requests/sec, latency, error rate)
- Custom business metrics
- Health checks
- Prometheus integration
- Grafana dashboards

**Resources:**
- [Prometheus Node.js Client](https://github.com/siimon/prom-client) (15 min)
- [NestJS Health Checks](https://docs.nestjs.com/recipes/terminus) (10 min)

**Setup:**
```bash
npm install @nestjs/terminus prom-client
```

**Exercises:**
1. Add Prometheus metrics endpoint (`/metrics`)
2. Track HTTP request count by endpoint and status
3. Track request duration (latency)
4. Track active connections
5. Add custom metric: posts created per hour
6. Create health check endpoint

**Practice Problems:**
- Problem 1: Expose `/metrics` endpoint with Prometheus format
- Problem 2: Track requests per second by endpoint
- Problem 3: Track P95 latency (95th percentile response time)
- Problem 4: Add custom counter for posts created
- Problem 5: Create `/health` endpoint (check DB, Redis, external services)

**Hints:**
- Use histogram for latency tracking
- Use counter for event counts
- Use gauge for current values (active connections)

#### Session 2: Monitoring Dashboard (50 min)
**Topics:** Metrics visualization, alerting rules, SLIs/SLOs

**Exercises:**
1. Set up Grafana with Docker
2. Connect Grafana to Prometheus
3. Create dashboard for API metrics (requests, errors, latency)
4. Add database connection pool metrics
5. Create alert rule for high error rate (>5%)
6. Implement uptime monitoring

**Practice Problems:**
- Problem 1: Create Grafana dashboard with key API metrics
- Problem 2: Add panel for request rate over time
- Problem 3: Add panel for error rate by endpoint
- Problem 4: Create alert for P95 latency >500ms
- Problem 5: Add business metrics dashboard (posts created, users registered)

**Hints:**
- Use Prometheus query language (PromQL) for complex queries
- Set up alerts for actionable metrics only
- Start with RED metrics: Rate, Errors, Duration

**Commit:** `Day 75: Application metrics and monitoring dashboard`

---

### Saturday, Mar 15 - Day 76
**Topic:** Complete Blog API - Advanced Features Part 1
**Sessions:** 2

#### Session 1: Full-Text Search (50 min)
**Pre-Session Questions:**
1. What's the difference between SQL LIKE and full-text search?
2. How does PostgreSQL full-text search work?
3. When would you use Elasticsearch instead of PostgreSQL search?

**Core Topics:**
- PostgreSQL full-text search
- Search indexing and ranking
- Search highlighting
- Fuzzy search and typo tolerance

**Resources:**
- [PostgreSQL Full-Text Search](https://www.postgresql.org/docs/current/textsearch.html) (20 min)

**Exercises:**
1. Add full-text search to posts (title + content)
2. Create GIN index for faster search
3. Implement search ranking (relevance scoring)
4. Add search result highlighting
5. Implement autocomplete for search
6. Add search filters (by category, date range)

**Practice Problems:**
- Problem 1: Search posts by keywords in title or content
- Problem 2: Rank results by relevance (title matches higher than content)
- Problem 3: Highlight matched keywords in results
- Problem 4: Implement "did you mean?" suggestions for misspellings
- Problem 5: Add faceted search (filter by category while searching)

**Hints:**
- Use `to_tsvector` and `to_tsquery` for full-text search
- Create GIN index on tsvector column for performance
- Use `ts_rank` for relevance scoring

#### Session 2: Advanced Filtering & Sorting (50 min)
**Topics:** Complex queries, dynamic filtering, cursor pagination

**Exercises:**
1. Implement dynamic filtering (any combination of filters)
2. Add multiple sort options (date, popularity, relevance)
3. Implement cursor-based pagination for better performance
4. Add tag-based filtering (posts with tags: javascript AND typescript)
5. Implement "related posts" recommendation
6. Add trending posts algorithm (views + recency)

**Practice Problems:**
- Problem 1: Allow filtering by multiple criteria simultaneously (category, tags, date range, author)
- Problem 2: Implement cursor pagination (better than offset for large datasets)
- Problem 3: Create trending posts algorithm (high views in last 7 days)
- Problem 4: Implement "related posts" based on shared tags
- Problem 5: Add sort by multiple fields (date DESC, views DESC)

**Hints:**
- Build query dynamically based on provided filters
- Use cursor pagination for infinite scroll
- Cache trending posts calculation

**Commit:** `Day 76: Full-text search and advanced filtering`

---

### Sunday, Mar 16 - Day 77
**Topic:** Complete Blog API - Advanced Features Part 2
**Sessions:** 2

#### Session 1: Social Features (50 min)
**Pre-Session Questions:**
1. How do you implement a follow system?
2. What's the best way to store likes/favorites?
3. How do you build a personalized feed?

**Core Topics:**
- Follow/follower relationships
- Like/favorite system
- Bookmarks
- Personalized feed algorithms
- Social graph queries

**Exercises:**
1. Implement user follow/unfollow functionality
2. Add followers/following count to user profile
3. Implement like/unlike for posts
4. Add bookmark functionality
5. Create personalized feed (posts from followed users)
6. Implement "suggested users to follow"

**Practice Problems:**
- Problem 1: Create follow system (user can follow other users)
- Problem 2: Get user's followers and following lists
- Problem 3: Implement like/unlike with like count
- Problem 4: Create personalized feed (posts from people you follow, sorted by recency)
- Problem 5: Suggest users to follow (based on mutual connections or similar interests)

**Hints:**
- Use junction table for follows (follower_id, following_id)
- Denormalize counts for performance (follower_count column)
- Cache personalized feed generation

#### Session 2: Engagement & Analytics (50 min)
**Topics:** View tracking, reading time, engagement metrics, user analytics

**Exercises:**
1. Track post views (unique and total)
2. Calculate and store reading time for posts
3. Track user engagement (time spent on post)
4. Implement view history for users
5. Add "popular posts" based on engagement
6. Create user analytics dashboard

**Practice Problems:**
- Problem 1: Track post views (increment view count, track unique views)
- Problem 2: Calculate estimated reading time based on word count
- Problem 3: Track which posts a user has viewed (history)
- Problem 4: Implement "trending now" (high engagement in last 24h)
- Problem 5: Create analytics: views over time, top posts, engagement rate

**Hints:**
- Use Redis for real-time view counting
- Calculate reading time: word_count / 200 words per minute
- Aggregate analytics data periodically (don't calculate on every request)

**Commit:** `Day 77: Social features and engagement tracking`

---

### Monday, Mar 17 - Day 78
**Topic:** Complete Blog API - Advanced Features Part 3
**Sessions:** 2

#### Session 1: Content Moderation (50 min)
**Pre-Session Questions:**
1. Why do you need content moderation?
2. How can you detect inappropriate content?
3. What is a content review workflow?

**Core Topics:**
- Content moderation workflows
- Automated moderation (profanity filter, spam detection)
- Manual review queue
- User reporting system
- Moderation actions (flag, hide, delete, ban)

**Exercises:**
1. Implement user reporting (report post/comment as spam/inappropriate)
2. Create moderation queue for admins
3. Add content flagging system
4. Implement profanity filter for posts/comments
5. Add automatic spam detection
6. Create moderation action log

**Practice Problems:**
- Problem 1: Allow users to report posts/comments
- Problem 2: Create admin moderation queue showing reported content
- Problem 3: Implement approve/reject actions for reported content
- Problem 4: Add profanity filter (block or replace bad words)
- Problem 5: Automatically flag posts with suspicious patterns (spam links, excessive caps)

**Hints:**
- Use enum for report reasons (spam, harassment, inappropriate, etc.)
- Store moderation history for audit trail
- Use third-party APIs for advanced content moderation (AWS Rekognition, Perspective API)

#### Session 2: Notifications System (50 min)
**Topics:** In-app notifications, notification preferences, notification center

**Exercises:**
1. Create notifications table and model
2. Implement notification creation for various events
3. Add notification types (comment, like, follow, mention)
4. Create "get unread notifications" endpoint
5. Implement mark as read functionality
6. Add notification preferences (user can opt out)

**Practice Problems:**
- Problem 1: Send notification when someone comments on your post
- Problem 2: Send notification when someone likes your post
- Problem 3: Send notification when someone follows you
- Problem 4: Implement @mentions (notify user when mentioned in comment)
- Problem 5: Create notification center endpoint (list all notifications with unread count)

**Hints:**
- Use WebSockets to push real-time notifications
- Batch notification creation (don't create notification for every like from same user)
- Respect user notification preferences

**Commit:** `Day 78: Content moderation and notifications`

---

### Tuesday, Mar 18 - Day 79
**Topic:** Complete Blog API - Performance Optimization
**Sessions:** 2

#### Session 1: Database Optimization (50 min)
**Pre-Session Questions:**
1. How do you identify slow database queries?
2. What is query planning?
3. When should you denormalize data?

**Core Topics:**
- Query optimization techniques
- Index optimization
- N+1 query problem solutions
- Denormalization strategies
- Database connection pooling

**Exercises:**
1. Enable query logging and find slow queries
2. Use EXPLAIN ANALYZE to understand query plans
3. Add missing indexes based on query patterns
4. Solve N+1 problems with eager loading
5. Denormalize frequently accessed counts
6. Optimize connection pool settings

**Practice Problems:**
- Problem 1: Find and fix the 5 slowest queries in your API
- Problem 2: Add indexes for common query patterns
- Problem 3: Solve N+1 problem when loading posts with authors and comments
- Problem 4: Denormalize post like_count and comment_count for faster queries
- Problem 5: Implement database query caching for expensive queries

**Hints:**
- Use Prisma's `include` and `select` carefully to avoid over-fetching
- Add composite indexes for multi-column WHERE clauses
- Monitor query execution time in production

#### Session 2: API Performance Optimization (50 min)
**Topics:** Response time optimization, payload optimization, compression

**Exercises:**
1. Implement response compression (gzip)
2. Optimize JSON payload size (remove unnecessary fields)
3. Add ETag caching for GET requests
4. Implement response streaming for large datasets
5. Add HTTP/2 support
6. Optimize image serving (proper sizes, WebP format)

**Practice Problems:**
- Problem 1: Enable gzip compression for all responses
- Problem 2: Implement ETag caching (return 304 Not Modified when content unchanged)
- Problem 3: Reduce API response size by 50% (remove unnecessary data, use pagination)
- Problem 4: Implement streaming for large list endpoints
- Problem 5: Set proper cache headers (Cache-Control, max-age)

**Hints:**
- Use compression middleware
- Calculate ETags based on content hash
- Set aggressive caching for static content, short TTL for dynamic

**Commit:** `Day 79: Performance optimization`

---

### Wednesday, Mar 19 - Day 80
**Topic:** Complete Blog API - Production Hardening
**Sessions:** 2

#### Session 1: Security Hardening (50 min)
**Pre-Session Questions:**
1. What are common API security vulnerabilities?
2. How do you protect against SQL injection?
3. What is CORS and why is it important?

**Core Topics:**
- Security best practices
- Input validation and sanitization
- SQL injection prevention
- XSS protection
- CORS configuration
- Security headers

**Exercises:**
1. Add Helmet.js for security headers
2. Configure CORS properly (allow specific origins only)
3. Implement input sanitization (strip HTML tags)
4. Add rate limiting per user (prevent abuse)
5. Implement CSRF protection
6. Add security audit with npm audit

**Practice Problems:**
- Problem 1: Configure Helmet.js with appropriate security headers
- Problem 2: Set up CORS to allow only your frontend domain
- Problem 3: Sanitize user input (remove script tags, validate data types)
- Problem 4: Implement per-user rate limiting (stricter than global)
- Problem 5: Add API key authentication for admin endpoints

**Hints:**
- Never trust client input, always validate on server
- Use Prisma's parameterized queries (prevents SQL injection)
- Set Content-Security-Policy header

#### Session 2: Deployment Preparation (50 min)
**Topics:** Environment configuration, secrets management, health checks, graceful shutdown

**Exercises:**
1. Externalize all configuration to environment variables
2. Implement secrets management (don't commit secrets)
3. Add comprehensive health check (database, Redis, S3)
4. Implement graceful shutdown (finish ongoing requests before exit)
5. Add process manager configuration (PM2)
6. Create deployment checklist

**Practice Problems:**
- Problem 1: Move all secrets to environment variables (never hardcode)
- Problem 2: Implement `/health` endpoint checking all dependencies
- Problem 3: Add graceful shutdown (SIGTERM handler)
- Problem 4: Create PM2 configuration for process management
- Problem 5: Write deployment documentation (environment variables, setup steps)

**Hints:**
- Use dotenv for local development, proper secrets management in production
- Health check should return 503 if any critical service is down
- Graceful shutdown: stop accepting new requests, finish existing, then exit

**Commit:** `Day 80: Security hardening and production preparation`

---

### Thursday, Mar 20 - Day 81
**Topic:** API Testing & Quality Assurance - Part 1
**Sessions:** 2

#### Session 1: Integration Testing Best Practices (50 min)
**Pre-Session Questions:**
1. What's the difference between unit tests and integration tests?
2. How do you test database interactions?
3. What is test coverage and why does it matter?

**Core Topics:**
- Integration testing strategies
- Test database setup
- Test fixtures and factories
- Mocking external services
- Test coverage analysis

**Exercises:**
1. Set up separate test database
2. Create test fixtures for users and posts
3. Write integration tests for all post endpoints
4. Mock external services (S3, email) in tests
5. Generate test coverage report
6. Add test coverage to CI/CD

**Practice Problems:**
- Problem 1: Write integration tests for complete post CRUD workflow
- Problem 2: Test authentication middleware (authorized vs unauthorized)
- Problem 3: Test pagination, filtering, and sorting
- Problem 4: Test error cases (404, 400, 401, 403)
- Problem 5: Achieve 80%+ test coverage for all services

**Hints:**
- Reset test database before each test suite
- Use factories for test data (don't hardcode)
- Mock external API calls (don't hit real S3/email in tests)

#### Session 2: E2E Testing (50 min)
**Topics:** End-to-end test flows, test scenarios, smoke tests

**Exercises:**
1. Create E2E test for user registration â†’ login â†’ create post flow
2. Test complete comment workflow
3. Test file upload flow
4. Test search functionality
5. Create smoke test suite (critical paths only)
6. Add E2E tests to CI/CD

**Practice Problems:**
- Problem 1: E2E test: register â†’ verify email â†’ login â†’ create post â†’ logout
- Problem 2: E2E test: user A creates post â†’ user B comments â†’ user A gets notification
- Problem 3: E2E test: search for posts â†’ filter by category â†’ sort by date
- Problem 4: E2E test: upload image â†’ create post with image â†’ verify image URL works
- Problem 5: Create smoke test suite that runs in <2 minutes

**Hints:**
- E2E tests should test complete user journeys
- Keep E2E tests focused on critical paths (don't test everything)
- Run E2E tests against isolated test environment

**Commit:** `Day 81: Comprehensive integration and E2E testing`

---

### Friday, Mar 21 - Day 82
**Topic:** API Testing & Quality Assurance - Part 2
**Sessions:** 2

#### Session 1: Load Testing (50 min)
**Pre-Session Questions:**
1. Why do you need load testing?
2. What metrics matter in load testing?
3. How many concurrent users can your API handle?

**Core Topics:**
- Load testing fundamentals
- k6 or Artillery for load testing
- Performance benchmarks
- Bottleneck identification
- Scalability testing

**Resources:**
- [k6 Documentation](https://k6.io/docs/) (20 min)

**Setup:**
```bash
npm install -g k6
```

**Exercises:**
1. Write load test script for GET /posts endpoint
2. Test with 10, 50, 100, 500 concurrent users
3. Measure throughput (requests/second)
4. Measure latency (P50, P95, P99)
5. Identify breaking point (when API starts failing)
6. Find and fix performance bottlenecks

**Practice Problems:**
- Problem 1: Load test GET /posts with 100 concurrent users for 1 minute
- Problem 2: Load test POST /posts with authentication
- Problem 3: Find maximum throughput (req/sec before errors)
- Problem 4: Measure P95 latency under normal load
- Problem 5: Test behavior under spike load (sudden 10x traffic)

**Hints:**
- Start with low load and gradually increase
- Monitor database connections, CPU, memory during load test
- Optimize based on bottlenecks found (usually database or cache)

#### Session 2: API Documentation & Contract Testing (50 min)
**Topics:** OpenAPI contract testing, API versioning, breaking changes

**Exercises:**
1. Export OpenAPI spec from Swagger
2. Write contract tests (validate API matches OpenAPI spec)
3. Test for breaking changes in API
4. Document API versioning strategy
5. Create API migration guides
6. Test backward compatibility

**Practice Problems:**
- Problem 1: Generate OpenAPI JSON from Swagger
- Problem 2: Write tests that validate responses match OpenAPI schema
- Problem 3: Test that adding new optional field doesn't break existing clients
- Problem 4: Document how to handle breaking changes (versioning strategy)
- Problem 5: Create migration guide for API v1 â†’ v2

**Hints:**
- Use tools like Spectral for OpenAPI spec validation
- Never remove fields in existing API (add new version instead)
- Document all breaking changes clearly

**Commit:** `Day 82: Load testing and contract testing`

---

### Saturday, Mar 22 - Day 83
**Topic:** Advanced Architecture Patterns
**Sessions:** 2

#### Session 1: Clean Architecture & Domain-Driven Design (50 min)
**Pre-Session Questions:**
1. What is Clean Architecture?
2. What is Domain-Driven Design?
3. How do you organize code for maintainability?

**Core Topics:**
- Clean Architecture principles
- Domain-Driven Design basics
- Separation of concerns
- Dependency injection patterns
- Repository pattern

**Resources:**
- [Clean Architecture by Robert Martin](https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html) (20 min)
- [Domain-Driven Design](https://martinfowler.com/bliki/DomainDrivenDesign.html) (15 min)

**Exercises:**
1. Refactor blog API to use repository pattern
2. Separate domain logic from HTTP layer
3. Create value objects for domain concepts
4. Implement use cases/application services
5. Add domain events
6. Implement domain validation

**Practice Problems:**
- Problem 1: Create repository interfaces and implementations
- Problem 2: Extract business logic from controllers to use cases/services
- Problem 3: Create value objects (Email, PostId, etc.)
- Problem 4: Implement domain events (PostCreated, UserFollowed)
- Problem 5: Add domain validation (business rules) separate from input validation

**Hints:**
- Controllers should be thin (just HTTP handling)
- Business logic belongs in domain services/use cases
- Use dependency injection for loose coupling

#### Session 2: CQRS & Event Sourcing Introduction (50 min)
**Topics:** Command Query Responsibility Segregation, Event Sourcing basics

**Exercises:**
1. Separate read and write models
2. Implement command handlers (write operations)
3. Implement query handlers (read operations)
4. Create event store for audit trail
5. Implement event replay
6. Add read model projections

**Practice Problems:**
- Problem 1: Split post creation (command) and post retrieval (query) into separate handlers
- Problem 2: Store all domain events in event store
- Problem 3: Create read model optimized for queries (denormalized)
- Problem 4: Implement event replay to rebuild read model from events
- Problem 5: Add temporal queries (what was state at specific point in time)

**Hints:**
- CQRS is useful when read and write patterns are very different
- Event Sourcing stores events, not current state
- Read models can be rebuilt from events

**Commit:** `Day 83: Clean architecture and CQRS patterns`

---

### Sunday, Mar 23 - Day 84
**Topic:** API Versioning & Evolution
**Sessions:** 2

#### Session 1: API Versioning Strategies (50 min)
**Pre-Session Questions:**
1. Why do APIs need versioning?
2. What are different versioning strategies?
3. How do you avoid breaking existing clients?

**Core Topics:**
- API versioning strategies (URL, header, content negotiation)
- Semantic versioning for APIs
- Deprecation policies
- Backward compatibility
- Forward compatibility

**Resources:**
- [API Versioning Best Practices](https://swagger.io/blog/api-strategy/api-versioning-best-practices/) (15 min)

**Exercises:**
1. Implement URL-based versioning (/v1/posts, /v2/posts)
2. Support multiple API versions simultaneously
3. Add deprecation warnings to old endpoints
4. Create v2 with breaking change (different response format)
5. Maintain v1 compatibility while adding v2
6. Document migration path from v1 to v2

**Practice Problems:**
- Problem 1: Add `/v1` prefix to all existing routes
- Problem 2: Create `/v2/posts` with different response structure
- Problem 3: Support both v1 and v2 simultaneously
- Problem 4: Add deprecation header to v1 endpoints
- Problem 5: Create automated tests for both versions

**Hints:**
- Use versioning from day one (easier to add initially)
- Support at least 2 versions simultaneously
- Give clients 6-12 months to migrate

#### Session 2: API Evolution & Sunset (50 min)
**Topics:** Adding features without breaking changes, deprecation process, API sunset

**Exercises:**
1. Add new optional field without breaking changes
2. Add new endpoint while keeping old one
3. Implement feature flags for gradual rollout
4. Create deprecation schedule
5. Monitor deprecated endpoint usage
6. Sunset old API version gracefully

**Practice Problems:**
- Problem 1: Add new optional field `readingTimeMinutes` to post response
- Problem 2: Add new endpoint `/posts/trending` without affecting existing endpoints
- Problem 3: Use feature flags to test new features with subset of users
- Problem 4: Create deprecation notice (6 months before removal)
- Problem 5: Monitor v1 API usage and notify remaining clients

**Hints:**
- Always additive changes when possible (new fields, new endpoints)
- Use feature flags for risky changes
- Communicate deprecations early and clearly

**Commit:** `Day 84: API versioning and evolution strategies`

---

### Monday, Mar 24 - Day 85
**Topic:** Production Deployment & DevOps Basics
**Sessions:** 2

#### Session 1: Containerization & Docker Compose (50 min)
**Pre-Session Questions:**
1. Why containerize your application?
2. What's the difference between development and production Docker images?
3. How do you orchestrate multiple containers?

**Core Topics:**
- Production-ready Dockerfile
- Multi-stage builds
- Docker Compose for full stack
- Environment-specific configurations
- Container health checks

**Exercises:**
1. Create production Dockerfile (multi-stage, optimized)
2. Create Docker Compose with app + PostgreSQL + Redis
3. Add health checks to containers
4. Configure environment variables
5. Set up volumes for data persistence
6. Implement container restart policies

**Practice Problems:**
- Problem 1: Build production Docker image < 200MB
- Problem 2: Create docker-compose.yml for local development (hot reload)
- Problem 3: Create docker-compose.prod.yml for production
- Problem 4: Add health check endpoint and container health check
- Problem 5: Configure proper resource limits (CPU, memory)

**Hints:**
- Use alpine base images for smaller size
- Copy only necessary files (use .dockerignore)
- Use multi-stage builds (build stage + runtime stage)

#### Session 2: CI/CD Pipeline Setup (50 min)
**Topics:** GitHub Actions, automated testing, automated deployment

**Setup:**
- Create GitHub repository for blog-api

**Exercises:**
1. Create GitHub Actions workflow for CI
2. Run tests automatically on every push
3. Add linting to CI pipeline
4. Build Docker image in CI
5. Push image to Docker registry
6. Add deployment workflow (CD)

**Practice Problems:**
- Problem 1: Create `.github/workflows/ci.yml` that runs tests on every push
- Problem 2: Add linting step (ESLint)
- Problem 3: Build Docker image and push to Docker Hub or GitHub Container Registry
- Problem 4: Deploy to staging environment automatically on main branch merge
- Problem 5: Add manual approval step for production deployment

**Hints:**
- Use caching in GitHub Actions to speed up builds
- Separate CI (test on every push) from CD (deploy on main)
- Use secrets for sensitive credentials

**Commit:** `Day 85: Containerization and CI/CD pipeline`

---

### Tuesday, Mar 25 - Day 86
**Topic:** Production Deployment - Cloud Platforms
**Sessions:** 2

#### Session 1: Deploy to Cloud Platform (50 min)
**Pre-Session Questions:**
1. What cloud platforms can host Node.js applications?
2. What's the difference between VPS and PaaS?
3. How do you configure production environment variables?

**Core Topics:**
- Cloud platform options (Render, Railway, Fly.io, AWS, DigitalOcean)
- Platform-as-a-Service (PaaS) deployment
- Environment configuration
- Database hosting (managed PostgreSQL)
- Redis hosting

**Resources:**
- [Render Deployment Guide](https://render.com/docs) (15 min)
- [Railway Deployment](https://docs.railway.app/) (15 min)

**Exercises:**
1. Deploy blog API to Render or Railway
2. Set up managed PostgreSQL database
3. Set up managed Redis instance
4. Configure environment variables in cloud dashboard
5. Connect to production database
6. Test production API endpoints

**Practice Problems:**
- Problem 1: Deploy blog-api to Render/Railway/Fly.io
- Problem 2: Provision managed PostgreSQL database
- Problem 3: Provision managed Redis instance
- Problem 4: Configure all environment variables in platform
- Problem 5: Run database migrations in production

**Hints:**
- Start with PaaS (easier) before VPS/Kubernetes
- Use managed databases (don't host PostgreSQL yourself initially)
- Set NODE_ENV=production

#### Session 2: Production Monitoring & Troubleshooting (50 min)
**Topics:** Log aggregation, error monitoring, uptime monitoring, alerting

**Exercises:**
1. Set up production logging (centralized logs)
2. Configure error tracking (Sentry in production)
3. Add uptime monitoring (UptimeRobot or similar)
4. Set up alerts for errors and downtime
5. Create production runbook (how to handle incidents)
6. Test incident response

**Practice Problems:**
- Problem 1: Configure production logs to be searchable
- Problem 2: Ensure all production errors are sent to Sentry
- Problem 3: Set up uptime monitoring with 5-minute checks
- Problem 4: Configure alerts (email/Slack) for critical errors
- Problem 5: Write runbook for common incidents (DB down, high latency, errors)

**Hints:**
- Use cloud platform's built-in logging when possible
- Set up alerts for actionable events only (avoid alert fatigue)
- Document troubleshooting steps

**Commit:** `Day 86: Cloud deployment and production monitoring`

---

### Wednesday, Mar 26 - Day 87
**Topic:** Blog API Complete & Production Ready
**Sessions:** 2

#### Session 1: Final Features & Polish (50 min)
**Pre-Session Questions:**
1. What features are missing from your blog API?
2. How do you know if your API is production-ready?
3. What documentation should you provide?

**Core Topics:**
- Feature completeness checklist
- API documentation completeness
- Error handling consistency
- Code quality and maintainability

**Exercises:**
1. Review and complete any missing features
2. Ensure all endpoints have proper error handling
3. Add request/response examples to all endpoints
4. Ensure consistent error response format
5. Add API rate limits documentation
6. Create comprehensive README.md

**Practice Problems:**
- Problem 1: Audit all endpoints for consistent error responses
- Problem 2: Document all environment variables required
- Problem 3: Create API usage examples for common workflows
- Problem 4: Add troubleshooting section to documentation
- Problem 5: Create architecture diagram showing all components

**Hints:**
- Use checklist to ensure nothing is missed
- Document for someone who has never seen your code
- Include setup instructions, API docs, architecture overview

#### Session 2: Production Readiness Review (50 min)
**Topics:** Security audit, performance review, disaster recovery

**Exercises:**
1. Run security audit (npm audit, snyk)
2. Fix all high/critical vulnerabilities
3. Review and fix performance bottlenecks
4. Implement database backup strategy
5. Create disaster recovery plan
6. Document rollback procedure

**Practice Problems:**
- Problem 1: Fix all npm audit vulnerabilities
- Problem 2: Ensure all endpoints respond in <200ms at P95
- Problem 3: Set up automated daily database backups
- Problem 4: Test backup restoration
- Problem 5: Document rollback process (how to deploy previous version)

**Hints:**
- Keep dependencies up to date
- Test disaster recovery procedures
- Document everything for future you

**Commit:** `Day 87: Blog API production-ready and complete!`

---

## ðŸŽ‰ PHASE 2 COMPLETE!

**You've finished Phase 2 (Days 46-87)! Achievements:**
- âœ… JWT authentication & authorization mastered
- âœ… Comprehensive testing skills (unit, integration, e2e)
- âœ… Docker & containerization proficient
- âœ… NestJS enterprise patterns
- âœ… Database optimization & transactions
- âœ… Production-ready backend development

**Key Projects Built:**
- Blog API with full authentication
- Task API rebuilt with NestJS best practices
- Multiple testing suites

**Ready for Phase 3: React & Frontend Development!**

---

# PHASE 3: REACT & FRONTEND MASTERY
## March 29 - May 7 (6 weeks, Days 88-128)

**Focus:** React fundamentals, hooks, state management, TypeScript + React

---

### Thursday, Mar 27 - Day 88
**Topic:** React Setup & JSX Fundamentals
**Sessions:** 2

#### Session 1: React Basics (50 min)
**Pre-Session Questions:**
1. What is React and why use it?
2. What is JSX?
3. What's the difference between React and vanilla JavaScript for DOM manipulation?

**Core Topics:**
- React introduction and mental model
- Virtual DOM concept
- JSX syntax and rules
- React vs vanilla JavaScript
- Create React App vs Vite

**Resources:**
- [React Official Tutorial](https://react.dev/learn) (30 min)
- [Vite Documentation](https://vitejs.dev/guide/) (10 min)

**Setup:**
```bash
npm create vite@latest blog-frontend -- --template react-ts
cd blog-frontend
npm install
npm run dev
```

**Exercises:**
1. Create React app with Vite + TypeScript
2. Explore project structure (src, public, index.html)
3. Create first component (HelloWorld)
4. Understand JSX (JavaScript in HTML)
5. Render component in App.tsx
6. Add basic styling with CSS

**Practice Problems:**
- Problem 1: Create `Greeting` component that displays "Hello, World!"
- Problem 2: Create `UserCard` component that displays name and email
- Problem 3: Create `Button` component with text and onClick (console.log for now)
- Problem 4: Create `Header` component with navigation links
- Problem 5: Compose multiple components in App.tsx

**Hints:**
- JSX must return single root element (use <></> fragment if needed)
- Use className instead of class
- Use camelCase for event handlers (onClick not onclick)

#### Session 2: Components & Props (50 min)
**Topics:** Props, component composition, props types

**Exercises:**
1. Pass props to components
2. Type props with TypeScript interfaces
3. Use props.children for composition
4. Create reusable Button component with variants
5. Implement conditional rendering based on props
6. Add default props

**Practice Problems:**
- Problem 1: Create `BlogPost` component that accepts title, author, content as props
- Problem 2: Type all props with TypeScript interfaces
- Problem 3: Create `Card` component that accepts children
- Problem 4: Create `Button` component with variant prop (primary, secondary, danger)
- Problem 5: Implement conditional rendering (show/hide based on isVisible prop)

**Hints:**
- Define props interface: `interface Props { title: string; }`
- Use destructuring: `({ title, author }: Props) =>`
- props.children has type React.ReactNode

**Commit:** `Day 88: React setup, JSX, components, and props`

---

### Friday, Mar 28 - Day 89
**Topic:** State with useState Hook
**Sessions:** 2

#### Session 1: useState Fundamentals (50 min)
**Pre-Session Questions:**
1. What is state in React?
2. How is state different from props?
3. What happens when state changes?

**Core Topics:**
- useState hook basics
- State updates and re-renders
- Multiple state variables
- State immutability
- Form inputs and controlled components

**Resources:**
- [React useState Hook](https://react.dev/reference/react/useState) (20 min)

**Exercises:**
1. Create counter with useState (increment/decrement buttons)
2. Create toggle button (show/hide content)
3. Handle text input with state
4. Create form with multiple inputs
5. Implement controlled vs uncontrolled components
6. Understand why state updates cause re-renders

**Practice Problems:**
- Problem 1: Create counter component (count starts at 0, buttons to +1 and -1)
- Problem 2: Create toggle component (button shows/hides text)
- Problem 3: Create input that displays typed text in real-time
- Problem 4: Create simple form (name, email inputs + submit button that logs state)
- Problem 5: Create character counter for textarea (show characters remaining out of 200)

**Hints:**
- useState returns `[value, setValue]` pair
- State updates are asynchronous
- Don't mutate state directly, always use setter function

#### Session 2: State Updates & Immutability (50 min)
**Topics:** Updating objects and arrays in state, functional updates

**Exercises:**
1. Update object state (user profile with multiple fields)
2. Update array state (todo list - add, remove, toggle)
3. Use functional updates for state that depends on previous state
4. Implement controlled form with object state
5. Create shopping cart (add/remove items)
6. Understand shallow vs deep copying

**Practice Problems:**
- Problem 1: Create user profile form that updates object state ({ name, email, bio })
- Problem 2: Create todo list (add todo, mark as complete, delete)
- Problem 3: Use functional update in counter: `setCount(prev => prev + 1)`
- Problem 4: Create shopping cart (add item, remove item, update quantity)
- Problem 5: Create task list with filter (show all, active, completed)

**Hints:**
- Spread operator for object updates: `setState({ ...state, field: newValue })`
- Array methods for state: `[...arr, newItem]`, `arr.filter(...)`, `arr.map(...)`
- Use functional updates when new state depends on old: `setState(prev => ...)`

**Commit:** `Day 89: useState hook and state management`

---

### Saturday, Mar 29 - Day 90
**Topic:** Lists, Keys, and Conditional Rendering
**Sessions:** 2

#### Session 1: Rendering Lists (50 min)
**Pre-Session Questions:**
1. How do you render arrays in React?
2. Why do list items need keys?
3. What makes a good key value?

**Core Topics:**
- Array.map() for rendering lists
- Keys and their importance
- List item components
- Rendering empty states
- Performance with large lists

**Resources:**
- [Rendering Lists](https://react.dev/learn/rendering-lists) (15 min)

**Exercises:**
1. Render array of strings as list
2. Render array of objects with proper keys
3. Extract list item into separate component
4. Handle empty lists (no items message)
5. Implement list with remove functionality
6. Create searchable list

**Practice Problems:**
- Problem 1: Render list of posts from array (title, author for each)
- Problem 2: Add unique key to each list item (use id, not array index)
- Problem 3: Extract PostItem component for each list item
- Problem 4: Show "No posts found" when array is empty
- Problem 5: Add search input to filter displayed posts

**Hints:**
- Always use .map() to render arrays
- Key should be unique and stable (preferably id from data)
- Don't use array index as key if list can be reordered/filtered

#### Session 2: Conditional Rendering (50 min)
**Topics:** if/else, ternary, &&, null rendering, switch cases

**Exercises:**
1. Show/hide components based on boolean state
2. Use ternary for inline conditionals
3. Use && for conditional rendering
4. Return null to render nothing
5. Use switch/case for multiple conditions
6. Implement loading states

**Practice Problems:**
- Problem 1: Show login button if not authenticated, profile if authenticated
- Problem 2: Use ternary: `{isLoading ? <Spinner /> : <Content />}`
- Problem 3: Use &&: `{error && <ErrorMessage />}`
- Problem 4: Show different UI based on user role (admin, user, guest)
- Problem 5: Create component with loading, error, and success states

**Hints:**
- Use ternary for if/else: `{condition ? <A /> : <B />}`
- Use && for if only: `{condition && <Component />}`
- Return null from component to render nothing
- Can use early return for cleaner code

**Commit:** `Day 90: Lists, keys, and conditional rendering`

---

### Sunday, Mar 30 - Day 91
**Topic:** Forms and Events
**Sessions:** 2

#### Session 1: Event Handling (50 min)
**Pre-Session Questions:**
1. How do you handle click events in React?
2. What is event delegation?
3. How do you prevent form submission default behavior?

**Core Topics:**
- Event handlers (onClick, onChange, onSubmit)
- Event object and preventDefault
- Passing arguments to event handlers
- Event delegation vs direct binding
- Synthetic events in React

**Resources:**
- [Responding to Events](https://react.dev/learn/responding-to-events) (15 min)

**Exercises:**
1. Handle button click events
2. Handle input onChange events
3. Prevent form default submission
4. Pass parameters to event handlers
5. Handle keyboard events (Enter key to submit)
6. Implement double-click handler

**Practice Problems:**
- Problem 1: Create button that logs message on click
- Problem 2: Create input that logs value on every change
- Problem 3: Create form that prevents default submit and logs data
- Problem 4: Create delete button that passes item id to handler
- Problem 5: Submit form on Enter key press

**Hints:**
- Event handlers: `onClick={() => handleClick()}`
- Access event object: `onChange={(e) => setValue(e.target.value)}`
- Prevent default: `e.preventDefault()`
- Pass args: `onClick={() => handleDelete(id)}`

#### Session 2: Form Validation (50 min)
**Topics:** Controlled components, validation, error messages, form submission

**Exercises:**
1. Create controlled form inputs
2. Implement client-side validation
3. Display field-level error messages
4. Disable submit button while invalid
5. Show validation errors on blur
6. Create reusable form input component

**Practice Problems:**
- Problem 1: Create login form with email and password validation
- Problem 2: Show error message if email is invalid format
- Problem 3: Show error if password is less than 8 characters
- Problem 4: Disable submit button if form has errors
- Problem 5: Show validation errors only after user touches field

**Hints:**
- Controlled input: `value={state}` + `onChange={...}`
- Validate on change or blur
- Store errors in state object: `{ email: 'Invalid email', password: '' }`
- Use HTML5 validation attributes as starting point

**Commit:** `Day 91: Events and form handling`

---

### Monday, Mar 31 - Day 92
**Topic:** useEffect Hook - Part 1
**Sessions:** 2

#### Session 1: useEffect Basics (50 min)
**Pre-Session Questions:**
1. What are side effects in React?
2. When does useEffect run?
3. What's the difference between componentDidMount and useEffect?

**Core Topics:**
- Side effects concept (API calls, timers, subscriptions)
- useEffect syntax and execution timing
- Dependency array
- Cleanup function
- Common use cases

**Resources:**
- [useEffect Hook](https://react.dev/reference/react/useEffect) (25 min)

**Exercises:**
1. Use useEffect to log on every render
2. Use useEffect with empty dependency array (runs once)
3. Use useEffect with dependencies (runs when deps change)
4. Set document title based on state
5. Add cleanup function for timer
6. Fetch data on component mount

**Practice Problems:**
- Problem 1: Log "Component mounted" once when component appears
- Problem 2: Update document title with current count value
- Problem 3: Create timer that increments counter every second
- Problem 4: Cleanup timer when component unmounts
- Problem 5: Fetch fake data from JSONPlaceholder API on mount

**Hints:**
- Empty deps `[]`: runs once on mount
- No deps: runs after every render (usually not what you want)
- Deps `[count]`: runs when count changes
- Return cleanup function to prevent memory leaks

#### Session 2: Data Fetching with useEffect (50 min)
**Topics:** API calls, loading states, error handling, cleanup

**Exercises:**
1. Fetch data from API on component mount
2. Add loading state while fetching
3. Handle errors and display error message
4. Clean up fetch on unmount (abort controller)
5. Refetch data when dependency changes
6. Handle race conditions

**Practice Problems:**
- Problem 1: Fetch list of posts from JSONPlaceholder API
- Problem 2: Show loading spinner while fetching
- Problem 3: Display error message if fetch fails
- Problem 4: Use AbortController to cancel fetch on unmount
- Problem 5: Fetch user posts when userId prop changes

**Hints:**
- Use async/await inside useEffect (create async function inside)
- Set loading: true before fetch, false after
- Use try/catch for error handling
- AbortController for cleanup: `fetch(url, { signal })`

**Commit:** `Day 92: useEffect hook basics and data fetching`

---

### Tuesday, Apr 1 - Day 93
**Topic:** useEffect Hook - Part 2
**Sessions:** 2

#### Session 1: Advanced useEffect Patterns (50 min)
**Pre-Session Questions:**
1. What are effect dependencies?
2. How do you handle multiple useEffects?
3. What is the cleanup function for?

**Core Topics:**
- Dependency array deep dive
- Multiple effects organization
- Effect cleanup patterns
- Common pitfalls (infinite loops, missing deps)
- ESLint exhaustive-deps rule

**Resources:**
- [You Might Not Need an Effect](https://react.dev/learn/you-might-not-need-an-effect) (20 min)

**Exercises:**
1. Split multiple side effects into separate useEffects
2. Avoid infinite loops (wrong dependencies)
3. Use cleanup for event listeners
4. Use cleanup for subscriptions
5. Implement debounced search with useEffect
6. Handle localStorage sync with useEffect

**Practice Problems:**
- Problem 1: Add window resize event listener with cleanup
- Problem 2: Implement search that fetches results as you type (debounced)
- Problem 3: Sync state to localStorage automatically
- Problem 4: Set up WebSocket connection with cleanup
- Problem 5: Create custom timer hook with useEffect

**Hints:**
- One effect per concern (don't mix unrelated side effects)
- Always clean up subscriptions/listeners/timers
- Use debounce for search: delay fetch until user stops typing
- ESLint will warn about missing dependencies (usually fix by adding them)

#### Session 2: Effect Performance & Optimization (50 min)
**Topics:** Unnecessary effects, derived state, performance optimization

**Exercises:**
1. Identify when you don't need useEffect
2. Use derived state instead of effects
3. Optimize expensive computations
4. Avoid unnecessary re-renders from effects
5. Use refs for values that don't trigger re-renders
6. Implement efficient data synchronization

**Practice Problems:**
- Problem 1: Replace effect with derived state (fullName = firstName + lastName)
- Problem 2: Calculate filtered list directly instead of using effect
- Problem 3: Only run effect when specific field changes, not all state
- Problem 4: Use useRef to store value without causing re-render
- Problem 5: Batch multiple state updates to avoid multiple effects

**Hints:**
- If you can calculate value from props/state, don't use effect
- Derived values: `const filtered = items.filter(...)`  no effect needed
- Be specific with dependencies (include only what matters)

**Commit:** `Day 93: Advanced useEffect patterns and optimization`

---

### Wednesday, Apr 2 - Day 94
**Topic:** Custom Hooks
**Sessions:** 2

#### Session 1: Creating Custom Hooks (50 min)
**Pre-Session Questions:**
1. What is a custom hook?
2. Why extract logic into custom hooks?
3. What are the rules of hooks?

**Core Topics:**
- Custom hooks concept (sharing logic)
- Naming convention (must start with "use")
- Rules of hooks
- When to create custom hooks
- Composition with built-in hooks

**Resources:**
- [Reusing Logic with Custom Hooks](https://react.dev/learn/reusing-logic-with-custom-hooks) (20 min)

**Exercises:**
1. Create useLocalStorage hook
2. Create useToggle hook
3. Create useDebounce hook
4. Create useWindowSize hook
5. Create usePrevious hook
6. Compose multiple hooks in custom hook

**Practice Problems:**
- Problem 1: Create `useLocalStorage(key, initialValue)` hook (get/set localStorage)
- Problem 2: Create `useToggle(initialValue)` hook (returns [value, toggle])
- Problem 3: Create `useDebounce(value, delay)` hook (returns debounced value)
- Problem 4: Create `useWindowSize()` hook (returns window width/height)
- Problem 5: Create `usePrevious(value)` hook (returns previous render's value)

**Hints:**
- Custom hooks are just functions that use other hooks
- Must start with "use" (convention + linter requirement)
- Can return anything (value, array, object)
- Extract repeated logic into custom hooks

#### Session 2: Advanced Custom Hooks (50 min)
**Topics:** Complex custom hooks, API hooks, form hooks

**Exercises:**
1. Create useFetch hook for API calls
2. Create useForm hook for form state management
3. Create useAsync hook for async operations
4. Create useOnClickOutside hook
5. Create useInterval hook
6. Combine multiple hooks into feature hook

**Practice Problems:**
- Problem 1: Create `useFetch(url)` hook that returns { data, loading, error }
- Problem 2: Create `useForm(initialValues)` hook for form state and validation
- Problem 3: Create `useAsync(asyncFunction)` hook with execute function
- Problem 4: Create `useOnClickOutside(ref, handler)` hook for modals/dropdowns
- Problem 5: Create `useBlogPosts()` hook that fetches and manages blog posts

**Hints:**
- Hooks can use other hooks (useEffect, useState, etc.)
- Return intuitive interface (what would you want as consumer?)
- Think about reusability across different components

**Commit:** `Day 94: Custom hooks for code reusability`

---

### Thursday, Apr 3 - Day 95
**Topic:** React Router - Navigation & Routing
**Sessions:** 2

#### Session 1: React Router Setup (50 min)
**Pre-Session Questions:**
1. What is client-side routing?
2. How is it different from traditional server routing?
3. What is React Router?

**Core Topics:**
- Client-side routing concept
- React Router v6 basics
- Routes, Route, and BrowserRouter
- Link and NavLink components
- Programmatic navigation

**Resources:**
- [React Router Tutorial](https://reactrouter.com/en/main/start/tutorial) (30 min)

**Setup:**
```bash
npm install react-router-dom
```

**Exercises:**
1. Install and set up React Router
2. Create basic routes (/home, /about, /contact)
3. Create navigation menu with Link components
4. Set up 404 Not Found page
5. Use NavLink for active link styling
6. Implement programmatic navigation (useNavigate)

**Practice Problems:**
- Problem 1: Set up router with routes for Home, About, Contact pages
- Problem 2: Create navigation menu using Link components
- Problem 3: Style active navigation link differently using NavLink
- Problem 4: Create 404 page for unmatched routes
- Problem 5: Navigate programmatically after form submission

**Hints:**
- Wrap app in `<BrowserRouter>`
- Define routes with `<Route path="/about" element={<About />} />`
- Use `<Link to="/about">` not `<a href>`
- useNavigate() for programmatic navigation: `navigate('/home')`

#### Session 2: Dynamic Routes & Parameters (50 min)
**Topics:** URL parameters, nested routes, query parameters

**Exercises:**
1. Create dynamic route with URL parameter (/posts/:id)
2. Access route params with useParams hook
3. Create nested routes
4. Use Outlet for nested route rendering
5. Access query parameters with useSearchParams
6. Create layout routes (shared layout)

**Practice Problems:**
- Problem 1: Create route `/posts/:id` for individual post pages
- Problem 2: Use useParams() to get post id and fetch that post
- Problem 3: Create nested routes: `/dashboard` with child routes `/dashboard/profile`, `/dashboard/settings`
- Problem 4: Create layout route with shared header/sidebar
- Problem 5: Use query params for filtering: `/posts?category=tech`

**Hints:**
- useParams(): `const { id } = useParams()`
- Nested routes need `<Outlet />` in parent to render children
- useSearchParams(): `const [searchParams] = useSearchParams()`
- Layouts: create route with children, use <Outlet /> where children render

**Commit:** `Day 95: React Router for navigation and routing`

---

### Friday, Apr 4 - Day 96
**Topic:** React with TypeScript - Advanced Typing
**Sessions:** 2

#### Session 1: Component Props Typing (50 min)
**Pre-Session Questions:**
1. How do you type props in React with TypeScript?
2. What is the type of children prop?
3. How do you make props optional?

**Core Topics:**
- Props interface definitions
- children prop type
- Optional props
- Union types for props
- Generic components

**Resources:**
- [React TypeScript Cheatsheet](https://react-typescript-cheatsheet.netlify.app/) (20 min)

**Exercises:**
1. Create strongly typed component props
2. Type children prop correctly
3. Use optional props with default values
4. Create union type for variant prop
5. Type event handlers properly
6. Create generic List component

**Practice Problems:**
- Problem 1: Type Button component props (text, onClick, variant?, disabled?)
- Problem 2: Type Card component that accepts children
- Problem 3: Create Alert component with variant: 'success' | 'error' | 'warning'
- Problem 4: Type form event handlers (onChange, onSubmit)
- Problem 5: Create generic `List<T>` component that accepts items: T[]

**Hints:**
- `children: React.ReactNode`
- Optional props: `title?: string`
- Union types: `variant: 'primary' | 'secondary'`
- Event types: `React.ChangeEvent<HTMLInputElement>`
- Generic: `function List<T>({ items }: { items: T[] })`

#### Session 2: Hooks & State Typing (50 min)
**Topics:** useState with TypeScript, useEffect types, custom hook types

**Exercises:**
1. Type useState with explicit type parameter
2. Type useState with inferred types
3. Type custom hooks properly
4. Type useRef for DOM elements
5. Type useContext
6. Handle null/undefined in types

**Practice Problems:**
- Problem 1: Type useState for object state: `const [user, setUser] = useState<User | null>(null)`
- Problem 2: Type custom useFetch hook with generics
- Problem 3: Type useRef for button element: `const ref = useRef<HTMLButtonElement>(null)`
- Problem 4: Create typed context for auth (user, login, logout)
- Problem 5: Type event handler functions separately

**Hints:**
- Explicit type: `useState<User | null>(null)`
- Inferred when initial value is typed: `useState(0)` infers number
- Ref for DOM: `useRef<HTMLDivElement>(null)`
- Context: create type for context value, use in createContext<ValueType>()

**Commit:** `Day 96: Advanced React TypeScript patterns`

---

### Saturday, Apr 5 - Day 97
**Topic:** useContext & Context API
**Sessions:** 2

#### Session 1: Context API Basics (50 min)
**Pre-Session Questions:**
1. What problem does Context solve?
2. When should you use Context?
3. What is prop drilling?

**Core Topics:**
- Context API concept (avoid prop drilling)
- Creating context with createContext
- Context Provider
- Consuming context with useContext
- When to use Context vs props

**Resources:**
- [Passing Data Deeply with Context](https://react.dev/learn/passing-data-deeply-with-context) (20 min)

**Exercises:**
1. Create theme context (light/dark mode)
2. Provide context value at app root
3. Consume context in nested components
4. Create context with multiple values
5. Update context value from child components
6. Create multiple contexts

**Practice Problems:**
- Problem 1: Create ThemeContext with value: { theme: 'light' | 'dark', toggleTheme: () => void }
- Problem 2: Wrap app in ThemeProvider
- Problem 3: Use useContext(ThemeContext) in Button component to apply theme styles
- Problem 4: Create toggle button that calls toggleTheme from context
- Problem 5: Create separate contexts for theme and user auth

**Hints:**
- Create context: `const ThemeContext = createContext<ThemeContextType | undefined>(undefined)`
- Provide value: `<ThemeContext.Provider value={...}>`
- Consume: `const { theme } = useContext(ThemeContext)`
- Wrap providers at app root (or nearest common ancestor)

#### Session 2: Advanced Context Patterns (50 min)
**Topics:** Custom context hooks, context composition, performance optimization

**Exercises:**
1. Create custom hook for context (useTheme, useAuth)
2. Split context for better performance
3. Memoize context value
4. Create context with reducer
5. Implement auth context with login/logout
6. Nest multiple context providers

**Practice Problems:**
- Problem 1: Create `useTheme()` custom hook that wraps useContext with null check
- Problem 2: Create `useAuth()` hook for auth context
- Problem 3: Memoize context value with useMemo to avoid unnecessary re-renders
- Problem 4: Create AuthContext with user state and login/logout functions
- Problem 5: Implement protected routes using auth context

**Hints:**
- Custom hook pattern: throw error if context is undefined (used outside provider)
- Memoize value: `const value = useMemo(() => ({ ... }), [deps])`
- Multiple providers: nest them or create wrapper component

**Commit:** `Day 97: Context API for state sharing`

---

### Sunday, Apr 6 - Day 98
**Topic:** State Management Patterns
**Sessions:** 2

#### Session 1: useReducer Hook (50 min)
**Pre-Session Questions:**
1. When should you use useReducer instead of useState?
2. What is a reducer function?
3. How is useReducer similar to Redux?

**Core Topics:**
- useReducer for complex state logic
- Reducer function (state, action) => newState
- Dispatch actions
- Action types and payloads
- useReducer vs useState

**Resources:**
- [Extracting State Logic into a Reducer](https://react.dev/learn/extracting-state-logic-into-a-reducer) (20 min)

**Exercises:**
1. Convert useState to useReducer for todo list
2. Define action types (ADD_TODO, TOGGLE_TODO, DELETE_TODO)
3. Write reducer function with switch statement
4. Dispatch actions from components
5. Type reducer with TypeScript
6. Combine useReducer with useContext

**Practice Problems:**
- Problem 1: Create todo list with useReducer (add, toggle, delete actions)
- Problem 2: Define TodoAction type union for all action types
- Problem 3: Write reducer function handling all actions
- Problem 4: Create cart with useReducer (add item, remove item, update quantity, clear cart)
- Problem 5: Combine useReducer + useContext for global state

**Hints:**
- Reducer: `(state, action) => { switch(action.type) { ... } }`
- Dispatch: `dispatch({ type: 'ADD_TODO', payload: todo })`
- Use useReducer when multiple related state updates
- TypeScript: type State, type Action (union of all action types)

#### Session 2: Zustand for State Management (50 min)
**Topics:** External state library, simpler alternative to Redux

**Resources:**
- [Zustand Documentation](https://github.com/pmndrs/zustand) (20 min)

**Setup:**
```bash
npm install zustand
```

**Exercises:**
1. Install Zustand
2. Create store with state and actions
3. Use store in components
4. Create multiple stores for different concerns
5. Persist state to localStorage
6. Compare with useContext/useReducer

**Practice Problems:**
- Problem 1: Create auth store with user state and login/logout actions
- Problem 2: Create cart store with items array and add/remove/clear actions
- Problem 3: Use auth store in multiple components without prop drilling
- Problem 4: Persist cart to localStorage automatically
- Problem 5: Create theme store for dark/light mode

**Hints:**
- Create store: `const useStore = create((set) => ({ ... }))`
- Use in component: `const { user, login } = useStore()`
- Actions: `login: (user) => set({ user })`
- Middleware for persistence: `persist()`
- Zustand is simpler than Redux, no providers needed

**Commit:** `Day 98: State management with useReducer and Zustand`

---

### Monday, Apr 7 - Day 99
**Topic:** Performance Optimization - Part 1
**Sessions:** 2

#### Session 1: React.memo and useMemo (50 min)
**Pre-Session Questions:**
1. Why does React re-render components?
2. What is memoization?
3. When should you optimize performance?

**Core Topics:**
- React rendering behavior
- React.memo for component memoization
- useMemo for expensive computations
- When to use memoization
- Premature optimization pitfalls

**Resources:**
- [React Performance Optimization](https://react.dev/reference/react/memo) (15 min)

**Exercises:**
1. Identify unnecessary re-renders with React DevTools
2. Wrap component with React.memo
3. Use useMemo for expensive calculations
4. Compare with and without memoization
5. Memoize filtered/sorted lists
6. Understand when memo is helpful vs harmful

**Practice Problems:**
- Problem 1: Wrap pure component in React.memo to prevent re-renders
- Problem 2: Use useMemo to cache expensive filter/sort operation
- Problem 3: Calculate fibonacci with and without useMemo (compare performance)
- Problem 4: Memoize filtered list that re-calculates on every render
- Problem 5: Identify when NOT to use memo (premature optimization)

**Hints:**
- React.memo: `const MemoComponent = React.memo(Component)`
- useMemo: `const value = useMemo(() => expensiveCalc(), [deps])`
- Only memoize if actually expensive or component renders often
- Profile first, optimize after

#### Session 2: useCallback and Optimization Patterns (50 min)
**Topics:** useCallback for function memoization, optimization best practices

**Exercises:**
1. Use useCallback for event handlers passed to child components
2. Understand useCallback dependency array
3. Optimize list rendering with keys
4. Use code splitting with lazy loading
5. Virtualize long lists (concept introduction)
6. Apply optimization techniques to blog app

**Practice Problems:**
- Problem 1: Use useCallback to memoize function passed to React.memo child
- Problem 2: Optimize list where each item has event handler
- Problem 3: Use proper keys (not array index) for list performance
- Problem 4: Lazy load route components with React.lazy
- Problem 5: Measure before/after performance with React DevTools Profiler

**Hints:**
- useCallback: `const fn = useCallback(() => {...}, [deps])`
- Necessary when passing function to memoized component
- Without useCallback, new function instance on every render
- Combine: React.memo + useCallback for full optimization

**Commit:** `Day 99: React performance optimization techniques`

---

### Tuesday, Apr 8 - Day 100
**Topic:** Performance Optimization - Part 2
**Sessions:** 2

#### Session 1: Code Splitting & Lazy Loading (50 min)
**Pre-Session Questions:**
1. What is code splitting?
2. Why would you lazy load components?
3. What is a bundle size and why does it matter?

**Core Topics:**
- Code splitting concept
- React.lazy and Suspense
- Route-based code splitting
- Component-based code splitting
- Bundle analysis

**Resources:**
- [Code-Splitting](https://react.dev/reference/react/lazy) (15 min)

**Exercises:**
1. Analyze bundle size with webpack analyzer
2. Lazy load route components
3. Add Suspense boundaries with fallback
4. Lazy load heavy components (charts, editors)
5. Preload components on hover
6. Measure improvement in initial load time

**Practice Problems:**
- Problem 1: Lazy load route components for /posts, /about, /contact
- Problem 2: Add Suspense with loading spinner fallback
- Problem 3: Lazy load modal component (only load when opened)
- Problem 4: Install and run webpack-bundle-analyzer to see bundle size
- Problem 5: Split vendor bundles from app code

**Hints:**
- Lazy: `const Posts = React.lazy(() => import('./Posts'))`
- Suspense: `<Suspense fallback={<Loading />}><Posts /></Suspense>`
- Split at route level first (biggest wins)
- Lazy load modals, tooltips, heavy features

#### Session 2: Web Vitals & Performance Monitoring (50 min)
**Topics:** Core Web Vitals, performance measurement, optimization strategies

**Setup:**
```bash
npm install web-vitals
```

**Exercises:**
1. Install web-vitals library
2. Measure LCP, FID, CLS
3. Use React DevTools Profiler
4. Optimize images (lazy loading, next-gen formats)
5. Implement virtualization for long lists
6. Add performance monitoring

**Practice Problems:**
- Problem 1: Measure Core Web Vitals (LCP, FID, CLS) in your app
- Problem 2: Lazy load images below the fold
- Problem 3: Use React DevTools Profiler to find slow components
- Problem 4: Implement infinite scroll or virtual list for long lists
- Problem 5: Set up performance monitoring (log vitals to analytics)

**Hints:**
- LCP: Largest Contentful Paint (should be <2.5s)
- FID: First Input Delay (should be <100ms)
- CLS: Cumulative Layout Shift (should be <0.1)
- Lazy load images: `loading="lazy"` attribute
- Virtual lists: react-window or react-virtual

**Commit:** `Day 100: Code splitting and performance monitoring`

---

### Wednesday, Apr 9 - Day 101
**Topic:** Error Boundaries & Error Handling
**Sessions:** 2

#### Session 1: Error Boundaries (50 min)
**Pre-Session Questions:**
1. What happens when a component throws an error?
2. How do you catch errors in React?
3. What are Error Boundaries?

**Core Topics:**
- Error Boundaries concept (class components)
- componentDidCatch and getDerivedStateFromError
- Fallback UI for errors
- Error boundary placement
- Limitations of error boundaries

**Resources:**
- [Error Boundaries](https://react.dev/reference/react/Component#catching-rendering-errors-with-an-error-boundary) (15 min)

**Exercises:**
1. Create Error Boundary class component
2. Catch errors with componentDidCatch
3. Display fallback UI on error
4. Log errors to error tracking service
5. Place error boundaries strategically
6. Reset error boundary with state

**Practice Problems:**
- Problem 1: Create ErrorBoundary component that catches child errors
- Problem 2: Display friendly error message when error occurs
- Problem 3: Add "Retry" button to error boundary
- Problem 4: Log errors to console (or Sentry) from componentDidCatch
- Problem 5: Wrap each route in error boundary (isolate errors)

**Hints:**
- Error boundaries must be class components (no hook equivalent yet)
- Catch: `componentDidCatch(error, errorInfo) { ... }`
- Fallback UI: `getDerivedStateFromError() { return { hasError: true } }`
- Wrap parts of app that might fail independently

#### Session 2: Global Error Handling (50 min)
**Topics:** Async error handling, error logging, user-friendly errors

**Exercises:**
1. Handle async errors (promises, fetch)
2. Create global error handler
3. Display toast notifications for errors
4. Implement retry logic for failed requests
5. Create error page for fatal errors
6. Add error reporting to monitoring service

**Practice Problems:**
- Problem 1: Catch and display errors from async API calls
- Problem 2: Show toast notification for network errors
- Problem 3: Retry failed fetch requests automatically (max 3 attempts)
- Problem 4: Create 500 error page for unrecoverable errors
- Problem 5: Send errors to Sentry or similar error tracking service

**Hints:**
- Try/catch for async code in useEffect
- Store errors in state to display to user
- Use error state: `const [error, setError] = useState<Error | null>(null)`
- Provide actionable error messages (not just "Error occurred")

**Commit:** `Day 101: Error boundaries and error handling`

---

### Thursday, Apr 10 - Day 102
**Topic:** Accessibility (a11y) Basics
**Sessions:** 2

#### Session 1: Semantic HTML & ARIA (50 min)
**Pre-Session Questions:**
1. What is web accessibility?
2. Why is accessibility important?
3. What is semantic HTML?

**Core Topics:**
- Accessibility fundamentals
- Semantic HTML elements
- ARIA attributes (aria-label, aria-describedby, role)
- Keyboard navigation
- Screen reader considerations

**Resources:**
- [React Accessibility](https://react.dev/learn/accessibility) (15 min)
- [MDN Accessibility](https://developer.mozilla.org/en-US/docs/Web/Accessibility) (20 min)

**Exercises:**
1. Use semantic HTML (<nav>, <main>, <article>, <button>)
2. Add aria-label to icon buttons
3. Implement keyboard navigation (Tab, Enter, Escape)
4. Add focus styles to interactive elements
5. Test with screen reader
6. Use alt text for images

**Practice Problems:**
- Problem 1: Replace <div onClick> with <button> (semantic + accessible)
- Problem 2: Add aria-label to icon-only buttons
- Problem 3: Ensure all interactive elements are keyboard accessible (Tab + Enter)
- Problem 4: Add alt text to all images (descriptive, not "image")
- Problem 5: Test your app with keyboard only (no mouse)

**Hints:**
- Use <button> not <div onClick>
- Add aria-label when visible label isn't present
- Make custom components focusable with tabIndex={0}
- Add :focus styles (don't remove outline!)

#### Session 2: Form Accessibility & Testing (50 min)
**Topics:** Accessible forms, labels, error messages, focus management

**Exercises:**
1. Associate labels with inputs (<label htmlFor>)
2. Add accessible error messages (aria-describedby)
3. Manage focus (auto-focus on modal open, return on close)
4. Add skip links for navigation
5. Test with Lighthouse accessibility audit
6. Test with axe DevTools extension

**Practice Problems:**
- Problem 1: Ensure every input has associated label (htmlFor + id)
- Problem 2: Link error messages to inputs with aria-describedby
- Problem 3: Auto-focus first input when modal opens
- Problem 4: Return focus to trigger button when modal closes
- Problem 5: Run Lighthouse audit and fix accessibility issues

**Hints:**
- Label: `<label htmlFor="email">Email</label> <input id="email" />`
- Error: `<input aria-describedby="email-error" /> <span id="email-error">{error}</span>`
- Focus management: `useEffect(() => inputRef.current?.focus(), [])`
- Install axe DevTools extension for Chrome/Firefox

**Commit:** `Day 102: Accessibility best practices`

---

### Friday, Apr 11 - Day 103
**Topic:** Testing React Components - Part 1
**Sessions:** 2

#### Session 1: React Testing Library Setup (50 min)
**Pre-Session Questions:**
1. Why test React components?
2. What's the difference between unit tests and integration tests?
3. What is React Testing Library?

**Core Topics:**
- Testing philosophy (test behavior, not implementation)
- React Testing Library vs Enzyme
- Queries (getBy, queryBy, findBy)
- Rendering components for tests
- Assertions with Jest

**Resources:**
- [React Testing Library](https://testing-library.com/docs/react-testing-library/intro/) (20 min)

**Setup:**
```bash
npm install --save-dev @testing-library/react @testing-library/jest-dom @testing-library/user-event
```

**Exercises:**
1. Set up testing environment
2. Write first test (render component)
3. Query elements (getByText, getByRole)
4. Test props rendering
5. Test conditional rendering
6. Run tests with npm test

**Practice Problems:**
- Problem 1: Test Button component renders with correct text
- Problem 2: Test Card component displays title and children
- Problem 3: Test conditional rendering (component shows/hides based on prop)
- Problem 4: Test list renders correct number of items
- Problem 5: Test error message displays when error prop is provided

**Hints:**
- Render: `render(<Component />)`
- Query: `screen.getByText('Hello')`, `screen.getByRole('button')`
- Assert: `expect(element).toBeInTheDocument()`
- Prefer getByRole over getByTestId

#### Session 2: Testing User Interactions (50 min)
**Topics:** Simulating events, user-event library, async tests

**Exercises:**
1. Test button clicks
2. Test form input changes
3. Test form submission
4. Use user-event for realistic interactions
5. Test async behavior (loading, data display)
6. Test error scenarios

**Practice Problems:**
- Problem 1: Test button click calls onClick handler
- Problem 2: Test typing in input updates the displayed value
- Problem 3: Test form submission calls onSubmit with correct data
- Problem 4: Test async data fetching (loading â†’ data displayed)
- Problem 5: Test error handling (network failure shows error message)

**Hints:**
- Fire event: `fireEvent.click(button)` or `await user.click(button)`
- Prefer user-event: `const user = userEvent.setup()` then `user.click(...)`
- Async: `await screen.findByText('Data')` waits for element
- Mock functions: `const onClick = jest.fn()`

**Commit:** `Day 103: React Testing Library fundamentals`

---

### Saturday, Apr 12 - Day 104
**Topic:** Testing React Components - Part 2
**Sessions:** 2

#### Session 1: Testing Hooks (50 min)
**Pre-Session Questions:**
1. How do you test custom hooks?
2. Can you test hooks outside of components?
3. What is @testing-library/react-hooks?

**Core Topics:**
- Testing hooks with renderHook
- Testing hook return values
- Testing hook updates
- Testing async hooks
- Testing hooks with context

**Resources:**
- [Testing Hooks](https://react-hooks-testing-library.com/) (15 min)

**Exercises:**
1. Test custom useToggle hook
2. Test hook state updates
3. Test async hooks (useFetch)
4. Test hook with dependencies
5. Test hook with context
6. Test hook error handling

**Practice Problems:**
- Problem 1: Test useToggle hook (initial value, toggle function)
- Problem 2: Test useCounter hook (increment, decrement, reset)
- Problem 3: Test useFetch hook (loading, data, error states)
- Problem 4: Test useDebounce hook (value updates after delay)
- Problem 5: Test useAuth hook that uses AuthContext

**Hints:**
- Use renderHook: `const { result } = renderHook(() => useToggle())`
- Access value: `result.current.value`
- Trigger update: `act(() => result.current.toggle())`
- Test async: `await waitFor(() => expect(result.current.data).toBeDefined())`

#### Session 2: Testing Integration & Best Practices (50 min)
**Topics:** Integration tests, mocking, test organization

**Exercises:**
1. Write integration tests (multiple components together)
2. Mock API calls with MSW (Mock Service Worker)
3. Test complete user flows
4. Organize tests logically
5. Achieve good test coverage
6. Balance unit vs integration tests

**Practice Problems:**
- Problem 1: Test complete login flow (input â†’ submit â†’ success/error)
- Problem 2: Mock API with MSW (return fake data)
- Problem 3: Test post creation flow (form â†’ API call â†’ list updates)
- Problem 4: Test navigation flow (click link â†’ new page renders)
- Problem 5: Achieve 80%+ coverage on key components

**Hints:**
- Integration tests test multiple components working together
- Mock network with MSW (better than axios mocking)
- Focus tests on user behavior, not implementation details
- Test what users do: see, click, type, read feedback

**Commit:** `Day 104: Testing hooks and integration tests`

---

### Sunday, Apr 13 - Day 105
**Topic:** Blog Frontend - Setup & Post List
**Sessions:** 2

#### Session 1: Project Setup (50 min)
**Topics:** Connect to backend API, project structure, routing setup

**Exercises:**
1. Create Vite + React + TypeScript project for blog frontend
2. Set up folder structure (components, pages, hooks, services)
3. Set up React Router for navigation
4. Create API service layer (axios or fetch)
5. Set up environment variables for API URL
6. Create base layout with header/footer

**Practice Problems:**
- Problem 1: Set up project with Vite, React, TypeScript, React Router
- Problem 2: Create folder structure: src/{components, pages, hooks, services, types}
- Problem 3: Set up routes: /, /posts, /posts/:id, /login, /register
- Problem 4: Create API service with base URL from environment variable
- Problem 5: Create Layout component with Header (nav links) and Outlet

**Hints:**
- Use Vite for faster dev experience
- Environment variable: `VITE_API_URL=http://localhost:3000`
- API service: centralize all API calls in services/api.ts
- Layout route pattern with Outlet for child routes

#### Session 2: Post List Page (50 min)
**Topics:** Fetch and display blog posts, loading states, error handling

**Exercises:**
1. Create PostList component
2. Fetch posts from API on mount
3. Display loading spinner while fetching
4. Display error message if fetch fails
5. Render list of posts with title, author, excerpt
6. Add link to each post detail page

**Practice Problems:**
- Problem 1: Create useFetch custom hook for data fetching
- Problem 2: Fetch posts from GET /posts API endpoint
- Problem 3: Show loading spinner while fetching
- Problem 4: Show error message if API call fails
- Problem 5: Display list of posts (title, author, excerpt, "Read more" link)

**Hints:**
- Use useEffect to fetch on component mount
- Create Loading and Error components for reuse
- Link to post detail: `<Link to={`/posts/${post.id}`}>Read more</Link>`
- Handle empty state (no posts)

**Commit:** `Day 105: Blog frontend setup and post list`

---

### Monday, Apr 14 - Day 106
**Topic:** Blog Frontend - Post Detail & Comments
**Sessions:** 2

#### Session 1: Post Detail Page (50 min)
**Topics:** Dynamic route, fetch single post, display content

**Exercises:**
1. Create PostDetail component
2. Get post ID from URL params
3. Fetch post by ID from API
4. Display full post (title, author, content, date)
5. Handle post not found (404)
6. Add back button to post list

**Practice Problems:**
- Problem 1: Create PostDetail page component
- Problem 2: Use useParams to get post ID from URL
- Problem 3: Fetch post from GET /posts/:id endpoint
- Problem 4: Display full post with formatted date
- Problem 5: Show 404 message if post not found

**Hints:**
- useParams: `const { id } = useParams()`
- Format date: use `new Date(post.createdAt).toLocaleDateString()`
- Handle 404: check if API returns 404, show error message
- Add navigation: `<Link to="/posts">â† Back to posts</Link>`

#### Session 2: Comments Section (50 min)
**Topics:** Display comments, add new comment

**Exercises:**
1. Fetch comments for post
2. Display comments list
3. Create AddComment form
4. Post new comment to API
5. Update comments list after adding
6. Handle authentication (only logged-in users can comment)

**Practice Problems:**
- Problem 1: Fetch comments from GET /posts/:id/comments
- Problem 2: Display comments below post (author, content, date)
- Problem 3: Create AddComment form (textarea + submit button)
- Problem 4: POST new comment to API /posts/:id/comments
- Problem 5: Refresh comments after successful submission

**Hints:**
- Fetch comments in same useEffect as post, or separate
- After posting comment, fetch comments again or add to state manually
- Check if user is authenticated before showing comment form
- Clear form after successful submission

**Commit:** `Day 106: Post detail and comments functionality`

---

### Tuesday, Apr 15 - Day 107
**Topic:** Blog Frontend - Authentication
**Sessions:** 2

#### Session 1: Login & Register Forms (50 min)
**Topics:** Auth forms, form validation, API integration

**Exercises:**
1. Create Login page with form
2. Create Register page with form
3. Add form validation (email format, password length)
4. Call login API endpoint
5. Handle auth errors (invalid credentials)
6. Display success/error messages

**Practice Problems:**
- Problem 1: Create Login form (email, password, submit)
- Problem 2: Validate email format and password length (min 8 chars)
- Problem 3: POST to /auth/login endpoint
- Problem 4: Display error message if login fails
- Problem 5: Create Register form (name, email, password, confirmPassword)

**Hints:**
- Use controlled inputs with useState
- Validate before submitting
- API returns JWT token on successful login
- Show field-level errors (invalid email, passwords don't match)

#### Session 2: Auth State Management (50 min)
**Topics:** Store JWT, auth context, protected routes

**Exercises:**
1. Create AuthContext for global auth state
2. Store JWT in localStorage
3. Add JWT to API requests (Authorization header)
4. Implement logout functionality
5. Create protected routes (redirect to login if not authenticated)
6. Show user info in header when logged in

**Practice Problems:**
- Problem 1: Create AuthContext with { user, login, logout, isAuthenticated }
- Problem 2: Store JWT in localStorage after successful login
- Problem 3: Add Authorization: Bearer <token> header to all API requests
- Problem 4: Implement logout (clear token, redirect to home)
- Problem 5: Create ProtectedRoute component (redirect to /login if not authenticated)

**Hints:**
- AuthContext holds user and auth functions
- Persist token: `localStorage.setItem('token', jwt)`
- Axios interceptor: add token to all requests automatically
- Check isAuthenticated before rendering protected content

**Commit:** `Day 107: Authentication (login, register, auth state)`

---

### Wednesday, Apr 16 - Day 108
**Topic:** Blog Frontend - Create & Edit Posts
**Sessions:** 2

#### Session 1: Create Post Form (50 min)
**Topics:** Form for creating new posts, rich text input (or textarea)

**Exercises:**
1. Create NewPost page
2. Build post form (title, content, category, tags)
3. Add form validation
4. POST new post to API
5. Redirect to post detail after creation
6. Only allow authenticated users

**Practice Problems:**
- Problem 1: Create NewPost form (title, content, category, tags)
- Problem 2: Validate all fields are filled
- Problem 3: POST to /posts endpoint with auth token
- Problem 4: Redirect to created post detail page on success
- Problem 5: Show form errors if API returns validation errors

**Hints:**
- Use textarea for content (or markdown editor library)
- Send auth token in request headers
- Get created post ID from API response for redirect
- Handle tags as comma-separated string or array

#### Session 2: Edit Post (50 min)
**Topics:** Prefill form with existing post data, update post

**Exercises:**
1. Create EditPost page
2. Fetch existing post data
3. Prefill form with post data
4. PUT/PATCH updated post to API
5. Only allow post author to edit
6. Redirect after successful update

**Practice Problems:**
- Problem 1: Create EditPost page at /posts/:id/edit
- Problem 2: Fetch post and prefill form fields
- Problem 3: PUT updated post to /posts/:id endpoint
- Problem 4: Check if current user is post author (show 403 if not)
- Problem 5: Redirect to post detail after successful update

**Hints:**
- Fetch post first, then set form state with post data
- Check: `if (post.authorId !== currentUser.id)` show error
- Use same form component for create and edit (reusable)
- PATCH vs PUT: PATCH for partial updates, PUT for full replacement

**Commit:** `Day 108: Create and edit post functionality`

---

### Thursday, Apr 17 - Day 109
**Topic:** Blog Frontend - Search & Filters
**Sessions:** 2

#### Session 1: Search Functionality (50 min)
**Topics:** Search bar, debounced search, query params

**Exercises:**
1. Add search bar to post list page
2. Implement debounced search (wait for user to stop typing)
3. Send search query to API
4. Display filtered results
5. Add loading indicator while searching
6. Update URL with search query

**Practice Problems:**
- Problem 1: Add search input above post list
- Problem 2: Debounce search input (wait 500ms after user stops typing)
- Problem 3: Fetch posts with query: GET /posts?search=keyword
- Problem 4: Show loading spinner while searching
- Problem 5: Update URL: /posts?search=keyword (use useSearchParams)

**Hints:**
- Use useDebounce custom hook from earlier
- useSearchParams: `const [searchParams, setSearchParams] = useSearchParams()`
- Update URL: `setSearchParams({ search: query })`
- Read URL on mount to support direct links

#### Session 2: Filters & Sorting (50 min)
**Topics:** Category filter, sort options, combine filters

**Exercises:**
1. Add category filter dropdown
2. Add sort dropdown (newest, oldest, popular)
3. Combine search + filters in one API call
4. Update URL with all filters
5. Add clear filters button
6. Implement pagination

**Practice Problems:**
- Problem 1: Add category dropdown (all, tech, lifestyle, etc.)
- Problem 2: Add sort dropdown (newest, oldest, most popular)
- Problem 3: Fetch posts with all params: /posts?search=x&category=tech&sort=newest
- Problem 4: Update URL with all query params
- Problem 5: Add pagination (page number in URL, prev/next buttons)

**Hints:**
- Combine all params: `/posts?search=${search}&category=${cat}&sort=${sort}&page=${page}`
- Multiple search params: `setSearchParams({ search, category, sort, page })`
- Pagination: show page numbers, disable prev on page 1

**Commit:** `Day 109: Search, filters, and sorting`

---

### Friday, Apr 18 - Day 110
**Topic:** Blog Frontend - User Profile
**Sessions:** 2

#### Session 1: View User Profile (50 min)
**Topics:** Display user info, user's posts

**Exercises:**
1. Create UserProfile page
2. Fetch user data by ID
3. Display user info (name, email, bio, joined date)
4. Fetch and display user's posts
5. Handle user not found
6. Add edit profile button (only for own profile)

**Practice Problems:**
- Problem 1: Create UserProfile page at /users/:id
- Problem 2: Fetch user from GET /users/:id
- Problem 3: Display user info (name, email, bio, member since)
- Problem 4: Fetch user's posts: GET /posts?authorId=:id
- Problem 5: Show "Edit Profile" button only if viewing own profile

**Hints:**
- Use useParams to get user ID
- Compare current user ID with profile user ID for edit button
- List user's posts same as main post list

#### Session 2: Edit User Profile (50 min)
**Topics:** Update user info, change password, upload avatar

**Exercises:**
1. Create EditProfile page
2. Prefill form with current user data
3. Update user info (name, bio)
4. Implement change password
5. Optional: upload profile picture
6. Update auth context after profile update

**Practice Problems:**
- Problem 1: Create EditProfile form (name, email, bio)
- Problem 2: PATCH /users/:id to update profile
- Problem 3: Add change password section (old password, new password, confirm)
- Problem 4: POST /users/:id/password to change password
- Problem 5: Update user in AuthContext after successful update

**Hints:**
- Can't change email (usually)
- Validate password change (old password correct, new password valid)
- Update auth context so header shows new name immediately
- Optional: implement avatar upload similar to post images

**Commit:** `Day 110: User profile view and edit`

---

### Saturday, Apr 19 - Day 111
**Topic:** Blog Frontend - Polish & UX Improvements
**Sessions:** 2

#### Session 1: UI/UX Enhancements (50 min)
**Topics:** Loading skeletons, empty states, toast notifications

**Exercises:**
1. Replace loading spinners with skeleton loaders
2. Add empty states (no posts, no comments, no results)
3. Implement toast notifications for actions (success, error)
4. Add confirmation modals (delete post, logout)
5. Improve error messages (user-friendly)
6. Add animations and transitions

**Practice Problems:**
- Problem 1: Create skeleton loader for post list while loading
- Problem 2: Show friendly empty state when no posts found
- Problem 3: Add toast notifications for success/error actions
- Problem 4: Add confirmation modal for post deletion
- Problem 5: Add fade-in animation for page transitions

**Hints:**
- Skeleton: gray rectangles mimicking content layout
- Empty state: illustration + message + action button
- Toast library: react-hot-toast or react-toastify
- Confirmation modal: are you sure? with cancel/confirm buttons

#### Session 2: Responsive Design (50 min)
**Topics:** Mobile-first CSS, responsive navigation, media queries

**Exercises:**
1. Make layout responsive (mobile, tablet, desktop)
2. Create responsive navigation (hamburger menu on mobile)
3. Make forms mobile-friendly
4. Optimize images for different screen sizes
5. Test on different devices/screen sizes
6. Add touch-friendly UI elements

**Practice Problems:**
- Problem 1: Use CSS Grid/Flexbox for responsive post grid
- Problem 2: Create hamburger menu for mobile navigation
- Problem 3: Stack form inputs vertically on mobile
- Problem 4: Use CSS media queries for breakpoints (768px, 1024px)
- Problem 5: Test app on mobile screen size (Chrome DevTools)

**Hints:**
- Mobile-first: design for mobile, add media queries for larger screens
- Hamburger menu: toggle state, show/hide on mobile
- Touch targets: minimum 44x44px for buttons/links
- Test with Chrome DevTools device emulation

**Commit:** `Day 111: UI/UX improvements and responsive design`

---

### Sunday, Apr 20 - Day 112
**Topic:** Blog Frontend - Real-Time Features (Optional)
**Sessions:** 2

#### Session 1: WebSocket Connection (50 min)
**Topics:** Connect to backend WebSocket, listen for events

**Exercises:**
1. Install socket.io-client
2. Connect to backend WebSocket server
3. Listen for "new_post" event
4. Update post list in real-time
5. Listen for "new_comment" event
6. Update comment count in real-time

**Practice Problems:**
- Problem 1: Connect to WebSocket server on app mount
- Problem 2: Listen for "new_post" event and add post to list
- Problem 3: Show toast notification when new post is published
- Problem 4: Listen for "new_comment" event on post detail page
- Problem 5: Update comment list in real-time when comment is added

**Hints:**
- Install: `npm install socket.io-client`
- Connect: `const socket = io('http://localhost:3000')`
- Listen: `socket.on('new_post', (post) => { ... })`
- Cleanup: disconnect socket on unmount

#### Session 2: Real-Time Notifications (50 min)
**Topics:** Notification dropdown, unread count, mark as read

**Exercises:**
1. Create notification dropdown in header
2. Listen for notification events
3. Display unread notification count
4. Show notification list
5. Mark notifications as read
6. Add notification preferences

**Practice Problems:**
- Problem 1: Create notification bell icon in header with unread count badge
- Problem 2: Listen for "notification" WebSocket event
- Problem 3: Show dropdown with notification list on bell click
- Problem 4: Mark notification as read when clicked
- Problem 5: Fetch old notifications on mount (not just live ones)

**Hints:**
- Store notifications in state
- Unread count: filter notifications by `!notification.read`
- Mark as read: PATCH /notifications/:id
- Optional: use Zustand for notification state

**Commit:** `Day 112: Real-time features with WebSockets`

---

### Monday, Apr 21 - Day 113
**Topic:** Blog Frontend - Advanced Features Part 1
**Sessions:** 2

#### Session 1: Draft Posts & Publishing (50 min)
**Topics:** Save as draft, publish/unpublish, scheduled publishing

**Exercises:**
1. Add draft/published status to posts
2. Save post as draft without publishing
3. Add publish/unpublish toggle
4. Filter posts by status (drafts, published)
5. Show draft indicator in UI
6. Only show published posts to non-authors

**Practice Problems:**
- Problem 1: Add status field to post creation (draft vs published)
- Problem 2: Create "My Drafts" page showing only draft posts
- Problem 3: Add publish button on draft posts
- Problem 4: Hide draft posts from public post list
- Problem 5: Show draft badge on post cards

**Hints:**
- Add status to API: GET /posts?status=published
- Check authorization: only author can see their drafts
- Use conditional rendering for draft indicator

#### Session 2: Post Categories & Tags (50 min)
**Topics:** Category management, tag filtering, multi-select

**Exercises:**
1. Fetch categories from API
2. Add category selector to post form
3. Implement tag input (add/remove tags)
4. Filter posts by category
5. Filter posts by tags
6. Show category and tags on post cards

**Practice Problems:**
- Problem 1: Fetch categories from GET /categories
- Problem 2: Add category dropdown to post creation form
- Problem 3: Implement tag input with add/remove functionality
- Problem 4: Filter posts: GET /posts?category=tech&tags=javascript,react
- Problem 5: Display category badge and tag list on post cards

**Hints:**
- Tags can be comma-separated array in state
- Use chips/badges UI for tags
- Category filter: dropdown or sidebar navigation

**Commit:** `Day 113: Draft posts and categories/tags`

---

### Tuesday, Apr 22 - Day 114
**Topic:** Blog Frontend - Advanced Features Part 2
**Sessions:** 2

#### Session 1: Like System (50 min)
**Topics:** Like/unlike posts, optimistic updates

**Exercises:**
1. Display like count on posts
2. Add like button (heart icon)
3. POST like to API /posts/:id/like
4. Implement unlike functionality
5. Optimistic UI update (instant feedback)
6. Show which posts current user has liked
7. Disable like button if not authenticated

**Practice Problems:**
- Problem 1: Display like count and heart button on each post
- Problem 2: POST to /posts/:id/like when heart clicked
- Problem 3: Update like count immediately (optimistic update)
- Problem 4: DELETE /posts/:id/like to unlike
- Problem 5: Show filled heart if user has liked, outline if not

**Hints:**
- Optimistic update: increment count immediately, revert if API fails
- Track liked posts: array of post IDs in state
- Toggle filled/outline heart based on liked status

#### Session 2: Bookmarks/Favorites (50 min)
**Topics:** Save posts for later, bookmark list

**Exercises:**
1. Add bookmark button to posts
2. POST bookmark to API
3. Create "My Bookmarks" page
4. Display bookmarked posts
5. Remove bookmark functionality
6. Show bookmark count (optional)

**Practice Problems:**
- Problem 1: Add bookmark icon button to post cards
- Problem 2: POST to /posts/:id/bookmark
- Problem 3: Create /bookmarks route showing user's bookmarked posts
- Problem 4: DELETE /posts/:id/bookmark to remove
- Problem 5: Toggle filled/outline bookmark icon

**Hints:**
- Similar to like system implementation
- Bookmarks are user-specific (not public count)
- Use local state + API calls

**Commit:** `Day 114: Like and bookmark features`

---

### Wednesday, Apr 23 - Day 115
**Topic:** Blog Frontend - Image Uploads
**Sessions:** 2

#### Session 1: Post Cover Image Upload (50 min)
**Topics:** File input, image preview, upload to API

**Exercises:**
1. Add file input to post form
2. Preview selected image before upload
3. Upload image to API (multipart/form-data)
4. Display cover image on post cards
5. Display full cover image on post detail
6. Handle upload errors

**Practice Problems:**
- Problem 1: Add file input to post form
- Problem 2: Show image preview using FileReader
- Problem 3: Upload image: POST /posts/:id/image with FormData
- Problem 4: Display uploaded image URL on post cards
- Problem 5: Show placeholder if no image

**Hints:**
- Use FormData for file uploads
- Preview: `URL.createObjectURL(file)` or FileReader
- Set Content-Type: multipart/form-data
- API returns image URL, store in post

#### Session 2: Profile Picture Upload (50 min)
**Topics:** User avatar upload, image cropping (optional)

**Exercises:**
1. Add profile picture upload to edit profile
2. Show current profile picture
3. Upload new profile picture
4. Display user avatars throughout app
5. Handle default avatar (no image uploaded)
6. Optimize image size before upload (optional)

**Practice Problems:**
- Problem 1: Add file input to edit profile page
- Problem 2: Upload avatar: POST /users/:id/avatar
- Problem 3: Display avatar in header when logged in
- Problem 4: Show avatar next to author name on posts
- Problem 5: Use default avatar icon if user has no picture

**Hints:**
- Same upload pattern as post images
- Store avatar URL in user object
- Update auth context after avatar upload
- Use default avatar: initial letter or icon

**Commit:** `Day 115: Image uploads for posts and profiles`

---

### Thursday, Apr 24 - Day 116
**Topic:** Blog Frontend - Markdown Editor (Optional Enhancement)
**Sessions:** 2

#### Session 1: Markdown Editor Integration (50 min)
**Topics:** Rich text editing, markdown syntax, preview

**Setup:**
```bash
npm install react-markdown react-simplemde-editor
```

**Exercises:**
1. Install markdown editor library
2. Replace textarea with markdown editor
3. Add markdown formatting buttons
4. Implement live preview
5. Store markdown in database
6. Render markdown in post display

**Practice Problems:**
- Problem 1: Integrate SimpleMDE or similar markdown editor
- Problem 2: Add formatting toolbar (bold, italic, links, images)
- Problem 3: Show live preview while editing
- Problem 4: Save markdown content to API
- Problem 5: Render markdown with react-markdown on post detail page

**Hints:**
- Libraries: SimpleMDE, react-md-editor, or Toast UI Editor
- Markdown stored as plain text in database
- Use react-markdown to render HTML from markdown

#### Session 2: Syntax Highlighting for Code Blocks (50 min)
**Topics:** Code block formatting, syntax highlighting

**Setup:**
```bash
npm install react-syntax-highlighter
```

**Exercises:**
1. Add code block support to markdown
2. Implement syntax highlighting
3. Support multiple languages
4. Add copy button to code blocks
5. Style code blocks properly
6. Add language label

**Practice Problems:**
- Problem 1: Use react-syntax-highlighter for code blocks
- Problem 2: Auto-detect language or use specified language
- Problem 3: Add "Copy" button that copies code to clipboard
- Problem 4: Style code blocks with theme (GitHub, VS Code, etc.)
- Problem 5: Add language label (e.g., "JavaScript") to code block header

**Hints:**
- react-syntax-highlighter with PrismJS or Highlight.js
- Detect language from markdown: ```javascript
- Use navigator.clipboard.writeText() for copy

**Commit:** `Day 116: Markdown editor and code highlighting`

---

### Friday, Apr 25 - Day 117
**Topic:** Blog Frontend - SEO & Meta Tags
**Sessions:** 2

#### Session 1: React Helmet for Meta Tags (50 min)
**Topics:** Dynamic meta tags, Open Graph, Twitter Cards

**Setup:**
```bash
npm install react-helmet-async
```

**Exercises:**
1. Install react-helmet-async
2. Set dynamic page titles
3. Add meta descriptions
4. Implement Open Graph tags for social sharing
5. Add Twitter Card meta tags
6. Test with social media preview tools

**Practice Problems:**
- Problem 1: Set page title dynamically per route
- Problem 2: Add meta description for each page
- Problem 3: Add Open Graph tags for post detail (title, description, image)
- Problem 4: Add Twitter Card meta tags
- Problem 5: Test sharing URL on Facebook/Twitter preview tool

**Hints:**
- Wrap app in HelmetProvider
- Use Helmet component in each page
- OG tags: og:title, og:description, og:image, og:url
- Test with: Facebook Sharing Debugger, Twitter Card Validator

#### Session 2: Sitemap & Robots.txt (50 min)
**Topics:** SEO optimization, sitemap generation

**Exercises:**
1. Create robots.txt file
2. Generate sitemap.xml
3. Add canonical URLs
4. Implement structured data (JSON-LD)
5. Optimize images with alt text
6. Add loading states for SEO

**Practice Problems:**
- Problem 1: Create public/robots.txt allowing all crawlers
- Problem 2: Generate sitemap.xml with all post URLs
- Problem 3: Add canonical URL meta tag to each page
- Problem 4: Add JSON-LD structured data for blog posts
- Problem 5: Ensure all images have descriptive alt text

**Hints:**
- robots.txt: allow search engines to crawl
- Sitemap: list all public URLs
- Canonical URL prevents duplicate content issues
- JSON-LD: search engines understand content structure

**Commit:** `Day 117: SEO optimization with meta tags`

---

### Saturday, Apr 26 - Day 118
**Topic:** Blog Frontend Testing - Part 1
**Sessions:** 2

#### Session 1: Component Testing Setup (50 min)
**Topics:** Test setup, testing library, first tests

**Exercises:**
1. Ensure testing library is installed
2. Write test for Button component
3. Test PostCard component rendering
4. Test form input changes
5. Test conditional rendering
6. Run tests and check coverage

**Practice Problems:**
- Problem 1: Test Button renders with correct text
- Problem 2: Test Button onClick is called when clicked
- Problem 3: Test PostCard displays title, author, excerpt
- Problem 4: Test form input value updates on change
- Problem 5: Test component shows error message when error prop is passed

**Hints:**
- Use @testing-library/react
- render() component, then screen.getBy...
- fireEvent.click() or user.click() for interactions
- expect().toBeInTheDocument() for assertions

#### Session 2: Testing API Integration (50 min)
**Topics:** Mocking API calls, testing async behavior

**Setup:**
```bash
npm install --save-dev msw
```

**Exercises:**
1. Set up MSW (Mock Service Worker)
2. Mock GET /posts endpoint
3. Test PostList fetches and displays posts
4. Test loading state
5. Test error state
6. Test empty state

**Practice Problems:**
- Problem 1: Mock API with MSW handlers
- Problem 2: Test PostList shows loading spinner initially
- Problem 3: Test PostList displays posts after fetch
- Problem 4: Test error message displayed on fetch failure
- Problem 5: Test empty state when no posts returned

**Hints:**
- MSW intercepts network requests in tests
- Use waitFor() for async assertions
- Mock both success and error responses

**Commit:** `Day 118: Component and integration testing`

---

### Sunday, Apr 27 - Day 119
**Topic:** Blog Frontend Testing - Part 2
**Sessions:** 2

#### Session 1: Testing User Flows (50 min)
**Topics:** E2E-style tests, complete user journeys

**Exercises:**
1. Test login flow
2. Test post creation flow
3. Test comment flow
4. Test navigation
5. Test form validation
6. Test authentication redirects

**Practice Problems:**
- Problem 1: Test complete login flow (input email/password â†’ submit â†’ redirect)
- Problem 2: Test post creation (fill form â†’ submit â†’ see new post)
- Problem 3: Test adding comment (type comment â†’ submit â†’ see comment)
- Problem 4: Test navigation (click link â†’ new page renders)
- Problem 5: Test protected route redirects to login when not authenticated

**Hints:**
- Mock authentication in tests
- Test complete flows, not isolated actions
- Use userEvent for realistic interactions

#### Session 2: Testing Custom Hooks (50 min)
**Topics:** Hook testing, renderHook utility

**Exercises:**
1. Test useFetch hook
2. Test useAuth hook
3. Test useForm hook
4. Test useDebounce hook
5. Test custom hooks with dependencies

**Practice Problems:**
- Problem 1: Test useFetch hook returns loading/data/error states
- Problem 2: Test useAuth hook login/logout functions
- Problem 3: Test useForm hook manages form state correctly
- Problem 4: Test useDebounce hook delays value updates
- Problem 5: Test hook cleanup functions are called

**Hints:**
- Use renderHook from @testing-library/react
- Access hook return values via result.current
- Use act() for state updates
- Test async hooks with waitFor()

**Commit:** `Day 119: User flow and hook testing`

---

### Monday, Apr 28 - Day 120
**Topic:** Blog Frontend - Progressive Web App (PWA)
**Sessions:** 2

#### Session 1: PWA Setup (50 min)
**Topics:** Service worker, manifest.json, offline support

**Exercises:**
1. Create manifest.json
2. Add app icons
3. Register service worker
4. Test "Add to Home Screen"
5. Implement offline fallback page
6. Cache static assets

**Practice Problems:**
- Problem 1: Create manifest.json with app metadata
- Problem 2: Generate app icons in multiple sizes
- Problem 3: Register service worker in index.html
- Problem 4: Test PWA installation on mobile
- Problem 5: Show offline page when no internet connection

**Hints:**
- Vite has PWA plugin: vite-plugin-pwa
- Manifest includes name, icons, theme_color, start_url
- Service worker caches assets for offline use
- Test with Chrome DevTools â†’ Application â†’ Manifest

#### Session 2: Caching Strategy (50 min)
**Topics:** Cache-first, network-first, stale-while-revalidate

**Exercises:**
1. Implement cache-first strategy for static assets
2. Implement network-first for API calls
3. Cache API responses with expiration
4. Add background sync for offline actions
5. Test offline functionality
6. Add update notification

**Practice Problems:**
- Problem 1: Cache static assets (JS, CSS, images) on install
- Problem 2: Use network-first for API calls with fallback to cache
- Problem 3: Cache API responses for 5 minutes
- Problem 4: Queue failed API calls for retry when back online
- Problem 5: Show notification when new version is available

**Hints:**
- Workbox library simplifies service worker logic
- Cache strategies: CacheFirst, NetworkFirst, StaleWhileRevalidate
- Background sync: sync event when connection restored

**Commit:** `Day 120: Progressive Web App features`

---

### Tuesday, Apr 29 - Day 121
**Topic:** Blog Frontend - Deployment
**Sessions:** 2

#### Session 1: Vercel Deployment (50 min)
**Topics:** Deploy frontend, environment variables, custom domain

**Exercises:**
1. Create Vercel account
2. Connect GitHub repository
3. Configure build settings
4. Set environment variables
5. Deploy production build
6. Test deployed application

**Practice Problems:**
- Problem 1: Deploy frontend to Vercel via GitHub integration
- Problem 2: Configure build command and output directory
- Problem 3: Add VITE_API_URL environment variable
- Problem 4: Test production deployment works correctly
- Problem 5: Set up automatic deployments on git push

**Hints:**
- Vercel auto-detects Vite projects
- Environment variables: Settings â†’ Environment Variables
- Preview deployments for PRs
- Custom domain: add in Vercel dashboard

#### Session 2: Production Optimization (50 min)
**Topics:** Bundle size, performance, analytics

**Exercises:**
1. Analyze bundle size
2. Optimize imports (tree shaking)
3. Add compression
4. Configure caching headers
5. Add analytics (optional)
6. Set up monitoring

**Practice Problems:**
- Problem 1: Run bundle analyzer to identify large dependencies
- Problem 2: Optimize imports (import only what you need)
- Problem 3: Enable compression in Vercel
- Problem 4: Configure cache headers for static assets
- Problem 5: Add Vercel Analytics or Google Analytics

**Hints:**
- Use vite-plugin-bundle-analyzer
- Lazy load heavy components
- Vercel automatically handles caching
- Monitor Core Web Vitals

**Commit:** `Day 121: Frontend deployment and optimization`

---

### Wednesday, Apr 30 - Day 122
**Topic:** Full-Stack Blog - Connect Frontend & Backend
**Sessions:** 2

#### Session 1: API Integration (50 min)
**Topics:** Connect deployed frontend to deployed backend

**Exercises:**
1. Update API base URL to production backend
2. Handle CORS properly
3. Test all API endpoints from frontend
4. Fix any connection issues
5. Test authentication flow
6. Verify file uploads work

**Practice Problems:**
- Problem 1: Update VITE_API_URL to production backend URL
- Problem 2: Configure CORS on backend to allow frontend domain
- Problem 3: Test login/register from deployed frontend
- Problem 4: Test CRUD operations work end-to-end
- Problem 5: Test file uploads work in production

**Hints:**
- Backend CORS: allow frontend domain
- Check browser console for CORS errors
- Verify environment variables are set correctly
- Test with real user account

#### Session 2: End-to-End Testing (50 min)
**Topics:** Test complete application in production

**Exercises:**
1. Test full user registration flow
2. Test creating and viewing posts
3. Test commenting
4. Test like and bookmark
5. Test search and filters
6. Document any bugs and fix them

**Practice Problems:**
- Problem 1: Create new account on production site
- Problem 2: Create a blog post with image
- Problem 3: Comment on a post
- Problem 4: Like and bookmark posts
- Problem 5: Test search functionality

**Hints:**
- Test like a real user would
- Check all features work in production
- Monitor backend logs for errors
- Fix issues and redeploy

**Commit:** `Day 122: Full-stack integration and testing`

---

### Thursday, May 1 - Day 123
**Topic:** Blog Project - Polish & Documentation
**Sessions:** 2

#### Session 1: UI Polish (50 min)
**Topics:** Final UI improvements, consistency, UX

**Exercises:**
1. Review all pages for consistency
2. Improve error messages
3. Add helpful tooltips
4. Improve mobile experience
5. Add loading skeletons everywhere
6. Polish animations and transitions

**Practice Problems:**
- Problem 1: Ensure consistent spacing, colors, fonts across all pages
- Problem 2: Make error messages user-friendly and actionable
- Problem 3: Add tooltips for icon buttons
- Problem 4: Test and improve mobile UX
- Problem 5: Add smooth transitions between pages

**Hints:**
- Use design system for consistency
- Get feedback from others
- Test on different devices
- Small UX improvements matter

#### Session 2: Documentation (50 min)
**Topics:** README, API docs, deployment guide

**Exercises:**
1. Write comprehensive README for frontend
2. Write comprehensive README for backend
3. Add setup instructions
4. Document environment variables
5. Add screenshots and demo GIF
6. Create architecture diagram

**Practice Problems:**
- Problem 1: Write README with project description, features, tech stack
- Problem 2: Add local development setup instructions
- Problem 3: Document all environment variables needed
- Problem 4: Add screenshots of key features
- Problem 5: Create simple architecture diagram (frontend â†’ backend â†’ database)

**Hints:**
- README should help someone else run your project
- Include prerequisites (Node version, etc.)
- Add badges (build status, etc.)
- Use tools like Excalidraw for diagrams

**Commit:** `Day 123: UI polish and documentation`

---

### Friday, May 2 - Day 124
**Topic:** Portfolio Website - Setup
**Sessions:** 2

#### Session 1: Portfolio Design (50 min)
**Topics:** Personal branding, portfolio structure

**Exercises:**
1. Plan portfolio structure (sections)
2. Choose color scheme and fonts
3. Create wireframes for pages
4. Design hero section
5. Design project showcase section
6. Design about and contact sections

**Practice Problems:**
- Problem 1: Sketch layout for homepage (hero, projects, about, contact)
- Problem 2: Choose 2-3 colors for brand palette
- Problem 3: Design project card layout
- Problem 4: Write compelling headline and bio
- Problem 5: Plan project showcase (what to highlight for each)

**Hints:**
- Keep it simple and professional
- Focus on projects, not decoration
- Use tools like Figma (optional) or pen and paper
- Look at other developer portfolios for inspiration

#### Session 2: Portfolio Build - Part 1 (50 min)
**Topics:** Create React app for portfolio

**Exercises:**
1. Create new Vite + React + TypeScript project
2. Set up routing
3. Create layout component
4. Build hero section with name and title
5. Add navigation
6. Make it responsive

**Practice Problems:**
- Problem 1: Create portfolio project with Vite
- Problem 2: Add routes: /, /projects, /about, /contact
- Problem 3: Create hero section with your name and "Full-Stack Developer"
- Problem 4: Add navigation menu
- Problem 5: Make header responsive for mobile

**Hints:**
- Keep it simple initially
- Focus on content over fancy animations
- Use TailwindCSS or plain CSS
- Mobile-first approach

**Commit:** `Day 124: Portfolio website setup`

---

### Saturday, May 3 - Day 125
**Topic:** Portfolio Website - Projects Section
**Sessions:** 2

#### Session 1: Project Cards (50 min)
**Topics:** Showcase your projects

**Exercises:**
1. Create project data (JSON or TypeScript)
2. Build project card component
3. Display all projects in grid
4. Add project images/screenshots
5. Add tech stack tags
6. Add links to live demo and GitHub

**Practice Problems:**
- Problem 1: Create array of project objects (title, description, image, tech, links)
- Problem 2: Build ProjectCard component displaying all info
- Problem 3: Create responsive grid of project cards
- Problem 4: Add tech stack badges (React, NestJS, etc.)
- Problem 5: Add "Live Demo" and "GitHub" buttons

**Hints:**
- Include your blog project
- Add Task API, Weather App, and other projects
- Use high-quality screenshots
- Highlight key features in descriptions

#### Session 2: Project Detail (Optional) (50 min)
**Topics:** Individual project pages

**Exercises:**
1. Create project detail page
2. Add detailed description
3. Add multiple screenshots
4. List key features
5. Describe challenges and solutions
6. Add lessons learned

**Practice Problems:**
- Problem 1: Create /projects/:slug route
- Problem 2: Create detailed project page with multiple sections
- Problem 3: Add carousel for multiple screenshots
- Problem 4: Write about technical challenges faced
- Problem 5: Describe what you learned from the project

**Hints:**
- Optional but impressive
- Shows communication skills
- Demonstrates problem-solving
- Good for interview talking points

**Commit:** `Day 125: Portfolio projects section`

---

### Sunday, May 4 - Day 126
**Topic:** Portfolio Website - About & Contact
**Sessions:** 2

#### Session 1: About Section (50 min)
**Topics:** Tell your story, skills display

**Exercises:**
1. Write compelling bio
2. Create skills section with icons
3. Add experience/timeline
4. Include education and certifications
5. Add downloadable resume link
6. Make it personal but professional

**Practice Problems:**
- Problem 1: Write 2-3 paragraph bio highlighting your journey
- Problem 2: Create skills grid with icons (React, TypeScript, Node, etc.)
- Problem 3: Add timeline showing learning journey
- Problem 4: Create resume PDF and add download button
- Problem 5: Add professional photo or avatar

**Hints:**
- Tell your unique story (HCL Domino â†’ modern dev)
- Quantify: "500+ hours of intensive learning"
- Highlight soft skills: problem-solving, self-motivated
- Keep it concise

#### Session 2: Contact Section (50 min)
**Topics:** Contact form, social links

**Exercises:**
1. Create contact form (name, email, message)
2. Add form validation
3. Integrate email service (EmailJS or similar)
4. Add social media links (GitHub, LinkedIn, Twitter)
5. Add email address
6. Test form submission

**Practice Problems:**
- Problem 1: Create contact form with validation
- Problem 2: Integrate EmailJS for form submissions
- Problem 3: Add GitHub, LinkedIn, Twitter links with icons
- Problem 4: Display email address with copy button
- Problem 5: Show success message after form submission

**Hints:**
- EmailJS is free for limited sends
- Alternative: use backend API for contact form
- Make social links prominent
- Test form works in production

**Commit:** `Day 126: Portfolio about and contact sections`

---

### Monday, May 5 - Day 127
**Topic:** Portfolio Website - Final Touches
**Sessions:** 2

#### Session 1: Animations & Interactions (50 min)
**Topics:** Smooth scrolling, fade-ins, hover effects

**Exercises:**
1. Add smooth scroll behavior
2. Implement scroll animations (fade in on scroll)
3. Add hover effects to buttons and cards
4. Add loading animations
5. Add transitions between sections
6. Test performance

**Practice Problems:**
- Problem 1: Add smooth scrolling for navigation links
- Problem 2: Use Intersection Observer for fade-in animations
- Problem 3: Add hover effects to project cards (scale, shadow)
- Problem 4: Add subtle animations to hero section
- Problem 5: Ensure animations don't hurt performance

**Hints:**
- Use CSS transitions for smooth effects
- Intersection Observer for scroll animations
- Keep animations subtle and professional
- Test on mobile (animations should work well)

#### Session 2: SEO & Deployment (50 min)
**Topics:** Meta tags, deploy to Vercel

**Exercises:**
1. Add meta tags for SEO
2. Add Open Graph tags
3. Create favicon
4. Optimize images
5. Deploy to Vercel
6. Test deployed site

**Practice Problems:**
- Problem 1: Add title, description, keywords meta tags
- Problem 2: Add Open Graph image for social sharing
- Problem 3: Create and add favicon
- Problem 4: Optimize all images (compress, lazy load)
- Problem 5: Deploy to Vercel and test

**Hints:**
- Use react-helmet-async
- Create OG image with your name and title
- Test with social media preview tools
- Custom domain if you have one

**Commit:** `Day 127: Portfolio animations and deployment`

---

### Tuesday, May 6 - Day 128
**Topic:** React Phase Complete - Review & Polish
**Sessions:** 2

#### Session 1: Blog App Final Review (50 min)
**Topics:** Test everything, fix bugs, polish

**Exercises:**
1. Test all blog features
2. Fix any remaining bugs
3. Improve performance
4. Update documentation
5. Record demo video
6. Take screenshots for portfolio

**Practice Problems:**
- Problem 1: Go through entire blog app as a user, note issues
- Problem 2: Fix all bugs found
- Problem 3: Run Lighthouse audit, improve score
- Problem 4: Update README with latest features
- Problem 5: Record screen recording of key features

**Hints:**
- Test in multiple browsers
- Ask friend/family to test
- Check mobile experience
- Update GitHub README

#### Session 2: Portfolio Final Review (50 min)
**Topics:** Final portfolio polish

**Exercises:**
1. Review portfolio site
2. Update with all projects
3. Proofread all text
4. Test all links work
5. Get feedback
6. Make final improvements

**Practice Problems:**
- Problem 1: Ensure all projects are listed with correct info
- Problem 2: Proofread bio, project descriptions for typos
- Problem 3: Test all external links work (GitHub, demos)
- Problem 4: Test contact form works
- Problem 5: Share with someone for feedback

**Hints:**
- First impressions matter
- Check for typos and grammar
- Ensure everything works
- Mobile experience is critical

**Commit:** `Day 128: React phase complete - blog and portfolio ready!`

---

## ðŸŽ‰ PHASE 3 COMPLETE!

**You've finished Phase 3 (Days 88-128)! Achievements:**
- âœ… React fundamentals mastered
- âœ… Hooks (useState, useEffect, useContext, useReducer, custom hooks)
- âœ… React Router for navigation
- âœ… TypeScript + React
- âœ… State management (Context, Zustand)
- âœ… Performance optimization
- âœ… Testing React components
- âœ… Complete blog frontend built and deployed
- âœ… Professional portfolio website

**Key Projects Built:**
- Full-featured blog frontend with authentication
- Personal portfolio website
- Multiple React components and custom hooks

**Ready for Phase 4: Full-Stack Integration!**

---

# PHASE 4: FULL-STACK INTEGRATION
## May 8 - June 14 (5+ weeks, Days 129-166)

**Focus:** Connecting React frontends to NestJS backends, building complete full-stack applications

---

### Thursday, May 7 - Day 129
**Topic:** Full-Stack Architecture Planning
**Sessions:** 2

#### Session 1: Project Selection & Planning (50 min)
**Topics:** Choose capstone project, plan architecture

**Exercises:**
1. Choose a full-stack project idea (or use provided)
2. Define core features (MVP)
3. Design database schema
4. Plan API endpoints
5. Sketch UI wireframes
6. Create project timeline

**Project Options:**
- **Job Board:** Post jobs, apply, employer dashboard
- **Social Network:** User profiles, posts, follows, feed
- **Marketplace:** List items, buy/sell, reviews, payments
- **Fitness Tracker:** Log workouts, track progress, social features
- **Recipe Manager:** Save recipes, meal planning, grocery lists

**Practice Problems:**
- Problem 1: Choose one project and list 5-7 core features
- Problem 2: Design database schema (users, main entities, relationships)
- Problem 3: List all API endpoints needed (method, path, auth)
- Problem 4: Sketch main pages/views
- Problem 5: Break down into 2-week sprint

**Hints:**
- Choose project that interests you
- Keep MVP small (can add features later)
- Focus on demonstrating full-stack skills
- Plan for authentication, CRUD, relationships

#### Session 2: Setup Full-Stack Project (50 min)
**Topics:** Monorepo or separate repos, initial setup

**Exercises:**
1. Create backend repository (NestJS)
2. Create frontend repository (React)
3. Set up PostgreSQL database
4. Initialize Prisma
5. Set up Git repos
6. Create initial project structure

**Practice Problems:**
- Problem 1: Create backend project with NestJS CLI
- Problem 2: Create frontend project with Vite
- Problem 3: Set up PostgreSQL with Docker
- Problem 4: Initialize Prisma in backend
- Problem 5: Create database schema in schema.prisma

**Hints:**
- Use what you've learned (don't start from scratch mentally)
- Reference blog API for backend patterns
- Reference blog frontend for React patterns
- Version control from day 1

**Commit:** `Day 129: Full-stack project planning and setup`

---

### Days 130-145 (May 8-23): Build Capstone Project

**Daily Pattern:**
- Session 1: Backend feature (API endpoint, database, business logic)
- Session 2: Frontend feature (UI, state management, API integration)

**Week 1 (Days 130-136): Core Features**

### Day 130: Authentication System
- Backend: Auth module, JWT strategy, register/login endpoints
- Frontend: Login/register pages, auth context, protected routes

### Day 131: User Profiles
- Backend: User CRUD endpoints, profile update
- Frontend: Profile page, edit profile form

### Day 132: Main Entity CRUD - Part 1
- Backend: Create main entity (jobs, posts, products, etc.)
- Frontend: Create form for main entity

### Day 133: Main Entity CRUD - Part 2
- Backend: Read, update, delete endpoints
- Frontend: List view, detail view, edit/delete

### Day 134: Relationships - Part 1
- Backend: Add related entity (applications, comments, orders)
- Frontend: Display related data

### Day 135: Relationships - Part 2
- Backend: Create/delete related entities
- Frontend: Forms and actions for related entities

### Day 136: Search & Filters
- Backend: Search endpoint with filters
- Frontend: Search bar, filter UI, results

**Week 2 (Days 137-143): Advanced Features**

### Day 137: File Uploads
- Backend: Image upload endpoint, S3 integration
- Frontend: File input, image preview, upload

### Day 138: Pagination
- Backend: Paginated responses
- Frontend: Pagination UI, infinite scroll

### Day 139: User Interactions - Part 1
- Backend: Likes/favorites endpoints
- Frontend: Like button, favorites page

### Day 140: User Interactions - Part 2
- Backend: Comments/reviews system
- Frontend: Comment form, comment list

### Day 141: Notifications
- Backend: Notification creation, endpoints
- Frontend: Notification bell, notification list

### Day 142: Email Integration
- Backend: Email service, transactional emails
- Frontend: Email verification, password reset

### Day 143: Admin Features
- Backend: Admin role, admin-only endpoints
- Frontend: Admin dashboard, moderation

**Days 144-145: Testing & Polish**

### Day 144: Testing
- Backend: Integration tests for key endpoints
- Frontend: Component tests for key features

### Day 145: Bug Fixes & Polish
- Fix all bugs
- Improve error handling
- Polish UI/UX

**Commit:** `Days 130-145: Capstone project core and advanced features`

---

### Days 146-152 (May 24-30): Second Full-Stack Project

**Build a different project to reinforce skills:**

### Day 146-147: Project 2 Setup
- Plan second project (different domain)
- Set up backend and frontend
- Database schema

### Day 148-149: Core Features
- Authentication
- Main CRUD operations
- Basic relationships

### Day 150-151: Advanced Features
- Search, filters, pagination
- File uploads
- User interactions

### Day 152: Testing & Deployment
- Write tests
- Deploy both backend and frontend
- Documentation

**Commit:** `Days 146-152: Second full-stack project complete`

---

### Days 153-159 (May 31 - Jun 6): Third Full-Stack Project (Smaller)

**Quick project demonstrating specific skills:**

### Day 153-154: Real-Time Chat Application
- WebSocket server setup
- Real-time messaging
- User presence

### Day 155-156: Chat Features
- Group chats/rooms
- Message history
- File sharing

### Day 157: Chat Polish
- UI improvements
- Notifications
- Mobile responsive

### Day 158-159: Video Chat Integration (Optional)
- WebRTC basics
- Peer-to-peer video
- Or: focus on deployment and documentation

**Commit:** `Days 153-159: Real-time chat application`

---

### Days 160-166 (Jun 7-13): Project Portfolio Polish

### Day 160: Project Documentation
**Sessions:** 2
- Write comprehensive READMEs for all projects
- Add architecture diagrams
- Document API endpoints
- Create setup guides

### Day 161: Demo Videos
**Sessions:** 2
- Record demo video for capstone project
- Record demos for other projects
- Edit and upload to YouTube/portfolio
- Add video links to portfolio

### Day 162: Portfolio Update
**Sessions:** 2
- Add all projects to portfolio site
- Update project descriptions
- Add new skills to about section
- Fresh screenshots

### Day 163: GitHub Profile Polish
**Sessions:** 2
- Update GitHub profile README
- Pin best repositories
- Ensure good commit history
- Add project descriptions

### Day 164: LinkedIn & Resume Update
**Sessions:** 2
- Update LinkedIn with new skills and projects
- Refresh resume with quantified achievements
- Write compelling project descriptions
- Get resume reviewed

### Day 165: Technical Blog Posts (Optional)
**Sessions:** 2
- Write blog post about building your capstone
- Discuss challenges and solutions
- Share on dev.to or Medium
- Link from portfolio

### Day 166: Final Full-Stack Review
**Sessions:** 2
- Review all projects
- Fix any remaining bugs
- Test all deployments
- Prepare project presentation talking points

**Commit:** `Days 160-166: Portfolio and documentation complete`

---

## ðŸŽ‰ PHASE 4 COMPLETE!

**You've finished Phase 4 (Days 129-166)! Achievements:**
- âœ… Built 2-3 complete full-stack applications
- âœ… Connected React frontends to NestJS backends
- âœ… Implemented authentication end-to-end
- âœ… Managed complex state across frontend and backend
- âœ… Deployed full-stack applications
- âœ… Professional documentation and demos
- âœ… Updated portfolio with all projects

**Key Projects Built:**
- Capstone full-stack application (comprehensive features)
- Second full-stack project (different domain)
- Real-time chat application (WebSockets)

**Ready for Phase 5: Interview Preparation!**

---

# PHASE 5: JOB READY & INTERVIEW PREP
## June 15 - July 14 (4 weeks, Days 167-196)

**Focus:** LeetCode, system design, portfolio polish, job applications

---

## Week 1 (Days 167-173): Data Structures & Algorithms Fundamentals

### Day 167: Arrays & Hash Tables
**Sessions:** 2
**Topics:** Array manipulation, hash map patterns

**LeetCode Problems:**
1. Two Sum (Easy)
2. Contains Duplicate (Easy)
3. Valid Anagram (Easy)
4. Group Anagrams (Medium)
5. Top K Frequent Elements (Medium)

**Practice:**
- Session 1: Solve 2 easy problems
- Session 2: Solve 2 medium problems, review patterns

**Key Patterns:**
- Hash map for O(1) lookup
- Frequency counting
- Sliding window basics

---

### Day 168: Two Pointers
**Sessions:** 2
**Topics:** Two pointer technique, multiple pointers

**LeetCode Problems:**
1. Valid Palindrome (Easy)
2. Two Sum II (Medium)
3. 3Sum (Medium)
4. Container With Most Water (Medium)
5. Trapping Rain Water (Hard)

**Practice:**
- Session 1: Easy + 1 medium
- Session 2: 2 medium problems

**Key Patterns:**
- Left and right pointers
- Fast and slow pointers
- Meeting point problems

---

### Day 169: Sliding Window
**Sessions:** 2
**Topics:** Fixed and dynamic sliding window

**LeetCode Problems:**
1. Best Time to Buy and Sell Stock (Easy)
2. Longest Substring Without Repeating Characters (Medium)
3. Longest Repeating Character Replacement (Medium)
4. Permutation in String (Medium)
5. Minimum Window Substring (Hard)

**Practice:**
- Session 1: 2 problems with notes
- Session 2: 2 problems, time yourself

**Key Patterns:**
- Expand window when condition met
- Shrink window when invalid
- Track min/max window size

---

### Day 170: Linked Lists - Part 1
**Sessions:** 2
**Topics:** Linked list basics, reversal, fast/slow pointers

**LeetCode Problems:**
1. Reverse Linked List (Easy)
2. Merge Two Sorted Lists (Easy)
3. Linked List Cycle (Easy)
4. Remove Nth Node From End (Medium)
5. Reorder List (Medium)

**Practice:**
- Session 1: Understand linked list structure, solve 2 easy
- Session 2: 2 medium problems

**Key Patterns:**
- Dummy head node
- Fast and slow pointers for cycle detection
- Reversal technique

---

### Day 171: Linked Lists - Part 2
**Sessions:** 2
**Topics:** Advanced linked list problems

**LeetCode Problems:**
1. Merge K Sorted Lists (Hard)
2. Reverse Nodes in K Group (Hard)
3. LRU Cache (Medium)
4. Copy List with Random Pointer (Medium)
5. Add Two Numbers (Medium)

**Practice:**
- Session 1: 2 medium problems
- Session 2: Review all linked list patterns

**Key Patterns:**
- Multiple pointers
- Recursion vs iteration
- Node manipulation

---

### Day 172: Stacks & Queues
**Sessions:** 2
**Topics:** Stack and queue patterns, monotonic stack

**LeetCode Problems:**
1. Valid Parentheses (Easy)
2. Min Stack (Medium)
3. Evaluate Reverse Polish Notation (Medium)
4. Daily Temperatures (Medium)
5. Largest Rectangle in Histogram (Hard)

**Practice:**
- Session 1: Stack basics, 2 problems
- Session 2: Monotonic stack pattern

**Key Patterns:**
- Stack for matching problems
- Monotonic stack for next greater/smaller
- Queue for BFS

---

### Day 173: Week 1 Review
**Sessions:** 2
**Topics:** Review all patterns, solve mixed problems

**Practice:**
- Session 1: Solve 3 problems from different topics
- Session 2: Mock interview practice (45 min)

**Reflection:**
- Which patterns are hardest?
- Time management strategies
- Communication practice

---

## Week 2 (Days 174-180): Trees, Graphs & Recursion

### Day 174: Binary Trees - Part 1
**Sessions:** 2
**Topics:** Tree traversal, DFS

**LeetCode Problems:**
1. Invert Binary Tree (Easy)
2. Maximum Depth of Binary Tree (Easy)
3. Same Tree (Easy)
4. Subtree of Another Tree (Easy)
5. Binary Tree Level Order Traversal (Medium)

**Practice:**
- Session 1: Tree basics, 3 easy problems
- Session 2: Level order traversal

**Key Patterns:**
- Recursive DFS (preorder, inorder, postorder)
- Iterative BFS (level order)
- Tree properties

---

### Day 175: Binary Trees - Part 2
**Sessions:** 2
**Topics:** Advanced tree problems

**LeetCode Problems:**
1. Lowest Common Ancestor (Medium)
2. Validate Binary Search Tree (Medium)
3. Kth Smallest Element in BST (Medium)
4. Binary Tree Maximum Path Sum (Hard)
5. Serialize and Deserialize Binary Tree (Hard)

**Practice:**
- Session 1: BST properties
- Session 2: Hard problems

**Key Patterns:**
- BST properties (left < root < right)
- Path problems
- Tree construction

---

### Day 176: Tries
**Sessions:** 2
**Topics:** Prefix trees, word search

**LeetCode Problems:**
1. Implement Trie (Medium)
2. Design Add and Search Words Data Structure (Medium)
3. Word Search II (Hard)
4. Longest Common Prefix (Easy)

**Practice:**
- Session 1: Implement trie from scratch
- Session 2: Trie applications

**Key Patterns:**
- Prefix matching
- Autocomplete
- Word validation

---

### Day 177: Graphs - Part 1
**Sessions:** 2
**Topics:** Graph representation, DFS, BFS

**LeetCode Problems:**
1. Number of Islands (Medium)
2. Clone Graph (Medium)
3. Pacific Atlantic Water Flow (Medium)
4. Course Schedule (Medium)
5. Graph Valid Tree (Medium)

**Practice:**
- Session 1: Graph traversal basics
- Session 2: Application problems

**Key Patterns:**
- Adjacency list representation
- Visited set
- DFS vs BFS choice

---

### Day 178: Graphs - Part 2
**Sessions:** 2
**Topics:** Advanced graph algorithms

**LeetCode Problems:**
1. Course Schedule II (Medium)
2. Word Ladder (Hard)
3. Network Delay Time (Medium)
4. Min Cost to Connect All Points (Medium)
5. Alien Dictionary (Hard)

**Practice:**
- Session 1: Topological sort
- Session 2: Shortest path

**Key Patterns:**
- Topological sort (Kahn's algorithm)
- Dijkstra's shortest path
- Union find

---

### Day 179: Backtracking
**Sessions:** 2
**Topics:** Decision trees, backtracking

**LeetCode Problems:**
1. Subsets (Medium)
2. Combination Sum (Medium)
3. Permutations (Medium)
4. Word Search (Medium)
5. N-Queens (Hard)

**Practice:**
- Session 1: Backtracking template
- Session 2: Apply to problems

**Key Patterns:**
- Choose, explore, unchoose
- Decision tree
- Pruning

---

### Day 180: Week 2 Review
**Sessions:** 2
**Topics:** Review trees, graphs, backtracking

**Practice:**
- Session 1: 3 mixed problems
- Session 2: Mock interview

---

## Week 3 (Days 181-187): Dynamic Programming & System Design

### Day 181: Dynamic Programming - 1D
**Sessions:** 2
**Topics:** DP fundamentals, 1D DP

**LeetCode Problems:**
1. Climbing Stairs (Easy)
2. House Robber (Medium)
3. Longest Increasing Subsequence (Medium)
4. Word Break (Medium)
5. Decode Ways (Medium)

**Practice:**
- Session 1: DP concept, memoization
- Session 2: Bottom-up DP

**Key Patterns:**
- Identify overlapping subproblems
- Define recurrence relation
- Memoization vs tabulation

---

### Day 182: Dynamic Programming - 2D
**Sessions:** 2
**Topics:** 2D DP, grid problems

**LeetCode Problems:**
1. Unique Paths (Medium)
2. Longest Common Subsequence (Medium)
3. Best Time to Buy and Sell Stock with Cooldown (Medium)
4. Coin Change 2 (Medium)
5. Edit Distance (Hard)

**Practice:**
- Session 1: 2D DP patterns
- Session 2: Apply to problems

**Key Patterns:**
- 2D state definition
- Grid traversal
- String matching

---

### Day 183: Greedy Algorithms
**Sessions:** 2
**Topics:** Greedy choice, intervals

**LeetCode Problems:**
1. Maximum Subarray (Medium)
2. Jump Game (Medium)
3. Gas Station (Medium)
4. Merge Intervals (Medium)
5. Non-overlapping Intervals (Medium)

**Practice:**
- Session 1: Greedy vs DP
- Session 2: Interval problems

**Key Patterns:**
- Locally optimal choices
- Proof of correctness
- Sorting first

---

### Day 184: System Design - Fundamentals
**Sessions:** 2
**Topics:** Scalability, load balancing, caching

**Study Topics:**
1. Horizontal vs vertical scaling
2. Load balancing strategies
3. Caching (Redis patterns)
4. Database replication
5. CAP theorem

**Practice:**
- Session 1: Study concepts, take notes
- Session 2: Draw diagrams, explain out loud

**Resources:**
- System Design Primer (GitHub)
- Gaurav Sen YouTube videos

---

### Day 185: System Design - URL Shortener
**Sessions:** 2
**Topics:** Design URL shortening service

**Requirements:**
- Shorten long URLs
- Redirect short URLs
- Analytics
- Scale to millions of users

**Practice:**
- Session 1: Requirements, API design, database schema
- Session 2: Scalability, caching, load balancing

**Key Concepts:**
- Base62 encoding
- Database sharding
- Caching strategy
- Rate limiting

---

### Day 186: System Design - Twitter/Instagram Feed
**Sessions:** 2
**Topics:** Design social media feed

**Requirements:**
- Post content
- Follow users
- View feed
- Notifications
- Scale to millions

**Practice:**
- Session 1: Data model, API design
- Session 2: Feed generation, caching, ranking

**Key Concepts:**
- Fan-out on write vs read
- Timeline generation
- Push vs pull
- Ranking algorithms

---

### Day 187: Week 3 Review
**Sessions:** 2
**Topics:** DP review, system design practice

**Practice:**
- Session 1: 2 DP problems
- Session 2: Mock system design interview

---

## Week 4 (Days 188-194): Interview Prep & Applications

### Day 188: Behavioral Interview Prep
**Sessions:** 2
**Topics:** STAR method, tell your story

**Preparation:**
- Write down 10 project stories
- STAR format (Situation, Task, Action, Result)
- Practice out loud

**Common Questions:**
1. Tell me about yourself
2. Why software development?
3. Tell me about a challenging project
4. How do you handle deadlines?
5. Describe a time you solved a difficult problem
6. How do you handle feedback?
7. Why our company?
8. Where do you see yourself in 5 years?

**Practice:**
- Session 1: Write STAR stories
- Session 2: Practice with timer (2 min each)

---

### Day 189: Resume & Cover Letter Polish
**Sessions:** 2
**Topics:** Final resume review, cover letter template

**Tasks:**
- Update resume with all projects
- Quantify achievements
- Tailor for full-stack roles
- Write cover letter template
- Get feedback from others

**Resume Highlights:**
- "Built 8 full-stack applications with modern tech stack"
- "500+ hours self-directed learning"
- "Proficient in React, TypeScript, NestJS, PostgreSQL"
- List projects with tech stack and impact

---

### Day 190: Portfolio & GitHub Final Review
**Sessions:** 2
**Topics:** Portfolio polish, GitHub profile

**Tasks:**
- Review portfolio site (mobile + desktop)
- Update GitHub profile README
- Pin best repositories
- Ensure all READMEs are excellent
- Add demo GIFs to projects
- Check all live demo links work

**GitHub Profile README:**
- Introduction with tech stack
- Featured projects with links
- GitHub stats
- Contact information

---

### Day 191: Mock Interviews - Technical
**Sessions:** 2
**Topics:** Full technical interview simulation

**Practice:**
- Session 1: 2 LeetCode mediums (45 min)
- Session 2: System design problem (45 min)

**Use:**
- Pramp for peer interviews
- LeetCode's mock interview feature
- Time yourself strictly

**Focus:**
- Think out loud
- Ask clarifying questions
- Explain approach before coding
- Test with examples

---

### Day 192: Mock Interviews - Behavioral
**Sessions:** 2
**Topics:** Behavioral interview practice

**Practice:**
- Session 1: Answer 10 behavioral questions
- Session 2: Practice with partner or record yourself

**Evaluate:**
- Clarity of answers
- STAR format usage
- Confidence
- Authenticity

---

### Day 193: Job Applications - Day 1
**Sessions:** 2
**Topics:** Apply to first batch of jobs

**Tasks:**
- Research 20 companies
- Apply to 10 companies today
- Customize each application
- Track applications in spreadsheet

**Target Companies:**
- Startups (high growth, modern stack)
- Mid-size companies (good engineering culture)
- Remote-friendly companies
- Companies using React/Node.js/TypeScript

**Application Tracking:**
- Company name
- Position title
- Date applied
- Status
- Follow-up date
- Notes

---

### Day 194: Job Applications - Day 2
**Sessions:** 2
**Topics:** Apply to more jobs, recruiter outreach

**Tasks:**
- Apply to 10 more companies
- Reach out to 5 recruiters on LinkedIn
- Join relevant Slack/Discord communities
- Network with developers in target companies

**LinkedIn Strategy:**
- Update headline: "Full-Stack Developer | React, TypeScript, NestJS"
- Open to work badge
- Connect with recruiters
- Engage with content

---

### Days 195-196: Final Prep

### Day 195: LeetCode Final Sprint
**Sessions:** 2
**Topics:** Solve problems from weak areas

**Practice:**
- Session 1: 3 problems from weakest topic
- Session 2: 2 random medium problems

**Goal:**
- Build confidence
- Stay sharp
- Time management

---

### Day 196: Final Review & Reflection
**Sessions:** 2
**Topics:** Review everything, celebrate progress

**Tasks:**
- Review your 196-day journey
- Update portfolio with any final touches
- Prepare for upcoming interviews
- Set goals for month 7+

**Reflection Questions:**
1. What am I most proud of?
2. What was hardest?
3. What would I do differently?
4. What surprised me?
5. How do I feel about job search?

**Celebrate:**
- You completed 196 days!
- You have a portfolio of projects
- You can build full-stack applications
- You're ready to interview
- You're a developer now!

---

## ðŸŽ‰ PHASE 5 COMPLETE!

**You've finished Phase 5 (Days 167-196)! Achievements:**
- âœ… Solved 50+ LeetCode problems across all topics
- âœ… Mastered common algorithm patterns
- âœ… Practiced system design
- âœ… Prepared behavioral interview answers
- âœ… Polished resume and portfolio
- âœ… Applied to 20+ companies
- âœ… Completed 196-day journey!

**LeetCode Topics Covered:**
- Arrays & Hash Tables
- Two Pointers & Sliding Window
- Linked Lists
- Stacks & Queues
- Binary Trees & BSTs
- Tries
- Graphs & Backtracking
- Dynamic Programming
- Greedy Algorithms

**System Design Topics:**
- Scalability fundamentals
- Caching strategies
- Load balancing
- Database design
- URL Shortener
- Social media feed

**Interview Skills:**
- Technical communication
- Problem-solving approach
- STAR method for behavioral
- Portfolio presentation

**Ready for Extended Plan: Months 7-12!**

---

# ðŸš€ EXTENDED PLAN: MONTHS 7-12 (GETTING ACTUALLY JOB-READY)

**Reality Check:** The first 6 months give you knowledge. The next 6 months make you hireable.

---

# PHASE 6: DEVOPS & PRODUCTION INFRASTRUCTURE
## July 15 - September 12 (8 weeks, Days 197-256)

**Focus:** Advanced Docker, Kubernetes, CI/CD, Cloud deployment, webhooks, monitoring - everything to deploy production apps

---

## ðŸ³ WEEK 1-2: DOCKER MASTERY (Days 197-210)

### Day 197: Docker Deep Dive - Networking
**Sessions:** 2
**Topics:** Bridge networks, host network, overlay networks, container communication
**Exercises:**
1. Create custom Docker network
2. Connect multiple containers (app + database + redis)
3. Test container-to-container communication
4. Implement service discovery with Docker DNS
5. Set up reverse proxy with nginx container
6. Configure port mapping strategies
7. Test network isolation between containers

### Day 198: Docker Volumes & Data Persistence
**Topics:** Named volumes, bind mounts, volume drivers, backup strategies
**Exercises:**
1. Create named volumes for database data
2. Implement bind mounts for development hot-reload
3. Backup and restore volume data
4. Share volumes between containers
5. Implement volume cleanup strategies
6. Test data persistence after container deletion

### Day 199: Docker Multi-Stage Builds Optimization
**Topics:** Build optimization, layer caching, security hardening
**Exercises:**
1. Build production-optimized Dockerfile for NestJS app
2. Reduce image size by 70%+ using multi-stage builds
3. Implement build caching strategies
4. Add security scanning to builds
5. Create separate dev and prod Dockerfiles
6. Benchmark build times and optimize

### Day 200: Docker Compose Advanced Patterns
**Topics:** Multiple environments, service dependencies, health checks, scaling
**Exercises:**
1. Create docker-compose.yml for full-stack app (frontend, backend, database, redis, nginx)
2. Configure health checks for all services
3. Implement service dependencies with depends_on and healthcheck
4. Create separate compose files: dev, staging, production
5. Set up environment-specific configurations
6. Implement service scaling

### Day 201-202: Container Orchestration Introduction
**Topics:** Why orchestration, Docker Swarm basics, intro to Kubernetes
**Exercises:**
1. Initialize Docker Swarm cluster
2. Deploy multi-container app to swarm
3. Implement rolling updates
4. Scale services up and down
5. Understand when you need Kubernetes vs Docker Compose
6. Set up local Kubernetes with Minikube
7. Deploy simple app to Kubernetes

### Day 203-204: CI/CD Pipeline with GitHub Actions
**Topics:** Automated testing, building, and deployment
**Exercises:**
1. Create GitHub Actions workflow for Node.js app
2. Set up automated testing on push
3. Build Docker image on PR merge
4. Push image to Docker Hub/GitHub Container Registry
5. Implement environment-specific deployments
6. Add deployment to cloud provider (Railway/Render)
7. Set up status badges in README
8. Implement rollback strategies

### Day 205-206: Cloud Deployment - DigitalOcean/AWS
**Topics:** VPS setup, Docker deployment, domain configuration, SSL
**Exercises:**
1. Provision VPS (DigitalOcean Droplet or AWS EC2)
2. Install Docker and Docker Compose
3. Set up firewall rules
4. Deploy your app with Docker Compose
5. Configure domain name (Namecheap/Google Domains)
6. Set up nginx reverse proxy
7. Configure SSL with Let's Encrypt (Certbot)
8. Set up automatic SSL renewal
9. Implement basic monitoring

### Day 207-208: Webhooks & Background Jobs
**Topics:** GitHub webhooks, Stripe webhooks, job queues, BullMQ
**Exercises:**
1. Implement GitHub webhook for CI/CD trigger
2. Create Stripe webhook handler for payment events
3. Set up webhook signature verification
4. Implement retry logic for failed webhooks
5. Install and configure Redis for job queues
6. Set up BullMQ for background job processing
7. Create jobs: send emails, process images, generate reports
8. Implement job monitoring dashboard
9. Add job failure handling and retries

### Day 209-210: Monitoring & Logging Production Apps
**Topics:** Application logs, error tracking, performance monitoring
**Exercises:**
1. Implement structured logging (Winston/Pino)
2. Set up log aggregation (Papertrail or Loki)
3. Integrate Sentry for error tracking
4. Set up application performance monitoring (APM)
5. Create health check endpoints
6. Implement uptime monitoring (UptimeRobot)
7. Set up alerts for errors and downtime
8. Create monitoring dashboard

---

## â˜¸ï¸ WEEK 3-4: KUBERNETES & ADVANCED DEVOPS (Days 211-224)

### Day 211-212: Kubernetes Fundamentals
**Topics:** Pods, Services, Deployments, ConfigMaps, Secrets
**Exercises:**
1. Install kubectl and Minikube
2. Create first pod with your app
3. Create deployment with replicas
4. Expose deployment with Service (ClusterIP, NodePort, LoadBalancer)
5. Configure environment variables with ConfigMaps
6. Store sensitive data in Secrets
7. Implement rolling updates
8. Practice rollback deployments

### Day 213-214: Kubernetes Networking & Ingress
**Topics:** Ingress controllers, load balancing, service mesh basics
**Exercises:**
1. Install nginx Ingress Controller
2. Create Ingress rules for routing
3. Configure path-based routing
4. Set up TLS/SSL in Kubernetes
5. Implement horizontal pod autoscaling
6. Configure resource limits and requests
7. Test load balancing between pods

### Day 215-216: Helm & Package Management
**Topics:** Helm charts, templating, releases
**Exercises:**
1. Install Helm
2. Deploy apps using existing Helm charts (PostgreSQL, Redis)
3. Create custom Helm chart for your app
4. Use templates and values files
5. Manage different environments (dev, staging, prod)
6. Implement chart versioning
7. Practice upgrades and rollbacks with Helm

### Day 217-218: Kubernetes Production Patterns
**Topics:** StatefulSets, Persistent Volumes, Jobs, CronJobs
**Exercises:**
1. Deploy stateful application (database) with StatefulSet
2. Configure PersistentVolumes and PersistentVolumeClaims
3. Create Kubernetes Jobs for one-time tasks
4. Set up CronJobs for scheduled tasks
5. Implement database backups with CronJobs
6. Configure pod anti-affinity for high availability
7. Set up namespaces for multi-tenant isolation

### Day 219-220: CI/CD with Kubernetes
**Topics:** GitOps, ArgoCD, automated deployments
**Exercises:**
1. Install ArgoCD or Flux
2. Connect Git repository to cluster
3. Implement GitOps workflow
4. Create multi-stage pipeline: dev â†’ staging â†’ production
5. Set up automatic deployments on Git push
6. Implement blue-green deployments
7. Test canary deployments

### Day 221-222: Infrastructure as Code - Terraform
**Topics:** Terraform basics, provisioning cloud resources
**Exercises:**
1. Install Terraform
2. Write Terraform config to provision VPS
3. Create database instances
4. Configure networking and security groups
5. Implement modules for reusability
6. Practice terraform plan, apply, destroy
7. Set up remote state storage (S3/Terraform Cloud)
8. Implement infrastructure for multi-environment setup

### Day 223-224: Security & Best Practices
**Topics:** Container security, secrets management, vulnerability scanning
**Exercises:**
1. Scan Docker images for vulnerabilities (Trivy)
2. Implement non-root containers
3. Use distroless base images
4. Set up Kubernetes RBAC (Role-Based Access Control)
5. Implement network policies
6. Configure Pod Security Standards
7. Use HashiCorp Vault for secrets management
8. Implement image signing and verification

---

## ðŸ“Š WEEK 5-8: ADVANCED BACKEND & SCALING (Days 225-256)

### Day 225-228: Microservices Architecture
**Topics:** Service decomposition, inter-service communication, API Gateway
**Exercises:**
1. Design microservices architecture for e-commerce app
2. Create 3 services: User Service, Product Service, Order Service
3. Implement gRPC for inter-service communication
4. Set up API Gateway with Kong or Express Gateway
5. Implement service discovery
6. Add distributed tracing with Jaeger
7. Handle cascading failures with circuit breakers
8. Test service resilience

### Day 229-232: Event-Driven Architecture
**Topics:** Message queues, pub/sub, event sourcing
**Exercises:**
1. Set up RabbitMQ or Apache Kafka
2. Implement event-driven communication between services
3. Create event producers and consumers
4. Implement pub/sub pattern
5. Handle event ordering and idempotency
6. Build event sourcing for order tracking
7. Implement CQRS (Command Query Responsibility Segregation)
8. Test eventual consistency scenarios

### Day 233-236: Caching & Performance Optimization
**Topics:** Redis caching strategies, CDN, database optimization
**Exercises:**
1. Implement Redis caching layer
2. Cache database queries with appropriate TTL
3. Implement cache invalidation strategies
4. Set up Redis for session storage
5. Use Redis for rate limiting
6. Implement database query optimization
7. Add database connection pooling
8. Set up CDN for static assets (Cloudflare)
9. Implement HTTP caching headers
10. Benchmark and optimize API response times

### Day 237-240: Database Scaling & Replication
**Topics:** Read replicas, sharding, connection pooling
**Exercises:**
1. Set up PostgreSQL primary-replica configuration
2. Implement read/write splitting in application
3. Configure automatic failover
4. Test replication lag handling
5. Implement database connection pooling (PgBouncer)
6. Design sharding strategy
7. Benchmark database performance
8. Implement database backup and recovery

### Day 241-244: GraphQL & Modern API Patterns
**Topics:** GraphQL server, subscriptions, federation
**Exercises:**
1. Build GraphQL API with Apollo Server
2. Design schema for existing REST API
3. Implement queries and mutations
4. Add authentication to GraphQL
5. Implement DataLoader for N+1 prevention
6. Set up GraphQL subscriptions for real-time
7. Test GraphQL performance vs REST
8. Add GraphQL Playground for documentation

### Day 245-248: Real-Time Features & WebSockets
**Topics:** Socket.io, Redis pub/sub, scaling WebSockets
**Exercises:**
1. Implement real-time chat with Socket.io
2. Add presence detection (online/offline status)
3. Implement typing indicators
4. Scale WebSockets with Redis adapter
5. Handle socket authentication
6. Implement room-based messaging
7. Add message persistence
8. Test connection stability and reconnection

### Day 249-252: Search & Elasticsearch
**Topics:** Full-text search, indexing, aggregations
**Exercises:**
1. Install Elasticsearch and Kibana
2. Index your database records to Elasticsearch
3. Implement full-text search across multiple fields
4. Add search filters and facets
5. Implement autocomplete/typeahead
6. Create search result ranking
7. Add search analytics
8. Optimize search performance

### Day 253-256: API Documentation & Developer Experience
**Topics:** OpenAPI/Swagger, API versioning, SDKs
**Exercises:**
1. Generate OpenAPI spec from NestJS controllers
2. Set up Swagger UI for API documentation
3. Implement API versioning (URL-based and header-based)
4. Create Postman collection
5. Generate API client SDKs
6. Write API usage guides
7. Add code examples for common use cases
8. Implement API playground

---

# PHASE 7-10: PURE PROJECT BUILDING (MONTHS 9-12)
## September 13 - January 17, 2027 (Days 257-366)

**NO MORE TUTORIALS. BUILD REAL, HIREABLE PROJECTS.**

Each project should be:
- âœ… Fully deployed and accessible via URL
- âœ… Professional README with screenshots
- âœ… Clean, production-quality code
- âœ… Comprehensive testing
- âœ… CI/CD pipeline
- âœ… Monitoring and logging
- âœ… Responsive design
- âœ… Added to your portfolio

---

## ðŸ“¦ PROJECT 1: Task Management SaaS (Days 257-271, 2 weeks)
**Difficulty:** â­â­â­ Intermediate

**What It Demonstrates:** Full-stack skills, SaaS patterns, team collaboration

**Core Features:**
1. User authentication with email verification
2. Workspace/team management (multi-tenant)
3. Board views: Kanban, List, Calendar
4. Task CRUD with assignments, due dates, priorities
5. Real-time updates (WebSocket)
6. File attachments (S3)
7. Activity feed
8. Search and filters
9. Email notifications
10. Mobile responsive

**Tech Stack:**
- Frontend: React + TypeScript + TailwindCSS
- Backend: NestJS + PostgreSQL + Redis
- Real-time: Socket.io
- Storage: AWS S3 or Cloudflare R2
- Deployment: Vercel (frontend) + Railway/Render (backend)

**Stretch Goals:**
- Drag-and-drop functionality
- Time tracking
- Reporting dashboard
- API webhooks for integrations

---

## ðŸ’¬ PROJECT 2: Real-Time Chat Platform (Days 272-286, 2 weeks)
**Difficulty:** â­â­â­â­ Advanced

**What It Demonstrates:** WebSockets, real-time systems, scalability

**Core Features:**
1. User registration/login
2. One-on-one messaging
3. Group chats/channels
4. Online/offline status
5. Typing indicators
6. Message read receipts
7. File/image sharing
8. Emoji reactions
9. Message search
10. Push notifications

**Tech Stack:**
- Frontend: React + TypeScript + Socket.io client
- Backend: NestJS + PostgreSQL + Redis (pub/sub)
- WebSockets: Socket.io with Redis adapter
- Storage: AWS S3 for media
- Deployment: Docker + DigitalOcean/AWS

**Stretch Goals:**
- Voice/video calls (WebRTC)
- End-to-end encryption
- Message threading
- Giphy integration
- Custom emojis

---

## ðŸ›’ PROJECT 3: E-Commerce Platform (Days 287-301, 2 weeks)
**Difficulty:** â­â­â­â­â­ Expert

**What It Demonstrates:** Payment processing, complex business logic, admin dashboards

**Core Features:**
1. Product catalog with categories and search
2. Shopping cart (persisted, Redis)
3. Checkout flow
4. Payment processing (Stripe)
5. Order management
6. Inventory tracking
7. Admin dashboard (product/order management)
8. Email receipts and notifications
9. Customer reviews and ratings
10. Mobile responsive

**Tech Stack:**
- Frontend: React + TypeScript + Redux/Zustand
- Backend: NestJS + PostgreSQL + Redis
- Payments: Stripe
- Search: Elasticsearch (optional)
- Deployment: Kubernetes or Docker Swarm

**Stretch Goals:**
- Recommendation engine
- Discount codes/promotions
- Shipping integration
- Analytics dashboard
- Multi-vendor support

---

## ðŸ“Š PROJECT 4: Analytics Dashboard (Days 302-316, 2 weeks)
**Difficulty:** â­â­â­â­ Advanced

**What It Demonstrates:** Data visualization, complex queries, performance optimization

**Core Features:**
1. Data ingestion API (track events)
2. Real-time metrics dashboard
3. Custom date range queries
4. Multiple chart types (line, bar, pie, heatmap)
5. User segmentation
6. Funnel analysis
7. Retention cohorts
8. Export reports (CSV, PDF)
9. Dashboard sharing
10. Alerting system

**Tech Stack:**
- Frontend: React + D3.js/Recharts + TypeScript
- Backend: NestJS + PostgreSQL (TimescaleDB) + Redis
- Processing: BullMQ for async data processing
- Caching: Aggressive Redis caching
- Deployment: Docker + Cloud provider

**Stretch Goals:**
- SQL query builder UI
- Custom dashboard builder
- A/B test tracking
- Predictive analytics
- Real-time streaming

---

## ðŸŽ¥ PROJECT 5: Video Streaming Platform (Days 317-331, 2 weeks)
**Difficulty:** â­â­â­â­â­ Expert

**What It Demonstrates:** Media handling, CDN, transcoding, complex infrastructure

**Core Features:**
1. Video upload and processing
2. Transcoding to multiple resolutions
3. Adaptive bitrate streaming (HLS)
4. Video player with controls
5. Thumbnails and previews
6. Comments and likes
7. Playlists
8. Watch history
9. Search and recommendations
10. Creator dashboard

**Tech Stack:**
- Frontend: React + Video.js/Plyr
- Backend: NestJS + PostgreSQL + Redis
- Storage: AWS S3 + CloudFront
- Transcoding: AWS MediaConvert or FFmpeg
- Deployment: Docker + AWS/DigitalOcean

**Stretch Goals:**
- Live streaming
- Subtitles/captions
- Watch parties (sync viewing)
- Content moderation
- Revenue analytics

---

## ðŸ¥ PROJECT 6: Healthcare Booking System (Days 332-346, 2 weeks)
**Difficulty:** â­â­â­â­ Advanced

**What It Demonstrates:** Scheduling, complex business rules, HIPAA-aware design

**Core Features:**
1. Patient registration/login
2. Doctor profiles and availability
3. Appointment booking with time slots
4. Calendar integration
5. Email/SMS reminders
6. Video consultation integration (Zoom/Twilio)
7. Medical records upload (encrypted)
8. Prescription management
9. Payment processing
10. Admin dashboard

**Tech Stack:**
- Frontend: React + TypeScript + FullCalendar
- Backend: NestJS + PostgreSQL + Redis
- Video: Twilio or Zoom SDK
- Notifications: SendGrid + Twilio SMS
- Deployment: Docker with strict security

**Stretch Goals:**
- Insurance verification
- Telemedicine features
- EMR integration
- Multi-location support
- Waitlist management

---

## ðŸŽ“ PROJECT 7: Learning Management System (Days 347-361, 2 weeks)
**Difficulty:** â­â­â­â­â­ Expert

**What It Demonstrates:** Complex user roles, content delivery, progress tracking

**Core Features:**
1. Student/instructor/admin roles
2. Course creation and management
3. Video lessons with progress tracking
4. Quizzes and assignments
5. Grading system
6. Discussion forums
7. Certificates on completion
8. Payment/subscription for courses
9. Student dashboard
10. Instructor analytics

**Tech Stack:**
- Frontend: React + TypeScript + Redux
- Backend: NestJS + PostgreSQL + Redis
- Video: AWS S3 + CloudFront or Vimeo API
- Payments: Stripe
- Certificates: PDF generation
- Deployment: Kubernetes

**Stretch Goals:**
- Live classes (WebRTC)
- Peer review system
- Gamification (badges, leaderboards)
- Mobile app (React Native)
- AI-powered recommendations

---

## ðŸš€ PROJECT 8: Your Own SaaS Idea (Days 362-366, Final Week)
**Difficulty:** Your Choice

**Build something YOU want to use.**

**Requirements:**
- Solves a real problem (even if small)
- Has at least 3 core features
- Fully deployed and functional
- Professional branding and design
- Could charge money for it (even if you don't)

**Examples:**
- Bookmark manager with AI tagging
- Invoice generator for freelancers
- Social media scheduler
- Code snippet manager
- Habit tracker with analytics
- Budget planner
- Recipe organizer
- Fitness tracker
- Travel planner
- Pet care logger

**Why This Matters:**
- Shows initiative and creativity
- Demonstrates end-to-end ownership
- Great talking point in interviews
- Could become a real product

---

## ðŸŽ¯ FINAL MONTH STRATEGY (Days 362-366)

### Week 1: Portfolio Polish
- Professional portfolio website
- Project showcases with screenshots and demos
- Technical blog posts (write about what you built)
- Update LinkedIn with projects
- Record demo videos

### Week 2: Resume & Applications
- Update resume with all projects
- Quantify achievements (users, performance, scale)
- Write compelling project descriptions
- Apply to 50+ companies
- Reach out to recruiters

### Week 3: Interview Prep
- 50 LeetCode problems (focus on patterns)
- System design practice (all your projects)
- Mock interviews
- Behavioral question prep
- Review all project code

### Week 4: Applications & Interviews
- More applications
- First-round interviews
- Code challenges
- System design interviews
- Negotiate offers

---

## ðŸ“ˆ WHAT YOU'LL HAVE AFTER 12 MONTHS:

**Portfolio:**
- 8 production-ready, deployed applications
- 50+ GitHub contributions
- Technical blog
- Impressive GitHub profile

**Skills:**
- Full-stack development (React + NestJS)
- DevOps (Docker, Kubernetes, CI/CD)
- Cloud deployment (AWS/DigitalOcean)
- Real-time systems
- Payment processing
- Video/media handling
- Security best practices
- Testing & monitoring

**Experience:**
- Solved real problems independently
- Deployed to production
- Handled DevOps
- Worked with real users
- Built complex features

**Confidence:**
- Can build anything from scratch
- Can debug production issues
- Can talk technically in interviews
- Can explain your architectural decisions

---

## ðŸŽ“ MONTH-BY-MONTH SUMMARY:

| Month | Focus | Output |
|-------|-------|--------|
| 1-2 | JS, HTML, CSS, Git | Portfolio + 3 projects |
| 3-4 | TypeScript, Node, DBs | APIs + databases |
| 5-6 | Testing, Docker, NestJS | Production-quality backend |
| 7-8 | DevOps, K8s, Infrastructure | Deployment mastery |
| 9-10 | Project 1-4 | 4 hireable projects |
| 11-12 | Project 5-8 | 4 advanced projects + job |

**This plan turns you from tutorial-follower â†’ builder â†’ hired developer.**

Ready to commit to this? The struggle is REAL, but so are the results. ðŸ”¥

---

*Last updated: January 1, 2026*
**Topic:** TypeScript Basic Types
**Sessions:** 2

#### Session 1: Primitive Types (50 min)
**Pre-Session Questions:**
1. What types does TypeScript add to JavaScript?
2. What is type inference?

**Core Topics:**
- Type annotations
- Type inference
- Primitive types: string, number, boolean
- Arrays: `number[]` vs `Array<number>`
- Special types: any, unknown, void, never, null, undefined

**Resources:**
- [TypeScript Handbook - Everyday Types](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html) (20 min)
- [Total TypeScript Beginners](https://www.totaltypescript.com/tutorials/beginners-typescript) - START HERE

**Setup:**
```bash
mkdir ts-practice && cd ts-practice
npm init -y
npm install -D typescript ts-node @types/node
npx tsc --init
```

**Exercises:**
```typescript
// 1. Type annotations
let name: string = "John";
let age: number = 25;
let isActive: boolean = true;

// 2. Arrays
let numbers: number[] = [1, 2, 3];
let strings: Array<string> = ["a", "b", "c"];

// 3. What happens if you do this?
let value: string = 42; // Error!

// 4. Type inference - what type is this?
let inferred = "hello"; // TypeScript knows it's a string

// 5. When to use any? (Answer: almost never!)
```

**Post-Session Recall:**
1. What's the difference between `number[]` and `Array<number>`?
2. What is type inference?
3. Why should you avoid `any`?

---

#### Session 2: Functions & Object Types (50 min)
**Core Topics:**
- Function parameter types
- Return types
- Optional parameters
- Default parameters
- Object type annotations

**Exercises:**
```typescript
// 1. Type a function
function add(a: number, b: number): number {
  return a + b;
}

// 2. Optional parameter
function greet(name: string, greeting?: string): string {
  return `${greeting || "Hello"}, ${name}!`;
}

// 3. Default parameter
function createUser(name: string, role: string = "user"): object {
  return { name, role };
}

// 4. Object type
function printUser(user: { name: string; age: number }): void {
  console.log(`${user.name} is ${user.age}`);
}

// 5. Arrow function types
const multiply: (a: number, b: number) => number = (a, b) => a * b;
```

**Commit:** `Day 33: TypeScript basic types`

---

### Tuesday, Feb 3 - Day 34
**Topic:** Interfaces & Type Aliases
**Sessions:** 2

#### Session 1: Interfaces (50 min)
**Pre-Session Questions:**
1. What is an interface?
2. How do interfaces help with code quality?

**Core Topics:**
- Interface syntax
- Optional properties (`?`)
- Readonly properties
- Extending interfaces

**Resources:**
- [TypeScript Handbook - Object Types](https://www.typescriptlang.org/docs/handbook/2/objects.html) (15 min)

**Exercises:**
```typescript
// 1. Basic interface
interface User {
  id: number;
  name: string;
  email: string;
  age?: number; // optional
  readonly createdAt: Date; // readonly
}

// 2. Use the interface
const user: User = {
  id: 1,
  name: "John",
  email: "john@example.com",
  createdAt: new Date()
};

// 3. Extending interfaces
interface Admin extends User {
  permissions: string[];
}

// 4. Array of interfaces
const users: User[] = [];

// 5. Interface for function
interface MathFunc {
  (a: number, b: number): number;
}
const add: MathFunc = (a, b) => a + b;
```

**Post-Session Recall:**
1. How do you make a property optional?
2. How do you make a property readonly?
3. How do you extend an interface?

---

#### Session 2: Type Aliases & Union Types (50 min)
**Core Topics:**
- Type aliases (`type`)
- Union types (`|`)
- Intersection types (`&`)
- Literal types
- Type narrowing

**Exercises:**
```typescript
// 1. Type alias
type ID = string | number;
type Status = "pending" | "completed" | "cancelled";

// 2. Union types
function printId(id: string | number): void {
  console.log(id);
}

// 3. Type narrowing
function process(value: string | number): string {
  if (typeof value === "string") {
    return value.toUpperCase(); // TS knows it's a string here
  }
  return value.toString();
}

// 4. Intersection types
type Person = { name: string };
type Employee = { employeeId: number };
type Staff = Person & Employee;

// 5. Interface vs Type - when to use each?
// Interface: for objects, can extend, declaration merging
// Type: for unions, intersections, primitives
```

**Commit:** `Day 34: Interfaces and type aliases`

---

### Wednesday, Feb 4 - Day 35
**Topic:** Generics
**Sessions:** 2

#### Session 1: Generic Functions (50 min)
**Pre-Session Questions:**
1. What are generics?
2. Why do we need them?

**Core Topics:**
- Generic syntax `<T>`
- Generic functions
- Multiple type parameters
- Generic constraints

**Resources:**
- [TypeScript Handbook - Generics](https://www.typescriptlang.org/docs/handbook/2/generics.html) (20 min)

**Exercises:**
```typescript
// 1. Generic function
function identity<T>(value: T): T {
  return value;
}
identity<string>("hello"); // T is string
identity(42); // T inferred as number

// 2. Generic with arrays
function getFirst<T>(arr: T[]): T | undefined {
  return arr[0];
}

// 3. Multiple type parameters
function pair<T, U>(first: T, second: U): [T, U] {
  return [first, second];
}

// 4. Generic constraint
function getLength<T extends { length: number }>(item: T): number {
  return item.length;
}
getLength("hello"); // OK
getLength([1, 2, 3]); // OK
// getLength(123); // Error! number doesn't have length
```

**Post-Session Recall:**
1. What does `<T>` mean?
2. How do you constrain a generic type?
3. Write a generic `getFirst` function from memory.

---

#### Session 2: Generic Interfaces & Utility Types (50 min)
**Core Topics:**
- Generic interfaces
- Generic classes
- Utility types: `Partial`, `Pick`, `Omit`, `Record`, `Required`

**Exercises:**
```typescript
// 1. Generic interface
interface Box<T> {
  value: T;
}
const stringBox: Box<string> = { value: "hello" };

// 2. Generic interface for API response
interface ApiResponse<T> {
  data: T;
  status: number;
  message: string;
}

// 3. Utility types
interface User {
  id: number;
  name: string;
  email: string;
  password: string;
}

type PartialUser = Partial<User>; // All properties optional
type UserWithoutPassword = Omit<User, "password">;
type UserCredentials = Pick<User, "email" | "password">;

// 4. Record type
type UserRoles = Record<string, string[]>;
const roles: UserRoles = {
  admin: ["read", "write", "delete"],
  user: ["read"]
};

// 5. Create your own generic type
type Result<T> = 
  | { success: true; data: T }
  | { success: false; error: string };
```

**Commit:** `Day 35: Generics`

---

### Thursday, Feb 5 - Day 36
**Topic:** TypeScript with Node.js
**Sessions:** 2

#### Session 1: Node.js + TypeScript Setup (50 min)
**Setup a proper TypeScript Node.js project:**

```bash
mkdir ts-node-project && cd ts-node-project
npm init -y
npm install -D typescript ts-node @types/node nodemon
npx tsc --init
```

**Configure tsconfig.json:**
```json
{
  "compilerOptions": {
    "target": "ES2020",
    "module": "commonjs",
    "outDir": "./dist",
    "rootDir": "./src",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules"]
}
```

**Create src/index.ts:**
```typescript
import fs from 'fs';
import path from 'path';

interface Config {
  port: number;
  host: string;
}

const config: Config = {
  port: 3000,
  host: 'localhost'
};

console.log(`Server config: ${config.host}:${config.port}`);
```

---

#### Session 2: TypeScript Express Setup (50 min)
```bash
npm install express
npm install -D @types/express
```

**Create src/app.ts:**
```typescript
import express, { Request, Response, NextFunction } from 'express';

const app = express();
app.use(express.json());

interface User {
  id: number;
  name: string;
  email: string;
}

const users: User[] = [];

// Typed route
app.get('/users', (req: Request, res: Response) => {
  res.json(users);
});

// Typed request body
interface CreateUserBody {
  name: string;
  email: string;
}

app.post('/users', (req: Request<{}, {}, CreateUserBody>, res: Response) => {
  const { name, email } = req.body;
  const newUser: User = {
    id: users.length + 1,
    name,
    email
  };
  users.push(newUser);
  res.status(201).json(newUser);
});

app.listen(3000, () => console.log('Server running'));
```

**Commit:** `Day 36: TypeScript + Node/Express`

---

### Friday, Feb 6 - Day 37
**Topic:** TypeScript Practice
**Sessions:** 2

#### Session 1: Convert Task API to TypeScript (50 min)
Convert your Task API from Phase 1 to TypeScript:
- Add interfaces for Task, CreateTaskDTO
- Type all route handlers
- Type middleware functions

---

#### Session 2: Complete Conversion (50 min)
- Type error handlers
- Add proper types throughout
- Test everything works

**Commit:** `Day 37: Task API in TypeScript`

---

### Saturday, Feb 7 - Day 38
**Topic:** PostgreSQL Introduction
**Sessions:** 4

#### Session 1: Database Fundamentals (50 min)
**Pre-Session Questions:**
1. What is a relational database?
2. What is SQL?

**Core Topics:**
- Tables, rows, columns
- Primary keys
- Foreign keys
- Data types

**Setup PostgreSQL with Docker:**
```bash
docker run --name postgres-dev \
  -e POSTGRES_PASSWORD=password \
  -e POSTGRES_DB=mydb \
  -p 5432:5432 \
  -d postgres:14
```

**Connect with psql:**
```bash
docker exec -it postgres-dev psql -U postgres -d mydb
```

---

#### Session 2: Basic SQL (50 min)
**Core Topics:**
- CREATE TABLE
- INSERT
- SELECT
- WHERE

**Exercises:**
```sql
-- Create table
CREATE TABLE users (
  id SERIAL PRIMARY KEY,
  name VARCHAR(100) NOT NULL,
  email VARCHAR(255) UNIQUE NOT NULL,
  created_at TIMESTAMP DEFAULT NOW()
);

-- Insert
INSERT INTO users (name, email) VALUES ('John', 'john@example.com');
INSERT INTO users (name, email) VALUES ('Jane', 'jane@example.com');

-- Select
SELECT * FROM users;
SELECT name, email FROM users;
SELECT * FROM users WHERE id = 1;
SELECT * FROM users WHERE name LIKE 'J%';
```

---

#### Session 3: UPDATE, DELETE, ORDER BY (50 min)
```sql
-- Update
UPDATE users SET name = 'John Doe' WHERE id = 1;

-- Delete
DELETE FROM users WHERE id = 2;

-- Order and Limit
SELECT * FROM users ORDER BY created_at DESC;
SELECT * FROM users ORDER BY name ASC LIMIT 10;
```

---

#### Session 4: Relationships (50 min)
```sql
-- Create posts table with foreign key
CREATE TABLE posts (
  id SERIAL PRIMARY KEY,
  title VARCHAR(255) NOT NULL,
  content TEXT,
  user_id INTEGER REFERENCES users(id),
  created_at TIMESTAMP DEFAULT NOW()
);

-- Insert posts
INSERT INTO posts (title, content, user_id) 
VALUES ('First Post', 'Hello world!', 1);

-- Simple JOIN
SELECT posts.title, users.name as author
FROM posts
JOIN users ON posts.user_id = users.id;
```

**Commit:** `Day 38: PostgreSQL basics`

---

### Sunday, Feb 8 - Day 39
**Topic:** Prisma ORM
**Sessions:** 4

#### Session 1: Prisma Setup (50 min)
**Core Topics:**
- What is an ORM?
- Prisma vs raw SQL
- Prisma schema

**Setup:**
```bash
mkdir prisma-practice && cd prisma-practice
npm init -y
npm install prisma @prisma/client
npm install -D typescript ts-node @types/node
npx prisma init
```

**Configure .env:**
```
DATABASE_URL="postgresql://postgres:password@localhost:5432/mydb"
```

---

#### Session 2: Schema Definition (50 min)
**prisma/schema.prisma:**
```prisma
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id        Int      @id @default(autoincrement())
  email     String   @unique
  name      String
  posts     Post[]
  createdAt DateTime @default(now())
}

model Post {
  id        Int      @id @default(autoincrement())
  title     String
  content   String?
  published Boolean  @default(false)
  author    User     @relation(fields: [authorId], references: [id])
  authorId  Int
  createdAt DateTime @default(now())
}
```

**Run migration:**
```bash
npx prisma migrate dev --name init
npx prisma generate
```

---

#### Session 3: CRUD Operations (50 min)
```typescript
import { PrismaClient } from '@prisma/client';

const prisma = new PrismaClient();

async function main() {
  // Create
  const user = await prisma.user.create({
    data: {
      email: 'alice@example.com',
      name: 'Alice'
    }
  });

  // Read all
  const users = await prisma.user.findMany();

  // Read one
  const singleUser = await prisma.user.findUnique({
    where: { id: 1 }
  });

  // Update
  const updatedUser = await prisma.user.update({
    where: { id: 1 },
    data: { name: 'Alice Smith' }
  });

  // Delete
  await prisma.user.delete({
    where: { id: 1 }
  });
}

main()
  .catch(console.error)
  .finally(() => prisma.$disconnect());
```

---

#### Session 4: Relations & Advanced Queries (50 min)
```typescript
// Create user with posts
const userWithPosts = await prisma.user.create({
  data: {
    email: 'bob@example.com',
    name: 'Bob',
    posts: {
      create: [
        { title: 'First Post', content: 'Hello!' },
        { title: 'Second Post', content: 'World!' }
      ]
    }
  },
  include: { posts: true }
});

// Find with relations
const usersWithPosts = await prisma.user.findMany({
  include: { posts: true }
});

// Filter
const publishedPosts = await prisma.post.findMany({
  where: { published: true },
  orderBy: { createdAt: 'desc' }
});
```

**Commit:** `Day 39: Prisma ORM`

---

[Continue with remaining weeks in same detail...]

---

## Week 8-9 (Feb 9-22): Blog API with TypeScript + Prisma

[Full blog API implementation with authentication, etc.]

---

## Week 10 (Feb 23 - Mar 1): Docker

[Docker fundamentals, Dockerfile, docker-compose]

---

## Week 11-12 (Mar 2-15): Testing & CI/CD

[Jest, testing patterns, GitHub Actions]

---

## Week 13 (Mar 16-22): NestJS Introduction

[NestJS fundamentals]

---

## Week 14 (Mar 23-28): NestJS Deep Dive + Redis

[Advanced NestJS, Redis basics]

---

# PHASE 3: FRONTEND MASTERY
## March 29 - May 9 (6 weeks)

---

## Week 15-16: React Fundamentals

[Components, props, state, effects]

---

## Week 17-18: React + TypeScript

[Typing React components, hooks, events]

---

## Week 19-20: State Management & Routing

[React Router, Context, Zustand]

---

# PHASE 4: FULL-STACK + ADVANCED
## May 10 - June 14 (5 weeks)

---

## Week 21-23: Full-Stack Projects

[Blog app, Capstone project]

---

## Week 24-25: Advanced Topics

[WebSockets, Performance, Deployment]

---

# PHASE 5: INTERVIEW PREP
## June 15 - July 14 (4.5 weeks)

---

## Week 26-27: Algorithms

**LeetCode Focus - 50+ Problems**

### Daily Pattern:
- Morning (before work): 1 Easy problem (20-30 min)
- Evening Session 1: 1 Medium problem (50 min)
- Evening Session 2: Review + System Design (50 min)

### Week 26 (Jun 15-21): Arrays & Hashing
| Day | Problem | Difficulty | Pattern |
|-----|---------|------------|---------|
| Mon | Two Sum | Easy | Hash Map |
| Mon | Contains Duplicate | Easy | Hash Set |
| Tue | Valid Anagram | Easy | Hash Map |
| Tue | Group Anagrams | Medium | Hash Map |
| Wed | Top K Frequent | Medium | Hash + Heap |
| Wed | Product of Array Except Self | Medium | Prefix |
| Thu | Valid Sudoku | Medium | Hash Set |
| Thu | Encode/Decode Strings | Medium | String |
| Fri | Longest Consecutive | Medium | Hash Set |
| Sat | Review + 2 new problems | | |
| Sun | Review + 2 new problems | | |

### Week 27 (Jun 22-28): Two Pointers & Sliding Window
| Day | Problem | Difficulty | Pattern |
|-----|---------|------------|---------|
| Mon | Valid Palindrome | Easy | Two Pointers |
| Mon | Two Sum II | Medium | Two Pointers |
| Tue | 3Sum | Medium | Two Pointers |
| Tue | Container With Most Water | Medium | Two Pointers |
| Wed | Best Time Buy/Sell Stock | Easy | Sliding Window |
| Wed | Longest Substring No Repeat | Medium | Sliding Window |
| Thu | Longest Repeating Char Replace | Medium | Sliding Window |
| Thu | Minimum Window Substring | Hard | Sliding Window |
| Fri | Review all problems | | |
| Sat | Review + practice | | |
| Sun | Mock interview practice | | |

---

## Week 28-29: System Design & Mock Interviews

### System Design Topics:
1. Caching (Redis)
2. Load Balancing
3. Database Indexing
4. API Rate Limiting
5. Microservices vs Monolith
6. URL Shortener Design
7. Twitter Feed Design

### Mock Interview Practice:
- Use [Pramp](https://www.pramp.com/) for free mock interviews
- Practice explaining your projects
- STAR method for behavioral questions

---

## Week 30 (Jul 6-14): Job Applications

### Daily Routine:
- Morning: Apply to 2-3 jobs
- Evening Session 1: LeetCode (stay sharp)
- Evening Session 2: Company research / prep

### Application Targets:
- 10-15 applications per week
- Focus: Modern stack companies (React, Node.js, TypeScript)
- Target: Startups, scale-ups, remote-friendly

---

## Resources Arsenal

### Official Documentation
- [JavaScript.info](https://javascript.info) - Best JS resource
- [TypeScript Handbook](https://www.typescriptlang.org/docs/)
- [React.dev](https://react.dev/) - New React docs
- [NestJS Docs](https://docs.nestjs.com/)
- [Prisma Docs](https://www.prisma.io/docs/)

### Video Learning
- [Web Dev Simplified](https://youtube.com/@WebDevSimplified)
- [Fireship](https://youtube.com/@Fireship)
- [NeetCode](https://youtube.com/@NeetCode) - LeetCode solutions

### TypeScript
- [Total TypeScript](https://www.totaltypescript.com/) - FREE tutorials
- [React TypeScript Cheatsheet](https://react-typescript-cheatsheet.netlify.app/)

### Problem Solving
- [NeetCode.io](https://neetcode.io/) - Curated roadmap
- [LeetCode](https://leetcode.com/)
- [Big O Cheat Sheet](https://www.bigocheatsheet.com/)

### CSS
- [Flexbox Froggy](https://flexboxfroggy.com/)
- [Grid Garden](https://cssgridgarden.com/)
- [Tailwind CSS](https://tailwindcss.com/)

---

## Job Search Strategy

### Resume Tips
**Highlight:**
- Modern tech stack (React, NestJS, TypeScript, Docker)
- Portfolio projects (with live links)
- GitHub activity
- Problem-solving skills

**Your Story:**
> "Backend developer transitioning to modern full-stack development. Self-taught React, NestJS, and TypeScript through 500+ hours of intensive study. Built and deployed 5+ full-stack applications demonstrating proficiency in modern web technologies."

### Where to Apply
- LinkedIn Jobs
- Indeed
- AngelList (startups)
- We Work Remotely
- Company websites directly

---

## Final Checklist

### By July 14, 2026, you will have:

**Portfolio Projects:**
- [ ] Todo App (vanilla JS)
- [ ] Weather App (API integration)
- [ ] Task API (Express + TS)
- [ ] Blog API (NestJS + Prisma + Docker)
- [ ] React Dashboard
- [ ] Full-Stack Capstone

**Skills:**
- [ ] JavaScript ES6+ mastery
- [ ] TypeScript proficiency
- [ ] React + hooks
- [ ] Node.js + Express
- [ ] NestJS basics
- [ ] PostgreSQL + Prisma
- [ ] Docker basics
- [ ] Git workflow
- [ ] REST API design
- [ ] Basic testing
- [ ] CI/CD basics

**LeetCode:**
- [ ] 50+ problems solved
- [ ] Common patterns known
- [ ] Can explain solutions

**Soft Skills:**
- [ ] Can explain projects clearly
- [ ] STAR method prepared
- [ ] Technical communication

---

## The Promise

**If you follow this plan:**

**By July 14, 2026:**
- 500+ hours of focused learning
- 5-7 portfolio projects deployed
- 50+ LeetCode problems solved
- 196 days of consistency
- Ready for whatever comes next

---

**Start: Thursday, January 1, 2026**
**End: Tuesday, July 14, 2026**
**Mission: Become a Hireable Modern Developer**

**LET'S GO.** ðŸ”¥

---

*Last updated: January 1, 2026*
